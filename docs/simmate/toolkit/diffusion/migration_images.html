<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 11.0.0"/>
    <title>simmate.toolkit.diffusion.migration_images API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(:first-of-type){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc > section:first-of-type details > summary{top:-20px;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../diffusion.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;simmate.toolkit.diffusion</a>

<a href="https://github.com/jacksund/simmate">            <img src="https://github.com/jacksund/simmate/blob/main/src/simmate/website/static_files/images/simmate-logo.svg?raw=true" class="logo" alt="project logo"/>
</a>
            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#MigrationImages">MigrationImages</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#MigrationImages.__init__">MigrationImages</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.get_sum_structure">get_sum_structure</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.get_nimages">get_nimages</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.from_migration_hop">from_migration_hop</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.from_endpoints">from_endpoints</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.from_startend_sites">from_startend_sites</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.from_structure">from_structure</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.from_dynamic">from_dynamic</a>
                        </li>
                        <li>
                                <a class="function" href="#MigrationImages.as_dict">as_dict</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                        <a class="pdoc-button git-button" href="https://github.com/jacksund/simmate/tree/main/src/simmate/toolkit/diffusion/migration_images.py">Edit on GitHub</a>
                    <h1 class="modulename">
<a href="./../../../simmate.html">simmate</a><wbr>.<a href="./../../toolkit.html">toolkit</a><wbr>.<a href="./../diffusion.html">diffusion</a><wbr>.migration_images    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">simmate.toolkit</span> <span class="kn">import</span> <span class="n">Structure</span>

<span class="kn">from</span> <span class="nn">pymatgen.analysis.diffusion.neb.pathfinder</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DistinctPathFinder</span><span class="p">,</span>
    <span class="n">MigrationHop</span> <span class="k">as</span> <span class="n">PymatgenMigrationHop</span><span class="p">,</span>
    <span class="n">IDPPSolver</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">MigrationImages</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is just a list of structures for a diffusion pathway. It has</span>
<span class="sd">    utility methods to help create these structures but otherwise behaves</span>
<span class="sd">    exactly like a python list.</span>

<span class="sd">    Note, this class is primarily used to generate inputs for calculations. If</span>
<span class="sd">    you&#39;d like more advanced features, you should represent your diffusion</span>
<span class="sd">    pathway as a MigrationHop instead.As a rule of thumb: Only use this class</span>
<span class="sd">    if you are manually creating your pathway from endpoint supercells or from</span>
<span class="sd">    a set of supercell images.</span>

<span class="sd">    All MigrationHop&#39;s can be converted to MigrationImages (using the</span>
<span class="sd">    `from_migration_hop` method); but not all MigrationImages can be converted</span>
<span class="sd">    to MigrationHops.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Structure</span><span class="p">]):</span>
        <span class="c1"># This init function does nothing except apply typing -- specifically,</span>
        <span class="c1"># it says that it expects a list of structures.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sum_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes all structures and combines them into one. Atoms that are within</span>
<span class="sd">        the given tolerance are joined into a single site.</span>

<span class="sd">        This is primarily used to view a diffusing pathway within a single</span>
<span class="sd">        structure -- as well as how the host lattice changes during diffusion.</span>
<span class="sd">        If you are able to convert your pathway to a MigrationHop, the</span>
<span class="sd">        MigrationHop.write_path() method is much faster and cleaner than this</span>
<span class="sd">        method, so it should be preffered. Also, because there are many atoms</span>
<span class="sd">        that are overlapping here, the output structure may cause programs</span>
<span class="sd">        like VESTA to crash.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `tolerance`:</span>
<span class="sd">            the angle and distance tolerance to consider fractional coordinates</span>
<span class="sd">            as matching. Matching sites will be merged as 1 site in the final</span>
<span class="sd">            sum structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># OPTIMIZE: this is very inefficient. It&#39;s much faster to visualize</span>
        <span class="c1"># structures with MigrationHop class because you know which atom is</span>
        <span class="c1"># moving. Here, we need to treat all atoms as moving. We can also</span>
        <span class="c1"># speed this up by only looking at diffusing species too.</span>
        <span class="n">final_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># recall self is a list of structures</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
                <span class="n">is_new</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">final_coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                            <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                            <span class="n">coords</span><span class="p">,</span>
                            <span class="n">rtol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                            <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">is_new</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">is_new</span><span class="p">:</span>
                    <span class="n">final_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                    <span class="n">final_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span>

        <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">final_species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">final_coords</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">structure</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_nimages</span><span class="p">(</span>
        <span class="n">pathway_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_image_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span>
        <span class="n">require_midpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the desirable number of images (not including start/end structures).</span>

<span class="sd">        This method helps generate a MigrationImages object, and typically is</span>
<span class="sd">        not called directly. The other classmethods of MigrationImages call</span>
<span class="sd">        this for you.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `pathway_length`:</span>
<span class="sd">            The length of the pathway.</span>

<span class="sd">        - `min_image_step`:</span>
<span class="sd">            The minimum step distance for the diffusing atom between images.</span>
<span class="sd">            The default is 0.7 Angstroms. For example, a path 2.8A long would</span>
<span class="sd">            require at least 4 images for this default.</span>

<span class="sd">        - `require_midpoint`:</span>
<span class="sd">            Whether there should be an image at the midpoint. In other words,</span>
<span class="sd">            whether the number of images should be odd. This is often important</span>
<span class="sd">            if you expect the transition state to be at the midpoint and you are</span>
<span class="sd">            not running CI-NEB. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of images to use for this pathway.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># At a minimum, we want to have images be 0.7 angstroms apart, and</span>
        <span class="c1"># with one additional image.</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="n">pathway_length</span> <span class="o">//</span> <span class="n">min_image_step</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># We also want an odd number of images. This ensures we have an image</span>
        <span class="c1"># at exactly the midpoint, which is often necessary if we aren&#39;t</span>
        <span class="c1"># running CI-NEB.</span>
        <span class="k">if</span> <span class="n">require_midpoint</span> <span class="ow">and</span> <span class="n">nimages</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nimages</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># This is a float but it makes more sense to have an integer</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_migration_hop</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">migration_hop</span><span class="p">:</span> <span class="n">PymatgenMigrationHop</span><span class="p">,</span>
        <span class="n">vacancy_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
        <span class="n">max_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
        <span class="n">min_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a MigrationHop object</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `migration_hop`:</span>
<span class="sd">            The MigrationHop object that should be converted.</span>

<span class="sd">        - `vacancy_mode`:</span>
<span class="sd">            Whether to use single-vacancy diffusion (True) or interstitial</span>
<span class="sd">            diffusion (False). The default is True.</span>

<span class="sd">        - `min_nsites`:</span>
<span class="sd">            The minimum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 80.</span>

<span class="sd">        - `max_nsites`:</span>
<span class="sd">            The maximum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 240.</span>

<span class="sd">        - `min_length`:</span>
<span class="sd">            The minimum length for each vector in the supercell structure.</span>
<span class="sd">            The default is 10 Angstroms.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The third thing returned is the bulk_supercell which we don&#39;t need.</span>
        <span class="n">start_supercell</span><span class="p">,</span> <span class="n">end_supercell</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">migration_hop</span><span class="o">.</span><span class="n">get_sc_structures</span><span class="p">(</span>
            <span class="n">vac_mode</span><span class="o">=</span><span class="n">vacancy_mode</span><span class="p">,</span>
            <span class="n">min_atoms</span><span class="o">=</span><span class="n">min_nsites</span><span class="p">,</span>
            <span class="n">max_atoms</span><span class="o">=</span><span class="n">max_nsites</span><span class="p">,</span>
            <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># calculate the number of images required</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_nimages</span><span class="p">(</span><span class="n">migration_hop</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="n">start_supercell</span><span class="p">,</span>
            <span class="n">end_supercell</span><span class="p">,</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_endpoints</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure_start</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">structure_end</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">nimages</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from start and end supercell structures.</span>
<span class="sd">        You do not need to specify the diffusing atom(s) as all sites are</span>
<span class="sd">        linearly interpolated and then relaxed by IDPP.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure_start`:</span>
<span class="sd">            The starting supercell of the diffusion pathway.</span>

<span class="sd">        - `structure_end`:</span>
<span class="sd">            The ending supercell of the diffusion pathway.</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of desired images for the pathway. Note, if you know the</span>
<span class="sd">            pathway length of your path, you can use the `get_nimages` static</span>
<span class="sd">            method to get a logical number of images.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Run IDPP relaxation on the images before returning them</span>
        <span class="n">idpp_solver</span> <span class="o">=</span> <span class="n">IDPPSolver</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">structure_start</span><span class="p">,</span> <span class="n">structure_end</span><span class="p">],</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">idpp_solver</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_startend_sites</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">site_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">site_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a bulk structure and start/end</span>
<span class="sd">        periodic sites of the diffusing atom.</span>

<span class="sd">        For example, this would allow a diffusion pathway that goes from a site</span>
<span class="sd">        at (0,0,0) to (1,1,1). Thus, symmetry and periodic boundry conditions</span>
<span class="sd">        are considered.</span>

<span class="sd">        Note, this method just creates a MigrationHop and then uses the</span>
<span class="sd">        `from_migration_hop` method to make a MigrationImages object.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `site_start`:</span>
<span class="sd">            The starting periodic site for this pathway.</span>

<span class="sd">        - `site_end`:</span>
<span class="sd">            The end periodic site for this pathway.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This information is all we need for a MigrationHop object</span>
        <span class="n">pathway</span> <span class="o">=</span> <span class="n">PymatgenMigrationHop</span><span class="p">(</span><span class="n">site_start</span><span class="p">,</span> <span class="n">site_end</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span><span class="n">pathway</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">migrating_specie</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">pathfinder_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a bulk crystal structure, this will find all symmetrically</span>
<span class="sd">        unique pathways and return them as list of MigrationImages objects.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `migrating_specie`:</span>
<span class="sd">            The identity of the diffusing ion (e.g. &quot;Li&quot; or &quot;Li1+&quot;). Note, only</span>
<span class="sd">            provide oxidation state if you are using an oxidation-state decorated</span>
<span class="sd">            structure.</span>

<span class="sd">        - `pathfinder_kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by DistinctPathFinder, but</span>
<span class="sd">            given as a dictionary. The default is {}.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert to the LLL reduced primitive cell to make it as cubic as possible</span>
        <span class="n">structure_lll</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_sanitized_structure</span><span class="p">()</span>

        <span class="c1"># Use pymatgen to find all the symmetrically unique pathways.</span>
        <span class="c1"># NOTE: This only finds pathways up until the structure is percolating.</span>
        <span class="c1"># If you are interested in longer pathways, then this script needs to</span>
        <span class="c1"># be adjusted by passing additional kwargs</span>
        <span class="n">pathfinder</span> <span class="o">=</span> <span class="n">DistinctPathFinder</span><span class="p">(</span>
            <span class="n">structure_lll</span><span class="p">,</span>
            <span class="n">migrating_specie</span><span class="o">=</span><span class="n">migrating_specie</span><span class="p">,</span>
            <span class="o">**</span><span class="n">pathfinder_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pathways</span> <span class="o">=</span> <span class="n">pathfinder</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="c1"># Now go through each path and convert to a MigrationPath. We return</span>
        <span class="c1"># these as a list of paths.</span>
        <span class="n">migration_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pathway</span> <span class="ow">in</span> <span class="n">pathways</span><span class="p">:</span>

            <span class="n">migration_path</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span>
                <span class="n">migration_hop</span><span class="o">=</span><span class="n">pathway</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">migration_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">migration_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">migration_paths</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dynamic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">migration_images</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an experimental feature. The code here is a repurposing of</span>
<span class="sd">        Structre.from_dynamic so consider making a general class for</span>
<span class="sd">        from_dynamic methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># assume any list is in the MigrationHop format if there are more than</span>
        <span class="c1"># two structures (i.e. there is at least one midpoint image)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">migration_images</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">migration_images</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">migration_images_cleaned</span> <span class="o">=</span> <span class="n">migration_images</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown format provided for migration_images input.&quot;</span><span class="p">)</span>

        <span class="n">migration_images_cleaned</span><span class="o">.</span><span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="n">is_from_past_calc</span>

        <span class="k">return</span> <span class="n">migration_images_cleaned</span>

    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</pre></div>

        </details>

            </section>
                <section id="MigrationImages">
                                <div class="attr class">
        <a class="headerlink" href="#MigrationImages">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">MigrationImages</span><wbr>(<span class="base">builtins.list</span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MigrationImages</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is just a list of structures for a diffusion pathway. It has</span>
<span class="sd">    utility methods to help create these structures but otherwise behaves</span>
<span class="sd">    exactly like a python list.</span>

<span class="sd">    Note, this class is primarily used to generate inputs for calculations. If</span>
<span class="sd">    you&#39;d like more advanced features, you should represent your diffusion</span>
<span class="sd">    pathway as a MigrationHop instead.As a rule of thumb: Only use this class</span>
<span class="sd">    if you are manually creating your pathway from endpoint supercells or from</span>
<span class="sd">    a set of supercell images.</span>

<span class="sd">    All MigrationHop&#39;s can be converted to MigrationImages (using the</span>
<span class="sd">    `from_migration_hop` method); but not all MigrationImages can be converted</span>
<span class="sd">    to MigrationHops.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Structure</span><span class="p">]):</span>
        <span class="c1"># This init function does nothing except apply typing -- specifically,</span>
        <span class="c1"># it says that it expects a list of structures.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sum_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes all structures and combines them into one. Atoms that are within</span>
<span class="sd">        the given tolerance are joined into a single site.</span>

<span class="sd">        This is primarily used to view a diffusing pathway within a single</span>
<span class="sd">        structure -- as well as how the host lattice changes during diffusion.</span>
<span class="sd">        If you are able to convert your pathway to a MigrationHop, the</span>
<span class="sd">        MigrationHop.write_path() method is much faster and cleaner than this</span>
<span class="sd">        method, so it should be preffered. Also, because there are many atoms</span>
<span class="sd">        that are overlapping here, the output structure may cause programs</span>
<span class="sd">        like VESTA to crash.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `tolerance`:</span>
<span class="sd">            the angle and distance tolerance to consider fractional coordinates</span>
<span class="sd">            as matching. Matching sites will be merged as 1 site in the final</span>
<span class="sd">            sum structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># OPTIMIZE: this is very inefficient. It&#39;s much faster to visualize</span>
        <span class="c1"># structures with MigrationHop class because you know which atom is</span>
        <span class="c1"># moving. Here, we need to treat all atoms as moving. We can also</span>
        <span class="c1"># speed this up by only looking at diffusing species too.</span>
        <span class="n">final_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># recall self is a list of structures</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
                <span class="n">is_new</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">final_coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                            <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                            <span class="n">coords</span><span class="p">,</span>
                            <span class="n">rtol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                            <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">is_new</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">is_new</span><span class="p">:</span>
                    <span class="n">final_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                    <span class="n">final_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span>

        <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">final_species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">final_coords</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">structure</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_nimages</span><span class="p">(</span>
        <span class="n">pathway_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_image_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span>
        <span class="n">require_midpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the desirable number of images (not including start/end structures).</span>

<span class="sd">        This method helps generate a MigrationImages object, and typically is</span>
<span class="sd">        not called directly. The other classmethods of MigrationImages call</span>
<span class="sd">        this for you.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `pathway_length`:</span>
<span class="sd">            The length of the pathway.</span>

<span class="sd">        - `min_image_step`:</span>
<span class="sd">            The minimum step distance for the diffusing atom between images.</span>
<span class="sd">            The default is 0.7 Angstroms. For example, a path 2.8A long would</span>
<span class="sd">            require at least 4 images for this default.</span>

<span class="sd">        - `require_midpoint`:</span>
<span class="sd">            Whether there should be an image at the midpoint. In other words,</span>
<span class="sd">            whether the number of images should be odd. This is often important</span>
<span class="sd">            if you expect the transition state to be at the midpoint and you are</span>
<span class="sd">            not running CI-NEB. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of images to use for this pathway.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># At a minimum, we want to have images be 0.7 angstroms apart, and</span>
        <span class="c1"># with one additional image.</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="n">pathway_length</span> <span class="o">//</span> <span class="n">min_image_step</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># We also want an odd number of images. This ensures we have an image</span>
        <span class="c1"># at exactly the midpoint, which is often necessary if we aren&#39;t</span>
        <span class="c1"># running CI-NEB.</span>
        <span class="k">if</span> <span class="n">require_midpoint</span> <span class="ow">and</span> <span class="n">nimages</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nimages</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># This is a float but it makes more sense to have an integer</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_migration_hop</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">migration_hop</span><span class="p">:</span> <span class="n">PymatgenMigrationHop</span><span class="p">,</span>
        <span class="n">vacancy_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
        <span class="n">max_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
        <span class="n">min_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a MigrationHop object</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `migration_hop`:</span>
<span class="sd">            The MigrationHop object that should be converted.</span>

<span class="sd">        - `vacancy_mode`:</span>
<span class="sd">            Whether to use single-vacancy diffusion (True) or interstitial</span>
<span class="sd">            diffusion (False). The default is True.</span>

<span class="sd">        - `min_nsites`:</span>
<span class="sd">            The minimum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 80.</span>

<span class="sd">        - `max_nsites`:</span>
<span class="sd">            The maximum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 240.</span>

<span class="sd">        - `min_length`:</span>
<span class="sd">            The minimum length for each vector in the supercell structure.</span>
<span class="sd">            The default is 10 Angstroms.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The third thing returned is the bulk_supercell which we don&#39;t need.</span>
        <span class="n">start_supercell</span><span class="p">,</span> <span class="n">end_supercell</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">migration_hop</span><span class="o">.</span><span class="n">get_sc_structures</span><span class="p">(</span>
            <span class="n">vac_mode</span><span class="o">=</span><span class="n">vacancy_mode</span><span class="p">,</span>
            <span class="n">min_atoms</span><span class="o">=</span><span class="n">min_nsites</span><span class="p">,</span>
            <span class="n">max_atoms</span><span class="o">=</span><span class="n">max_nsites</span><span class="p">,</span>
            <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># calculate the number of images required</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_nimages</span><span class="p">(</span><span class="n">migration_hop</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="n">start_supercell</span><span class="p">,</span>
            <span class="n">end_supercell</span><span class="p">,</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_endpoints</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure_start</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">structure_end</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">nimages</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from start and end supercell structures.</span>
<span class="sd">        You do not need to specify the diffusing atom(s) as all sites are</span>
<span class="sd">        linearly interpolated and then relaxed by IDPP.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure_start`:</span>
<span class="sd">            The starting supercell of the diffusion pathway.</span>

<span class="sd">        - `structure_end`:</span>
<span class="sd">            The ending supercell of the diffusion pathway.</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of desired images for the pathway. Note, if you know the</span>
<span class="sd">            pathway length of your path, you can use the `get_nimages` static</span>
<span class="sd">            method to get a logical number of images.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Run IDPP relaxation on the images before returning them</span>
        <span class="n">idpp_solver</span> <span class="o">=</span> <span class="n">IDPPSolver</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">structure_start</span><span class="p">,</span> <span class="n">structure_end</span><span class="p">],</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">idpp_solver</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_startend_sites</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">site_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">site_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a bulk structure and start/end</span>
<span class="sd">        periodic sites of the diffusing atom.</span>

<span class="sd">        For example, this would allow a diffusion pathway that goes from a site</span>
<span class="sd">        at (0,0,0) to (1,1,1). Thus, symmetry and periodic boundry conditions</span>
<span class="sd">        are considered.</span>

<span class="sd">        Note, this method just creates a MigrationHop and then uses the</span>
<span class="sd">        `from_migration_hop` method to make a MigrationImages object.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `site_start`:</span>
<span class="sd">            The starting periodic site for this pathway.</span>

<span class="sd">        - `site_end`:</span>
<span class="sd">            The end periodic site for this pathway.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This information is all we need for a MigrationHop object</span>
        <span class="n">pathway</span> <span class="o">=</span> <span class="n">PymatgenMigrationHop</span><span class="p">(</span><span class="n">site_start</span><span class="p">,</span> <span class="n">site_end</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span><span class="n">pathway</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">migrating_specie</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">pathfinder_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a bulk crystal structure, this will find all symmetrically</span>
<span class="sd">        unique pathways and return them as list of MigrationImages objects.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `migrating_specie`:</span>
<span class="sd">            The identity of the diffusing ion (e.g. &quot;Li&quot; or &quot;Li1+&quot;). Note, only</span>
<span class="sd">            provide oxidation state if you are using an oxidation-state decorated</span>
<span class="sd">            structure.</span>

<span class="sd">        - `pathfinder_kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by DistinctPathFinder, but</span>
<span class="sd">            given as a dictionary. The default is {}.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert to the LLL reduced primitive cell to make it as cubic as possible</span>
        <span class="n">structure_lll</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_sanitized_structure</span><span class="p">()</span>

        <span class="c1"># Use pymatgen to find all the symmetrically unique pathways.</span>
        <span class="c1"># NOTE: This only finds pathways up until the structure is percolating.</span>
        <span class="c1"># If you are interested in longer pathways, then this script needs to</span>
        <span class="c1"># be adjusted by passing additional kwargs</span>
        <span class="n">pathfinder</span> <span class="o">=</span> <span class="n">DistinctPathFinder</span><span class="p">(</span>
            <span class="n">structure_lll</span><span class="p">,</span>
            <span class="n">migrating_specie</span><span class="o">=</span><span class="n">migrating_specie</span><span class="p">,</span>
            <span class="o">**</span><span class="n">pathfinder_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pathways</span> <span class="o">=</span> <span class="n">pathfinder</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="c1"># Now go through each path and convert to a MigrationPath. We return</span>
        <span class="c1"># these as a list of paths.</span>
        <span class="n">migration_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pathway</span> <span class="ow">in</span> <span class="n">pathways</span><span class="p">:</span>

            <span class="n">migration_path</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span>
                <span class="n">migration_hop</span><span class="o">=</span><span class="n">pathway</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">migration_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">migration_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">migration_paths</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dynamic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">migration_images</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an experimental feature. The code here is a repurposing of</span>
<span class="sd">        Structre.from_dynamic so consider making a general class for</span>
<span class="sd">        from_dynamic methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># assume any list is in the MigrationHop format if there are more than</span>
        <span class="c1"># two structures (i.e. there is at least one midpoint image)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">migration_images</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">migration_images</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">migration_images_cleaned</span> <span class="o">=</span> <span class="n">migration_images</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown format provided for migration_images input.&quot;</span><span class="p">)</span>

        <span class="n">migration_images_cleaned</span><span class="o">.</span><span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="n">is_from_past_calc</span>

        <span class="k">return</span> <span class="n">migration_images_cleaned</span>

    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class is just a list of structures for a diffusion pathway. It has
utility methods to help create these structures but otherwise behaves
exactly like a python list.</p>

<p>Note, this class is primarily used to generate inputs for calculations. If
you'd like more advanced features, you should represent your diffusion
pathway as a MigrationHop instead.As a rule of thumb: Only use this class
if you are manually creating your pathway from endpoint supercells or from
a set of supercell images.</p>

<p>All MigrationHop's can be converted to MigrationImages (using the
<code><a href="#MigrationImages.from_migration_hop">from_migration_hop</a></code> method); but not all MigrationImages can be converted
to MigrationHops.</p>
</div>


                            <div id="MigrationImages.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">MigrationImages</span><span class="signature">(
    structures: List[<a href="../base_data_types/structure.html#Structure">simmate.toolkit.base_data_types.structure.Structure</a>]
)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Structure</span><span class="p">]):</span>
        <span class="c1"># This init function does nothing except apply typing -- specifically,</span>
        <span class="c1"># it says that it expects a list of structures.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="MigrationImages.get_sum_structure" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.get_sum_structure">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_sum_structure</span><span class="signature">(self, tolerance: float = 0.001)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_sum_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes all structures and combines them into one. Atoms that are within</span>
<span class="sd">        the given tolerance are joined into a single site.</span>

<span class="sd">        This is primarily used to view a diffusing pathway within a single</span>
<span class="sd">        structure -- as well as how the host lattice changes during diffusion.</span>
<span class="sd">        If you are able to convert your pathway to a MigrationHop, the</span>
<span class="sd">        MigrationHop.write_path() method is much faster and cleaner than this</span>
<span class="sd">        method, so it should be preffered. Also, because there are many atoms</span>
<span class="sd">        that are overlapping here, the output structure may cause programs</span>
<span class="sd">        like VESTA to crash.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `tolerance`:</span>
<span class="sd">            the angle and distance tolerance to consider fractional coordinates</span>
<span class="sd">            as matching. Matching sites will be merged as 1 site in the final</span>
<span class="sd">            sum structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># OPTIMIZE: this is very inefficient. It&#39;s much faster to visualize</span>
        <span class="c1"># structures with MigrationHop class because you know which atom is</span>
        <span class="c1"># moving. Here, we need to treat all atoms as moving. We can also</span>
        <span class="c1"># speed this up by only looking at diffusing species too.</span>
        <span class="n">final_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># recall self is a list of structures</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
                <span class="n">is_new</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">final_coords</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                            <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                            <span class="n">coords</span><span class="p">,</span>
                            <span class="n">rtol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                            <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">is_new</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">is_new</span><span class="p">:</span>
                    <span class="n">final_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                    <span class="n">final_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span>

        <span class="n">structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">final_species</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">final_coords</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">structure</span>
</pre></div>

        </details>

            <div class="docstring"><p>Takes all structures and combines them into one. Atoms that are within
the given tolerance are joined into a single site.</p>

<p>This is primarily used to view a diffusing pathway within a single
structure -- as well as how the host lattice changes during diffusion.
If you are able to convert your pathway to a MigrationHop, the
MigrationHop.write_path() method is much faster and cleaner than this
method, so it should be preffered. Also, because there are many atoms
that are overlapping here, the output structure may cause programs
like VESTA to crash.</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><code>tolerance</code>:
the angle and distance tolerance to consider fractional coordinates
as matching. Matching sites will be merged as 1 site in the final
sum structure.</li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.get_nimages" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.get_nimages">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">get_nimages</span><span class="signature">(
    pathway_length: float,
    min_image_step: float = 0.7,
    require_midpoint: bool = True
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_nimages</span><span class="p">(</span>
        <span class="n">pathway_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_image_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span>
        <span class="n">require_midpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the desirable number of images (not including start/end structures).</span>

<span class="sd">        This method helps generate a MigrationImages object, and typically is</span>
<span class="sd">        not called directly. The other classmethods of MigrationImages call</span>
<span class="sd">        this for you.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `pathway_length`:</span>
<span class="sd">            The length of the pathway.</span>

<span class="sd">        - `min_image_step`:</span>
<span class="sd">            The minimum step distance for the diffusing atom between images.</span>
<span class="sd">            The default is 0.7 Angstroms. For example, a path 2.8A long would</span>
<span class="sd">            require at least 4 images for this default.</span>

<span class="sd">        - `require_midpoint`:</span>
<span class="sd">            Whether there should be an image at the midpoint. In other words,</span>
<span class="sd">            whether the number of images should be odd. This is often important</span>
<span class="sd">            if you expect the transition state to be at the midpoint and you are</span>
<span class="sd">            not running CI-NEB. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of images to use for this pathway.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># At a minimum, we want to have images be 0.7 angstroms apart, and</span>
        <span class="c1"># with one additional image.</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="n">pathway_length</span> <span class="o">//</span> <span class="n">min_image_step</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># We also want an odd number of images. This ensures we have an image</span>
        <span class="c1"># at exactly the midpoint, which is often necessary if we aren&#39;t</span>
        <span class="c1"># running CI-NEB.</span>
        <span class="k">if</span> <span class="n">require_midpoint</span> <span class="ow">and</span> <span class="n">nimages</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nimages</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># This is a float but it makes more sense to have an integer</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nimages</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gives the desirable number of images (not including start/end structures).</p>

<p>This method helps generate a MigrationImages object, and typically is
not called directly. The other classmethods of MigrationImages call
this for you.</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><p><code>pathway_length</code>:
The length of the pathway.</p></li>
<li><p><code>min_image_step</code>:
The minimum step distance for the diffusing atom between images.
The default is 0.7 Angstroms. For example, a path 2.8A long would
require at least 4 images for this default.</p></li>
<li><p><code>require_midpoint</code>:
Whether there should be an image at the midpoint. In other words,
whether the number of images should be odd. This is often important
if you expect the transition state to be at the midpoint and you are
not running CI-NEB. The default is True.</p></li>
</ul>

<h2 id="returns">Returns</h2>

<ul>
<li><code>nimages</code>:
The number of images to use for this pathway.</li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.from_migration_hop" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.from_migration_hop">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_migration_hop</span><span class="signature">(
    cls,
    migration_hop: pymatgen.analysis.diffusion.neb.pathfinder.MigrationHop,
    vacancy_mode: bool = True,
    min_nsites: int = 80,
    max_nsites: int = 240,
    min_length: int = 10,
    **kwargs
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_migration_hop</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">migration_hop</span><span class="p">:</span> <span class="n">PymatgenMigrationHop</span><span class="p">,</span>
        <span class="n">vacancy_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
        <span class="n">max_nsites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
        <span class="n">min_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a MigrationHop object</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `migration_hop`:</span>
<span class="sd">            The MigrationHop object that should be converted.</span>

<span class="sd">        - `vacancy_mode`:</span>
<span class="sd">            Whether to use single-vacancy diffusion (True) or interstitial</span>
<span class="sd">            diffusion (False). The default is True.</span>

<span class="sd">        - `min_nsites`:</span>
<span class="sd">            The minimum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 80.</span>

<span class="sd">        - `max_nsites`:</span>
<span class="sd">            The maximum number of sites to have in the supercell structure.</span>
<span class="sd">            The default is 240.</span>

<span class="sd">        - `min_length`:</span>
<span class="sd">            The minimum length for each vector in the supercell structure.</span>
<span class="sd">            The default is 10 Angstroms.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The third thing returned is the bulk_supercell which we don&#39;t need.</span>
        <span class="n">start_supercell</span><span class="p">,</span> <span class="n">end_supercell</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">migration_hop</span><span class="o">.</span><span class="n">get_sc_structures</span><span class="p">(</span>
            <span class="n">vac_mode</span><span class="o">=</span><span class="n">vacancy_mode</span><span class="p">,</span>
            <span class="n">min_atoms</span><span class="o">=</span><span class="n">min_nsites</span><span class="p">,</span>
            <span class="n">max_atoms</span><span class="o">=</span><span class="n">max_nsites</span><span class="p">,</span>
            <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># calculate the number of images required</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_nimages</span><span class="p">(</span><span class="n">migration_hop</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="n">start_supercell</span><span class="p">,</span>
            <span class="n">end_supercell</span><span class="p">,</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a MigrationImages object from a MigrationHop object</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><p><code>migration_hop</code>:
The MigrationHop object that should be converted.</p></li>
<li><p><code>vacancy_mode</code>:
Whether to use single-vacancy diffusion (True) or interstitial
diffusion (False). The default is True.</p></li>
<li><p><code>min_nsites</code>:
The minimum number of sites to have in the supercell structure.
The default is 80.</p></li>
<li><p><code>max_nsites</code>:
The maximum number of sites to have in the supercell structure.
The default is 240.</p></li>
<li><p><code>min_length</code>:
The minimum length for each vector in the supercell structure.
The default is 10 Angstroms.</p></li>
<li><p><code>**kwargs</code>:
Any arguments that are normally accepted by IDPPSolver</p></li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.from_endpoints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.from_endpoints">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_endpoints</span><span class="signature">(
    cls,
    structure_start: <a href="../base_data_types/structure.html#Structure">simmate.toolkit.base_data_types.structure.Structure</a>,
    structure_end: <a href="../base_data_types/structure.html#Structure">simmate.toolkit.base_data_types.structure.Structure</a>,
    nimages: int,
    **kwargs
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_endpoints</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure_start</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">structure_end</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">nimages</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from start and end supercell structures.</span>
<span class="sd">        You do not need to specify the diffusing atom(s) as all sites are</span>
<span class="sd">        linearly interpolated and then relaxed by IDPP.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure_start`:</span>
<span class="sd">            The starting supercell of the diffusion pathway.</span>

<span class="sd">        - `structure_end`:</span>
<span class="sd">            The ending supercell of the diffusion pathway.</span>

<span class="sd">        - `nimages`:</span>
<span class="sd">            The number of desired images for the pathway. Note, if you know the</span>
<span class="sd">            pathway length of your path, you can use the `get_nimages` static</span>
<span class="sd">            method to get a logical number of images.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by IDPPSolver</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Run IDPP relaxation on the images before returning them</span>
        <span class="n">idpp_solver</span> <span class="o">=</span> <span class="n">IDPPSolver</span><span class="o">.</span><span class="n">from_endpoints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">structure_start</span><span class="p">,</span> <span class="n">structure_end</span><span class="p">],</span>
            <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">idpp_solver</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a MigrationImages object from start and end supercell structures.
You do not need to specify the diffusing atom(s) as all sites are
linearly interpolated and then relaxed by IDPP.</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><p><code>structure_start</code>:
The starting supercell of the diffusion pathway.</p></li>
<li><p><code>structure_end</code>:
The ending supercell of the diffusion pathway.</p></li>
<li><p><code>nimages</code>:
The number of desired images for the pathway. Note, if you know the
pathway length of your path, you can use the <code><a href="#MigrationImages.get_nimages">get_nimages</a></code> static
method to get a logical number of images.</p></li>
<li><p><code>**kwargs</code>:
Any arguments that are normally accepted by IDPPSolver</p></li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.from_startend_sites" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.from_startend_sites">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_startend_sites</span><span class="signature">(
    cls,
    structure: <a href="../base_data_types/structure.html#Structure">simmate.toolkit.base_data_types.structure.Structure</a>,
    site_start: int,
    site_end: int,
    **kwargs
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_startend_sites</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">site_start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">site_end</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a MigrationImages object from a bulk structure and start/end</span>
<span class="sd">        periodic sites of the diffusing atom.</span>

<span class="sd">        For example, this would allow a diffusion pathway that goes from a site</span>
<span class="sd">        at (0,0,0) to (1,1,1). Thus, symmetry and periodic boundry conditions</span>
<span class="sd">        are considered.</span>

<span class="sd">        Note, this method just creates a MigrationHop and then uses the</span>
<span class="sd">        `from_migration_hop` method to make a MigrationImages object.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `site_start`:</span>
<span class="sd">            The starting periodic site for this pathway.</span>

<span class="sd">        - `site_end`:</span>
<span class="sd">            The end periodic site for this pathway.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This information is all we need for a MigrationHop object</span>
        <span class="n">pathway</span> <span class="o">=</span> <span class="n">PymatgenMigrationHop</span><span class="p">(</span><span class="n">site_start</span><span class="p">,</span> <span class="n">site_end</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span><span class="n">pathway</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a MigrationImages object from a bulk structure and start/end
periodic sites of the diffusing atom.</p>

<p>For example, this would allow a diffusion pathway that goes from a site
at (0,0,0) to (1,1,1). Thus, symmetry and periodic boundry conditions
are considered.</p>

<p>Note, this method just creates a MigrationHop and then uses the
<code><a href="#MigrationImages.from_migration_hop">from_migration_hop</a></code> method to make a MigrationImages object.</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><p><code>structure</code>:
The bulk crystal structure (NOT the supercell).</p></li>
<li><p><code>site_start</code>:
The starting periodic site for this pathway.</p></li>
<li><p><code>site_end</code>:
The end periodic site for this pathway.</p></li>
<li><p><code>**kwargs</code>:
Any arguments that are normally accepted by <code><a href="#MigrationImages.from_migration_hop">from_migration_hop</a></code>.</p></li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.from_structure" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.from_structure">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_structure</span><span class="signature">(
    cls,
    structure: <a href="../base_data_types/structure.html#Structure">simmate.toolkit.base_data_types.structure.Structure</a>,
    migrating_specie: str,
    pathfinder_kwargs: dict = {},
    **kwargs
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">migrating_specie</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">pathfinder_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a bulk crystal structure, this will find all symmetrically</span>
<span class="sd">        unique pathways and return them as list of MigrationImages objects.</span>

<span class="sd">        #### Parameters</span>

<span class="sd">        - `structure`:</span>
<span class="sd">            The bulk crystal structure (NOT the supercell).</span>

<span class="sd">        - `migrating_specie`:</span>
<span class="sd">            The identity of the diffusing ion (e.g. &quot;Li&quot; or &quot;Li1+&quot;). Note, only</span>
<span class="sd">            provide oxidation state if you are using an oxidation-state decorated</span>
<span class="sd">            structure.</span>

<span class="sd">        - `pathfinder_kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by DistinctPathFinder, but</span>
<span class="sd">            given as a dictionary. The default is {}.</span>

<span class="sd">        - `**kwargs`:</span>
<span class="sd">            Any arguments that are normally accepted by `from_migration_hop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert to the LLL reduced primitive cell to make it as cubic as possible</span>
        <span class="n">structure_lll</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_sanitized_structure</span><span class="p">()</span>

        <span class="c1"># Use pymatgen to find all the symmetrically unique pathways.</span>
        <span class="c1"># NOTE: This only finds pathways up until the structure is percolating.</span>
        <span class="c1"># If you are interested in longer pathways, then this script needs to</span>
        <span class="c1"># be adjusted by passing additional kwargs</span>
        <span class="n">pathfinder</span> <span class="o">=</span> <span class="n">DistinctPathFinder</span><span class="p">(</span>
            <span class="n">structure_lll</span><span class="p">,</span>
            <span class="n">migrating_specie</span><span class="o">=</span><span class="n">migrating_specie</span><span class="p">,</span>
            <span class="o">**</span><span class="n">pathfinder_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pathways</span> <span class="o">=</span> <span class="n">pathfinder</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="c1"># Now go through each path and convert to a MigrationPath. We return</span>
        <span class="c1"># these as a list of paths.</span>
        <span class="n">migration_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pathway</span> <span class="ow">in</span> <span class="n">pathways</span><span class="p">:</span>

            <span class="n">migration_path</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_migration_hop</span><span class="p">(</span>
                <span class="n">migration_hop</span><span class="o">=</span><span class="n">pathway</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">migration_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">migration_path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">migration_paths</span>
</pre></div>

        </details>

            <div class="docstring"><p>Given a bulk crystal structure, this will find all symmetrically
unique pathways and return them as list of MigrationImages objects.</p>

<h4 id="parameters">Parameters</h4>

<ul>
<li><p><code>structure</code>:
The bulk crystal structure (NOT the supercell).</p></li>
<li><p><code>migrating_specie</code>:
The identity of the diffusing ion (e.g. "Li" or "Li1+"). Note, only
provide oxidation state if you are using an oxidation-state decorated
structure.</p></li>
<li><p><code>pathfinder_kwargs</code>:
Any arguments that are normally accepted by DistinctPathFinder, but
given as a dictionary. The default is {}.</p></li>
<li><p><code>**kwargs</code>:
Any arguments that are normally accepted by <code><a href="#MigrationImages.from_migration_hop">from_migration_hop</a></code>.</p></li>
</ul>
</div>


                            </div>
                            <div id="MigrationImages.from_dynamic" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.from_dynamic">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_dynamic</span><span class="signature">(cls, migration_images)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dynamic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">migration_images</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an experimental feature. The code here is a repurposing of</span>
<span class="sd">        Structre.from_dynamic so consider making a general class for</span>
<span class="sd">        from_dynamic methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># assume any list is in the MigrationHop format if there are more than</span>
        <span class="c1"># two structures (i.e. there is at least one midpoint image)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">migration_images</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">migration_images</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">migration_images_cleaned</span> <span class="o">=</span> <span class="n">migration_images</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown format provided for migration_images input.&quot;</span><span class="p">)</span>

        <span class="n">migration_images_cleaned</span><span class="o">.</span><span class="n">is_from_past_calc</span> <span class="o">=</span> <span class="n">is_from_past_calc</span>

        <span class="k">return</span> <span class="n">migration_images_cleaned</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is an experimental feature. The code here is a repurposing of
Structre.from_dynamic so consider making a general class for
from_dynamic methods.</p>
</div>


                            </div>
                            <div id="MigrationImages.as_dict" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MigrationImages.as_dict">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">as_dict</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.list</dt>
                                <dd id="MigrationImages.clear" class="function">clear</dd>
                <dd id="MigrationImages.copy" class="function">copy</dd>
                <dd id="MigrationImages.append" class="function">append</dd>
                <dd id="MigrationImages.insert" class="function">insert</dd>
                <dd id="MigrationImages.extend" class="function">extend</dd>
                <dd id="MigrationImages.pop" class="function">pop</dd>
                <dd id="MigrationImages.remove" class="function">remove</dd>
                <dd id="MigrationImages.index" class="function">index</dd>
                <dd id="MigrationImages.count" class="function">count</dd>
                <dd id="MigrationImages.reverse" class="function">reverse</dd>
                <dd id="MigrationImages.sort" class="function">sort</dd>

            </div>
                                </dl>
                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>