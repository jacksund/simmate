<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 9.0.1" />
    <title>simmate.calculators.vasp.inputs.incar API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
            <div>
                        <a class="pdoc-button module-list-button" href="../inputs.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;simmate.calculators.vasp.inputs</a>

<a href="https://github.com/jacksund/simmate">                        <img src="https://github.com/jacksund/simmate/blob/main/logo/simmate.svg?raw=true" class="logo" alt="project logo"/>
</a>
                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Incar">Incar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Incar.__init__">Incar</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.to_evaluated_str">to_evaluated_str</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.to_file">to_file</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.from_file">from_file</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.compare_incars">compare_incars</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_density">keyword_modifier_density</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_density_a">keyword_modifier_density_a</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_density_b">keyword_modifier_density_b</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_density_c">keyword_modifier_density_c</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_per_atom">keyword_modifier_per_atom</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_smart_magmom">keyword_modifier_smart_magmom</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_smart_ldau">keyword_modifier_smart_ldau</a>
                        </li>
                        <li>
                                <a class="function" href="#Incar.keyword_modifier_smart_ismear">keyword_modifier_smart_ismear</a>
                        </li>
                </ul>

            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                        <a class="pdoc-button git-button" href="https://github.com/jacksund/simmate/tree/main/src/simmate/calculators/vasp/inputs/incar.py">Edit on GitHub</a>
                    <h1 class="modulename">
<a href="./../../../../simmate.html">simmate</a><wbr>.<a href="./../../../calculators.html">calculators</a><wbr>.<a href="./../../vasp.html">vasp</a><wbr>.<a href="./../inputs.html">inputs</a><wbr>.incar    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">math</span>


<span class="k">class</span> <span class="nc">Incar</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INCAR object for reading and writing INCAR files. This behaves exactly like</span>
<span class="sd">    a python dictionary, but has a few extra checks and methods attached to it.</span>
<span class="sd">    You can pass it a dictionary or initialize it just like you would dict(kwargs).</span>
<span class="sd">    You can consider the dict(kwargs) as equivalent to Incar(parameters).</span>

<span class="sd">    If you want a given setting to be dependent on the structure or dynamically</span>
<span class="sd">    determined, then we implement these modifiers. This would enable us to</span>
<span class="sd">    do things like ENCUT__per_atom or NGZF__density. We can even have more complex</span>
<span class="sd">    modifiers like multiple_keywords__smart_ldau which signals that our</span>
<span class="sd">    &quot;smart_ldau&quot; modifier introduces more than one new setting to the INCAR, such</span>
<span class="sd">    as LDAUJ, LDAUU, LDAUL, LDAUTYPE, and LDAUPRINT.</span>

<span class="sd">    TODO: In the future, I want to allow modifiers like __relative_to_previous</span>
<span class="sd">    and __use_previous to string settings accross tasks.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># The kwargs are a dictionary of parameters (e.g. {&quot;PREC&quot;: &quot;accurate&quot;})</span>

        <span class="c1"># Establish the dictionary with the given input</span>
        <span class="c1"># This is the same as doing dict(**kwargs)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Based on the kwargs, go through and make sure each parameter is in</span>
        <span class="c1"># it&#39;s expected datatype. Thus users can supply strings in the typical</span>
        <span class="c1"># VASP format that will be convert to python types here.</span>
        <span class="c1"># OPTIMIZE -- would it be faster if I only did this on from_file init?</span>
        <span class="c1"># and therefore assumed the user to initialize this with proper python</span>
        <span class="c1"># datatypes and formatting? Also will this behave properly if the value</span>
        <span class="c1"># is already in the correct format?</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># parameters may have tags like &quot;__density&quot; added onto them. We don&#39;t</span>
            <span class="c1"># convert to the datatype yet, but instead wait until a structure</span>
            <span class="c1"># is provided (when the to_file or str methods are called below).</span>
            <span class="c1"># These are defined in python and should already be in the correct</span>
            <span class="c1"># data format.</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

            <span class="c1"># Otherwise, we need to convert values to the proper python datatype</span>
            <span class="c1"># because we might be reading from a file where everything is a string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formatted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_to_datatype</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">formatted_value</span><span class="p">})</span>

        <span class="c1"># SPECIAL CASE</span>
        <span class="c1"># If you have LSORBIT=True or LNONCOLLINEAR=True, the MAGMOM class needs</span>
        <span class="c1"># to take on a different form. Instead of a single MAGMOM being set as</span>
        <span class="c1"># a float, it&#39;s now a vector (x,y,z). For example:</span>
        <span class="c1">#   MAGMOM = x1 y1 z1    x2 y2 z2    x3 y3 z3 ...</span>
        <span class="c1">#       [...instead of...]</span>
        <span class="c1">#   MAGMOM = value1 value2 value3 ...</span>
        <span class="c1"># Check if MAGMOM is set along with LSORBIT or LNONCOLLINEAR being True</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;MAGMOM&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LSORBIT&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LNONCOLLINEAR&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># convert the MAGMOM value from...</span>
            <span class="c1">#   [x1,y1,z1,x2,y2,z2,x3,y3,z3] (this can be a string too)</span>
            <span class="c1">#   to...</span>
            <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
            <span class="n">old_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">]</span>
            <span class="n">new_format</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_format</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_format</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># Or If I wanted to do the same thing with numpy:</span>
            <span class="c1">#   new_format = numpy.array_split(old_format, len(old_format) // 3)</span>
            <span class="c1"># now update the dictionary with this value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">:</span> <span class="n">new_format</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">to_evaluated_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Let&#39;s start with an empty string and build from there</span>
        <span class="n">final_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># First we need to iterate through all parameters and check if we have</span>
        <span class="c1"># ones that are structure-specific. For example, we would need to</span>
        <span class="c1"># evaluate &quot;ENCUT__per_atom&quot;. We go through all these and collect the</span>
        <span class="c1"># paramters into a final settings list.</span>
        <span class="n">final_settings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># if there is no modifier attached to the parameter, we just keep it as-is</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># Otherwise we have a modifier like &quot;__density&quot; and need to evaluate it</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># make sure we have a structure supplied because all modifiers</span>
                <span class="c1"># require one.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;It looks like you used a keyword modifier but didn&#39;t &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;supply a structure! If you want to use </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;then you need to make sure you provide a structure so &quot;</span>
                        <span class="s2">&quot;that the modifier can be evaluated.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># separate the input into the base parameter and modifier.</span>
                <span class="c1"># This also overwrites what our paramter value is.</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">modifier_tag</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>

                <span class="c1"># check that this class has this modifier supported. It should</span>
                <span class="c1"># be a method named &quot;keyword_modifier_mymodifer&quot;.</span>
                <span class="c1"># If everything looks good, we grab the modifier function</span>
                <span class="n">modifier_fxn_name</span> <span class="o">=</span> <span class="s2">&quot;keyword_modifier_&quot;</span> <span class="o">+</span> <span class="n">modifier_tag</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">):</span>
                    <span class="n">modifier_fxn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        It looks like you used a keyword modifier that hasn&#39;t</span>
<span class="sd">                        been defined yet! If you want something like ENCUT__smart_encut,</span>
<span class="sd">                        then you need to make sure there is a keyword_modifier_smart_encut</span>
<span class="sd">                        method available.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># now that we have the modifier function, let&#39;s use it to update</span>
                <span class="c1"># our value for this keyword.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">modifier_fxn</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="c1"># if the &quot;parameter&quot; is actually &quot;multiple_keywords&quot;, then we</span>
                <span class="c1"># have our actually parameters as a dictionary. We need to</span>
                <span class="c1"># pull these out of the &quot;value&quot; we have.</span>
                <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;multiple_keywords&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">subparameter</span><span class="p">,</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">final_settings</span><span class="p">[</span><span class="n">subparameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">subvalue</span>

                <span class="c1"># otherwise we were just given back an update value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Now that we have all of our parameters evaluated for the structure, we</span>
        <span class="c1"># iterate through each parameter and its set value. Each one will be</span>
        <span class="c1"># put on a separate line.</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">final_settings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># let&#39;s start by adding the parameter key to our output</span>
            <span class="c1"># It will be followed by an equal sign to separate it&#39;s value</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="n">parameter</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span>

            <span class="c1"># If we have a value that is a list (or list of lists)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>

                <span class="c1"># check if we have a list of lists</span>
                <span class="c1"># Take MAGMOM with LSORBIT=True as an example, where we convert...</span>
                <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
                <span class="c1"># to...</span>
                <span class="c1"># &quot;x1 y1 z1 x2 y2 z2 x3 y3 z3&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">)</span>

                <span class="c1"># otherwise we just have a list of items</span>
                <span class="c1"># converts [1, 2, 3] to &quot;1 2 3&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>

            <span class="c1"># if it&#39;s not a list, we can just save the string of the value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># we want to start each parameter on a new line, so we need to</span>
            <span class="c1"># add this at the end of each. There will be an extra new line at</span>
            <span class="c1"># the end of the file, but that&#39;s alright</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># we now have our final string and can return it!</span>
        <span class="k">return</span> <span class="n">final_str</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Incar to a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): filename to write to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we just take the string format and put it in a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_evaluated_str</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an Incar object from a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): Filename for file</span>
<span class="sd">        Returns:</span>
<span class="sd">            Incar object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># open the file, grab the lines, and then close it</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="c1"># store parameters in this dictionary</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># go through line by line</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="c1"># If the line starts with a # then its a comment and we should skip.</span>
            <span class="c1"># It also could be an empty line that we should skip,</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># multiple parameters on a single line are separated by a semicolon</span>
            <span class="k">for</span> <span class="n">sub_line</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
                <span class="c1"># the PARAMETER and VALUE are separated by equal sign</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sub_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                <span class="c1"># we can use the parameter/value to update our dictionary. The</span>
                <span class="c1"># last thing we do is remove leading/trailing whitespace with strip()</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">parameter</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># return the final dictionary as an Incar object</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_str_to_datatype</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When given a vasp parameter and it&#39;s value as a string, this helper</span>
<span class="sd">        function will use the key (parameter) to determine how to convert the</span>
<span class="sd">        val string to the proper python datatype (int, float, bool, list...).</span>
<span class="sd">        I have the most common keys mapped out, but if a parameter is given that</span>
<span class="sd">        isn&#39;t mapped, I simply leave it as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># I outline the most common keys to what their expected data types are.</span>

        <span class="c1"># OPTIMIZE -- I should set these elsewhere so that these lists are not</span>
        <span class="c1"># initialized every time I call this function. Maybe have a dictionary</span>
        <span class="c1"># of {Parameter: Value_datatype} in the main enviornment for use.</span>

        <span class="n">vector_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c1"># &quot;MAGMOM&quot;,  # depends on other args -- see notes in init</span>
            <span class="s2">&quot;DIPOL&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">float_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAUU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MAGMOM&quot;</span><span class="p">,</span>  <span class="c1"># depends on other args -- see notes in init</span>
            <span class="s2">&quot;LANGEVIN_GAMMA&quot;</span><span class="p">,</span>
            <span class="s2">&quot;QUAD_EFG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EINT&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">int_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAUL&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EINT&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">bool_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LWAVE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LSCALU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LCHARG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LPLANE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LUSE_VDW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LHFCALC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ADDGRID&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LSORBIT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LNONCOLLINEAR&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">float_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;EDIFF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SIGMA&quot;</span><span class="p">,</span>
            <span class="s2">&quot;TIME&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ENCUTFOCK&quot;</span><span class="p">,</span>
            <span class="s2">&quot;HFSCREEN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;POTIM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EDIFFG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;AGGAC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PARAM1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PARAM2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;KSPACING&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">int_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;NSW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NBANDS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NELMIN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISIF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;IBRION&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISPIN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ICHARG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NELM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISMEAR&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NPAR&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LMAXMIX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ENCUT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NSIM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NKRED&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NUPDOWN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISPIND&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;IVDW&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If the value is not a string, then assume we are already in the</span>
        <span class="c1"># correct format. Note, an incorrect format will throw an error</span>
        <span class="c1"># somewhere below, which may be tricky for beginners to traceback.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># if the parameter is in int_keys</span>
        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">int_keys</span><span class="p">:</span>
            <span class="c1"># sometimes &quot;1.&quot; was written to indicate an integer so check for</span>
            <span class="c1"># this and remove it if needed.</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># return the value integer</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># if the parameter is in float_keys, we convert value to a float</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">float_keys</span><span class="p">:</span>
            <span class="c1"># return the value float</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># if the parameter is in bool_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">bool_keys</span><span class="p">:</span>
            <span class="c1"># Python is weird where bool(&quot;FALSE&quot;) will return True... So I need</span>
            <span class="c1"># to convert the string to lowercase and read it to know what to</span>
            <span class="c1"># return here.</span>
            <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="s2">&quot;f&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if the parameter is in vector_list_keys</span>
        <span class="c1"># These vectors are always floats</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">vector_list_keys</span><span class="p">:</span>
            <span class="c1"># convert a string of...</span>
            <span class="c1">#   &quot;x1 y1 z1 x2 y2 z2 x3 y3 z3&quot;</span>
            <span class="c1"># to...</span>
            <span class="c1">#   [x1,y1,z1,x2,y2,z2,x3,y3,z3] (list of floats)</span>
            <span class="c1"># and then to...</span>
            <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>

        <span class="c1"># if the parameter is in float_list_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">float_list_keys</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

        <span class="c1"># if the parameter is in int_list_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">int_list_keys</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

        <span class="c1"># If it is not in the common keys listed, just leave it as a string.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">compare_incars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_incar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares two Incars and indicates which parameters are the same and</span>
<span class="sd">        which are not. Useful for checking whether two runs were done using</span>
<span class="sd">        the same parameters.</span>
<span class="sd">        Args:</span>
<span class="sd">            other (Incar): The other Incar object to compare to.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict of the following format:</span>
<span class="sd">            {&quot;Same&quot; : parameters_that_are_the_same,</span>
<span class="sd">            &quot;Different&quot;: parameters_that_are_different}</span>
<span class="sd">            The value of the other_incar is returned for the paramters that</span>
<span class="sd">            are different are returned as {Parameter: (incar_value, other_incar_value)}</span>
<span class="sd">            where None is used as a placeholder. For the same parameters, the</span>
<span class="sd">            dictionary is returned as {Parameter: shared_value}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">same_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">different_parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make a collection of all unique keys used by the two dictionaries</span>
        <span class="c1"># I convert to list() so I can use set() below.</span>
        <span class="c1"># OPTIMIZE -- is there a better way to do this?</span>
        <span class="n">parameters1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">parameters2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_incar</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># iterate through each unique parameter</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters1</span> <span class="o">+</span> <span class="n">parameters2</span><span class="p">):</span>

            <span class="c1"># try to grab the value from both Incar objects</span>
            <span class="c1"># If it doesn&#39;t have the value, None will be provided</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
            <span class="n">value2</span> <span class="o">=</span> <span class="n">other_incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>

            <span class="c1"># compare the two and store</span>
            <span class="k">if</span> <span class="n">value1</span> <span class="o">==</span> <span class="n">value2</span><span class="p">:</span>
                <span class="c1"># it doesn&#39;t matter which value I grab so I just use value1</span>
                <span class="n">same_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value1</span>
            <span class="c1"># if they are different...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">different_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Same&quot;</span><span class="p">:</span> <span class="n">same_parameters</span><span class="p">,</span> <span class="s2">&quot;Different&quot;</span><span class="p">:</span> <span class="n">different_parameters</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all the values of another INCAR object to this object.</span>
<span class="sd">        Facilitates the use of &quot;standard&quot; INCARs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start by copying this incar&#39;s settings</span>
        <span class="n">new_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="c1"># now iterate through the other incar parameters to incorporate them</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># If both have a given parameter, make sure they are the same values</span>
            <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">parameter</span><span class="p">]:</span>
                <span class="c1"># If not, we shouldn&#39;t allow combining these Incars as it can</span>
                <span class="c1"># lead to undesired results.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incars have conflicting values! One conflict is with </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;where one incar has </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span><span class="si">}</span><span class="s2"> and the other has </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># otherwise just set the value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># now return the new Incar</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="o">**</span><span class="n">new_parameters</span><span class="p">)</span>

    <span class="c1"># ------------------------------</span>
    <span class="c1"># All methods below are modifiers that users can apply. I may move these to</span>
    <span class="c1"># a separate class (e.g. KeywordModifier).</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_a</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density_a modifier means the user wants a specific density along</span>
<span class="sd">        the A lattice vector. They provide this density in per-angstrom units</span>
<span class="sd">        and we return the structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that A vector of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_b</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_c</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_per_atom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">per_atom_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">per_atom_value</span> <span class="o">/</span> <span class="n">structure</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_magmom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">override_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __smart_magmom modifier goes through a series of checks to decide</span>
<span class="sd">        what to set the MAGMOM as for VASP. In order of priority they are...</span>
<span class="sd">            (1) the magmom property attached to each site in the structure object</span>
<span class="sd">            (2) the spin property attached to the site&#39;s specie</span>
<span class="sd">            (3) a value provided explicitly (e.g. {&quot;Co&quot;: 0.5})</span>
<span class="sd">            (4) a value of 0.6</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># grab the default MAGMOM supplied, or use VASP&#39;s default of 1 otherwise</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># we go through each site in the structure and decide what to set the</span>
        <span class="c1"># MAGMOM for each. This allows even different sites of the same</span>
        <span class="c1"># element to have their own MAGMOM</span>
        <span class="n">magnetic_moments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
            <span class="c1"># if the structure object has magmom-decorated sites, we use that</span>
            <span class="c1"># as our first priority</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s2">&quot;magmom&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
            <span class="c1"># next we check if the site&#39;s specie has a spin</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s2">&quot;spin&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
            <span class="c1"># we then look at the override dictionary if there was one provided.</span>
            <span class="c1"># If note, we use 0.6 as a default.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">magnetic_moment</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">magnetic_moment</span><span class="p">)</span>

        <span class="c1"># This feature is in pymatgen, but I haven&#39;t added it here yet.</span>
        <span class="c1"># if self.constrain_total_magmom:</span>
        <span class="c1">#     nupdown = sum([mag if abs(mag) &gt; 0.6 else 0 for mag in incar[&quot;MAGMOM&quot;]])</span>
        <span class="c1">#     incar[&quot;NUPDOWN&quot;] = nupdown</span>

        <span class="k">return</span> <span class="n">magnetic_moments</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ldau</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ldau_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This modifier handles a series of keyword arguments that are associated</span>
<span class="sd">        with LDAU, including LDAUJ, LDAUL, LDAUTYPE, LDAUU, LDAUPRINT, and LMAXMIX.</span>
<span class="sd">        Therefore, a complex dictionary is passed to this. The format looks like this...</span>
<span class="sd">            LDAU__multiple_keywords__smart_ldau = dict(</span>
<span class="sd">                LDAU__auto=True,</span>
<span class="sd">                LDAUTYPE=2,</span>
<span class="sd">                LDAUPRINT=1,</span>
<span class="sd">                LDAUJ={...},</span>
<span class="sd">                LDAUL={...},</span>
<span class="sd">                LDAUU={...},</span>
<span class="sd">                LMAXMIX__auto=True,</span>
<span class="sd">                )</span>
<span class="sd">        The LDAUJ, LDAUL, and LDAUU values can be a dictionary of elements to</span>
<span class="sd">        value, or (most commonly) a nested dictionary. For example...</span>
<span class="sd">            LDAUJ = {&quot;F&quot;:{&quot;Co&quot;:0}}</span>
<span class="sd">        This would mean if the structure is a fluoride, set the LDAUJ for Co to 0.</span>
<span class="sd">        If there are multiple options here (e.g. for fluorides and oxides), then</span>
<span class="sd">        priority is placed on the most electronegative element. This would mean</span>
<span class="sd">        some thing like yttrium oxide fluoride would be treated as a fluoride over</span>
<span class="sd">        an oxide.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first we need to go through the LDAUJ, LDAUL, and LDAUU keywords and</span>
        <span class="c1"># see what their values are. If all of these end up be 0 for all elements</span>
        <span class="c1"># then we actually don&#39;t need LDAU at all! Therefore, we&#39;ll go through</span>
        <span class="c1"># all of these keywords and build a dictionary of settings to return</span>
        <span class="c1"># at the end of this function</span>
        <span class="n">ldau_settings</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># To help decide how we set these values, let&#39;s check what the most</span>
        <span class="c1"># electronegative element is, which will be last in the sorted composition</span>
        <span class="n">most_electroneg</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">elements</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span>

        <span class="c1"># As we go through these settings, we want see if we are even using LDAU.</span>
        <span class="c1"># For example if we ran a calculation on NaCl, we&#39;d probably see that</span>
        <span class="c1"># all LDAUJ/LDAUL/LDAUU values are just 0. In that case, we can just</span>
        <span class="c1"># throw away (i.e. turn off) all LDAU settings. Therefore, we have a term</span>
        <span class="c1"># &quot;using_ldau&quot; that is false until proven otherwise.</span>
        <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">ldau_keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUL&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUU&quot;</span><span class="p">]:</span>

            <span class="c1"># grab the sub-dictionary that maps elements to this keyword.</span>
            <span class="c1"># If it&#39;s not there, just use an empty dictionary.</span>
            <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ldau_keyword</span><span class="p">,</span> <span class="p">{})</span>

            <span class="c1"># check if the most electronegative element is in the override_values</span>
            <span class="c1"># and if so, see if it has a subdictionary in it. We use this</span>
            <span class="c1"># dictionary as our base one to pull values from.</span>
            <span class="k">if</span> <span class="n">most_electroneg</span> <span class="ow">in</span> <span class="n">keyword_config</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">],</span> <span class="nb">dict</span>
            <span class="p">):</span>
                <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">]</span>

            <span class="c1"># now iterate through all the sites and grab the assigned value. If nothing</span>
            <span class="c1"># is set then the default is 0.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">keyword_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span>
            <span class="p">]</span>

            <span class="c1"># now that we have this keyword all set, we add it to our results</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="n">ldau_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

            <span class="c1"># check to see if we are using ldau here (i.e. any value is not 0)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># now check if we actaully need LDAU here. If not, we can throw out all</span>
        <span class="c1"># settings and just return an empty dictionary</span>
        <span class="k">if</span> <span class="n">using_ldau</span> <span class="ow">and</span> <span class="s2">&quot;LDAU__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAU&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># we want to modify LMAXMIX if LSDA+U and there are any d or f electrons</span>
        <span class="k">if</span> <span class="s2">&quot;LMAXMIX__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="c1"># first iterate through all elements and check for f-electrons</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">56</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="c1"># now check for elements that contain d-electrons</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># The remaining LDAU keywords are LDAUPRINT and LDAUTYPE, which we just</span>
        <span class="c1"># leave at what is set in the input</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUPRINT&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUTYPE&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ldau_settings</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ismear</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ismear_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The smearing value used here depends on if we have a semiconductor,</span>
<span class="sd">        insulator, or metal. This modifier makes a &quot;best-guess&quot; on what the</span>
<span class="sd">        material is and uses the proper smearing type. Note that if this</span>
<span class="sd">        guess is wrong, it is useful to have the IncorrectSmearing error</span>
<span class="sd">        handler to fix this as VASP runs.</span>

<span class="sd">        Read more about the VASP recommended ISMEAR settings here:</span>
<span class="sd">            https://www.vasp.at/wiki/index.php/ISMEAR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># for now we just go through the structure and if all elements are</span>
        <span class="c1"># metals, then we say it&#39;s a metal. Otherwise, we treat the structure</span>
        <span class="c1"># as a semiconductor or insulator.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">is_metal</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;non-metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">return</span> <span class="n">ismear_settings</span>


<span class="c1"># To introduce other modifiers that pymatgen uses...</span>
<span class="c1"># https://github.com/materialsproject/pymatgen/blob/b789d74639aa851d7e5ee427a765d9fd5a8d1079/pymatgen/io/vasp/sets.py#L500</span>

<span class="c1"># if self.use_structure_charge:</span>
<span class="c1">#     incar[&quot;NELECT&quot;] = self.nelect</span>

<span class="c1"># Ensure adequate number of KPOINTS are present for the tetrahedron</span>
<span class="c1"># method (ISMEAR=-5). If KSPACING is in the INCAR file the number</span>
<span class="c1"># of kpoints is not known before calling VASP, but a warning is raised</span>
<span class="c1"># when the KSPACING value is &gt; 0.5 (2 reciprocal Angstrom).</span>
<span class="c1"># An error handler in Custodian is available to</span>
<span class="c1"># correct overly large KSPACING values (small number of kpoints)</span>
<span class="c1"># if necessary.</span>
<span class="c1"># if &quot;KSPACING&quot; not in self.user_incar_settings.keys():</span>
<span class="c1"># if self.kpoints is not None:</span>
<span class="c1">#     if np.product(self.kpoints.kpts) &lt; 4 and incar.get(&quot;ISMEAR&quot;, 0) == -5:</span>
<span class="c1">#         incar[&quot;ISMEAR&quot;] = 0</span>
</pre></div>

        </details>

            </section>
                <section id="Incar">
                                <div class="attr class">
        <a class="headerlink" href="#Incar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Incar</span><wbr>(<span class="base">builtins.dict</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Incar</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INCAR object for reading and writing INCAR files. This behaves exactly like</span>
<span class="sd">    a python dictionary, but has a few extra checks and methods attached to it.</span>
<span class="sd">    You can pass it a dictionary or initialize it just like you would dict(kwargs).</span>
<span class="sd">    You can consider the dict(kwargs) as equivalent to Incar(parameters).</span>

<span class="sd">    If you want a given setting to be dependent on the structure or dynamically</span>
<span class="sd">    determined, then we implement these modifiers. This would enable us to</span>
<span class="sd">    do things like ENCUT__per_atom or NGZF__density. We can even have more complex</span>
<span class="sd">    modifiers like multiple_keywords__smart_ldau which signals that our</span>
<span class="sd">    &quot;smart_ldau&quot; modifier introduces more than one new setting to the INCAR, such</span>
<span class="sd">    as LDAUJ, LDAUU, LDAUL, LDAUTYPE, and LDAUPRINT.</span>

<span class="sd">    TODO: In the future, I want to allow modifiers like __relative_to_previous</span>
<span class="sd">    and __use_previous to string settings accross tasks.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># The kwargs are a dictionary of parameters (e.g. {&quot;PREC&quot;: &quot;accurate&quot;})</span>

        <span class="c1"># Establish the dictionary with the given input</span>
        <span class="c1"># This is the same as doing dict(**kwargs)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Based on the kwargs, go through and make sure each parameter is in</span>
        <span class="c1"># it&#39;s expected datatype. Thus users can supply strings in the typical</span>
        <span class="c1"># VASP format that will be convert to python types here.</span>
        <span class="c1"># OPTIMIZE -- would it be faster if I only did this on from_file init?</span>
        <span class="c1"># and therefore assumed the user to initialize this with proper python</span>
        <span class="c1"># datatypes and formatting? Also will this behave properly if the value</span>
        <span class="c1"># is already in the correct format?</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># parameters may have tags like &quot;__density&quot; added onto them. We don&#39;t</span>
            <span class="c1"># convert to the datatype yet, but instead wait until a structure</span>
            <span class="c1"># is provided (when the to_file or str methods are called below).</span>
            <span class="c1"># These are defined in python and should already be in the correct</span>
            <span class="c1"># data format.</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

            <span class="c1"># Otherwise, we need to convert values to the proper python datatype</span>
            <span class="c1"># because we might be reading from a file where everything is a string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formatted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_to_datatype</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">formatted_value</span><span class="p">})</span>

        <span class="c1"># SPECIAL CASE</span>
        <span class="c1"># If you have LSORBIT=True or LNONCOLLINEAR=True, the MAGMOM class needs</span>
        <span class="c1"># to take on a different form. Instead of a single MAGMOM being set as</span>
        <span class="c1"># a float, it&#39;s now a vector (x,y,z). For example:</span>
        <span class="c1">#   MAGMOM = x1 y1 z1    x2 y2 z2    x3 y3 z3 ...</span>
        <span class="c1">#       [...instead of...]</span>
        <span class="c1">#   MAGMOM = value1 value2 value3 ...</span>
        <span class="c1"># Check if MAGMOM is set along with LSORBIT or LNONCOLLINEAR being True</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;MAGMOM&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LSORBIT&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LNONCOLLINEAR&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># convert the MAGMOM value from...</span>
            <span class="c1">#   [x1,y1,z1,x2,y2,z2,x3,y3,z3] (this can be a string too)</span>
            <span class="c1">#   to...</span>
            <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
            <span class="n">old_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">]</span>
            <span class="n">new_format</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_format</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_format</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># Or If I wanted to do the same thing with numpy:</span>
            <span class="c1">#   new_format = numpy.array_split(old_format, len(old_format) // 3)</span>
            <span class="c1"># now update the dictionary with this value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">:</span> <span class="n">new_format</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">to_evaluated_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Let&#39;s start with an empty string and build from there</span>
        <span class="n">final_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># First we need to iterate through all parameters and check if we have</span>
        <span class="c1"># ones that are structure-specific. For example, we would need to</span>
        <span class="c1"># evaluate &quot;ENCUT__per_atom&quot;. We go through all these and collect the</span>
        <span class="c1"># paramters into a final settings list.</span>
        <span class="n">final_settings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># if there is no modifier attached to the parameter, we just keep it as-is</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># Otherwise we have a modifier like &quot;__density&quot; and need to evaluate it</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># make sure we have a structure supplied because all modifiers</span>
                <span class="c1"># require one.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;It looks like you used a keyword modifier but didn&#39;t &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;supply a structure! If you want to use </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;then you need to make sure you provide a structure so &quot;</span>
                        <span class="s2">&quot;that the modifier can be evaluated.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># separate the input into the base parameter and modifier.</span>
                <span class="c1"># This also overwrites what our paramter value is.</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">modifier_tag</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>

                <span class="c1"># check that this class has this modifier supported. It should</span>
                <span class="c1"># be a method named &quot;keyword_modifier_mymodifer&quot;.</span>
                <span class="c1"># If everything looks good, we grab the modifier function</span>
                <span class="n">modifier_fxn_name</span> <span class="o">=</span> <span class="s2">&quot;keyword_modifier_&quot;</span> <span class="o">+</span> <span class="n">modifier_tag</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">):</span>
                    <span class="n">modifier_fxn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        It looks like you used a keyword modifier that hasn&#39;t</span>
<span class="sd">                        been defined yet! If you want something like ENCUT__smart_encut,</span>
<span class="sd">                        then you need to make sure there is a keyword_modifier_smart_encut</span>
<span class="sd">                        method available.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># now that we have the modifier function, let&#39;s use it to update</span>
                <span class="c1"># our value for this keyword.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">modifier_fxn</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="c1"># if the &quot;parameter&quot; is actually &quot;multiple_keywords&quot;, then we</span>
                <span class="c1"># have our actually parameters as a dictionary. We need to</span>
                <span class="c1"># pull these out of the &quot;value&quot; we have.</span>
                <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;multiple_keywords&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">subparameter</span><span class="p">,</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">final_settings</span><span class="p">[</span><span class="n">subparameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">subvalue</span>

                <span class="c1"># otherwise we were just given back an update value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Now that we have all of our parameters evaluated for the structure, we</span>
        <span class="c1"># iterate through each parameter and its set value. Each one will be</span>
        <span class="c1"># put on a separate line.</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">final_settings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># let&#39;s start by adding the parameter key to our output</span>
            <span class="c1"># It will be followed by an equal sign to separate it&#39;s value</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="n">parameter</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span>

            <span class="c1"># If we have a value that is a list (or list of lists)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>

                <span class="c1"># check if we have a list of lists</span>
                <span class="c1"># Take MAGMOM with LSORBIT=True as an example, where we convert...</span>
                <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
                <span class="c1"># to...</span>
                <span class="c1"># &quot;x1 y1 z1 x2 y2 z2 x3 y3 z3&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">)</span>

                <span class="c1"># otherwise we just have a list of items</span>
                <span class="c1"># converts [1, 2, 3] to &quot;1 2 3&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>

            <span class="c1"># if it&#39;s not a list, we can just save the string of the value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># we want to start each parameter on a new line, so we need to</span>
            <span class="c1"># add this at the end of each. There will be an extra new line at</span>
            <span class="c1"># the end of the file, but that&#39;s alright</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># we now have our final string and can return it!</span>
        <span class="k">return</span> <span class="n">final_str</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Incar to a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): filename to write to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we just take the string format and put it in a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_evaluated_str</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an Incar object from a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): Filename for file</span>
<span class="sd">        Returns:</span>
<span class="sd">            Incar object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># open the file, grab the lines, and then close it</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="c1"># store parameters in this dictionary</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># go through line by line</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="c1"># If the line starts with a # then its a comment and we should skip.</span>
            <span class="c1"># It also could be an empty line that we should skip,</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># multiple parameters on a single line are separated by a semicolon</span>
            <span class="k">for</span> <span class="n">sub_line</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
                <span class="c1"># the PARAMETER and VALUE are separated by equal sign</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sub_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                <span class="c1"># we can use the parameter/value to update our dictionary. The</span>
                <span class="c1"># last thing we do is remove leading/trailing whitespace with strip()</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">parameter</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># return the final dictionary as an Incar object</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_str_to_datatype</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When given a vasp parameter and it&#39;s value as a string, this helper</span>
<span class="sd">        function will use the key (parameter) to determine how to convert the</span>
<span class="sd">        val string to the proper python datatype (int, float, bool, list...).</span>
<span class="sd">        I have the most common keys mapped out, but if a parameter is given that</span>
<span class="sd">        isn&#39;t mapped, I simply leave it as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># I outline the most common keys to what their expected data types are.</span>

        <span class="c1"># OPTIMIZE -- I should set these elsewhere so that these lists are not</span>
        <span class="c1"># initialized every time I call this function. Maybe have a dictionary</span>
        <span class="c1"># of {Parameter: Value_datatype} in the main enviornment for use.</span>

        <span class="n">vector_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c1"># &quot;MAGMOM&quot;,  # depends on other args -- see notes in init</span>
            <span class="s2">&quot;DIPOL&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">float_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAUU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MAGMOM&quot;</span><span class="p">,</span>  <span class="c1"># depends on other args -- see notes in init</span>
            <span class="s2">&quot;LANGEVIN_GAMMA&quot;</span><span class="p">,</span>
            <span class="s2">&quot;QUAD_EFG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EINT&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">int_list_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAUL&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EINT&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">bool_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;LDAU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LWAVE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LSCALU&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LCHARG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LPLANE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LUSE_VDW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LHFCALC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ADDGRID&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LSORBIT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LNONCOLLINEAR&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">float_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;EDIFF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SIGMA&quot;</span><span class="p">,</span>
            <span class="s2">&quot;TIME&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ENCUTFOCK&quot;</span><span class="p">,</span>
            <span class="s2">&quot;HFSCREEN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;POTIM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EDIFFG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;AGGAC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PARAM1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PARAM2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;KSPACING&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">int_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;NSW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NBANDS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NELMIN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISIF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;IBRION&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISPIN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ICHARG&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NELM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISMEAR&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NPAR&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LMAXMIX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ENCUT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NSIM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NKRED&quot;</span><span class="p">,</span>
            <span class="s2">&quot;NUPDOWN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ISPIND&quot;</span><span class="p">,</span>
            <span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;IVDW&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If the value is not a string, then assume we are already in the</span>
        <span class="c1"># correct format. Note, an incorrect format will throw an error</span>
        <span class="c1"># somewhere below, which may be tricky for beginners to traceback.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># if the parameter is in int_keys</span>
        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">int_keys</span><span class="p">:</span>
            <span class="c1"># sometimes &quot;1.&quot; was written to indicate an integer so check for</span>
            <span class="c1"># this and remove it if needed.</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># return the value integer</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># if the parameter is in float_keys, we convert value to a float</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">float_keys</span><span class="p">:</span>
            <span class="c1"># return the value float</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># if the parameter is in bool_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">bool_keys</span><span class="p">:</span>
            <span class="c1"># Python is weird where bool(&quot;FALSE&quot;) will return True... So I need</span>
            <span class="c1"># to convert the string to lowercase and read it to know what to</span>
            <span class="c1"># return here.</span>
            <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="s2">&quot;f&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if the parameter is in vector_list_keys</span>
        <span class="c1"># These vectors are always floats</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">vector_list_keys</span><span class="p">:</span>
            <span class="c1"># convert a string of...</span>
            <span class="c1">#   &quot;x1 y1 z1 x2 y2 z2 x3 y3 z3&quot;</span>
            <span class="c1"># to...</span>
            <span class="c1">#   [x1,y1,z1,x2,y2,z2,x3,y3,z3] (list of floats)</span>
            <span class="c1"># and then to...</span>
            <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>

        <span class="c1"># if the parameter is in float_list_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">float_list_keys</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

        <span class="c1"># if the parameter is in int_list_keys</span>
        <span class="k">elif</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">int_list_keys</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

        <span class="c1"># If it is not in the common keys listed, just leave it as a string.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">compare_incars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_incar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares two Incars and indicates which parameters are the same and</span>
<span class="sd">        which are not. Useful for checking whether two runs were done using</span>
<span class="sd">        the same parameters.</span>
<span class="sd">        Args:</span>
<span class="sd">            other (Incar): The other Incar object to compare to.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict of the following format:</span>
<span class="sd">            {&quot;Same&quot; : parameters_that_are_the_same,</span>
<span class="sd">            &quot;Different&quot;: parameters_that_are_different}</span>
<span class="sd">            The value of the other_incar is returned for the paramters that</span>
<span class="sd">            are different are returned as {Parameter: (incar_value, other_incar_value)}</span>
<span class="sd">            where None is used as a placeholder. For the same parameters, the</span>
<span class="sd">            dictionary is returned as {Parameter: shared_value}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">same_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">different_parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make a collection of all unique keys used by the two dictionaries</span>
        <span class="c1"># I convert to list() so I can use set() below.</span>
        <span class="c1"># OPTIMIZE -- is there a better way to do this?</span>
        <span class="n">parameters1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">parameters2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_incar</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># iterate through each unique parameter</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters1</span> <span class="o">+</span> <span class="n">parameters2</span><span class="p">):</span>

            <span class="c1"># try to grab the value from both Incar objects</span>
            <span class="c1"># If it doesn&#39;t have the value, None will be provided</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
            <span class="n">value2</span> <span class="o">=</span> <span class="n">other_incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>

            <span class="c1"># compare the two and store</span>
            <span class="k">if</span> <span class="n">value1</span> <span class="o">==</span> <span class="n">value2</span><span class="p">:</span>
                <span class="c1"># it doesn&#39;t matter which value I grab so I just use value1</span>
                <span class="n">same_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value1</span>
            <span class="c1"># if they are different...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">different_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Same&quot;</span><span class="p">:</span> <span class="n">same_parameters</span><span class="p">,</span> <span class="s2">&quot;Different&quot;</span><span class="p">:</span> <span class="n">different_parameters</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all the values of another INCAR object to this object.</span>
<span class="sd">        Facilitates the use of &quot;standard&quot; INCARs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start by copying this incar&#39;s settings</span>
        <span class="n">new_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="c1"># now iterate through the other incar parameters to incorporate them</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># If both have a given parameter, make sure they are the same values</span>
            <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="n">parameter</span><span class="p">]:</span>
                <span class="c1"># If not, we shouldn&#39;t allow combining these Incars as it can</span>
                <span class="c1"># lead to undesired results.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Incars have conflicting values! One conflict is with </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;where one incar has </span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span><span class="si">}</span><span class="s2"> and the other has </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># otherwise just set the value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># now return the new Incar</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="o">**</span><span class="n">new_parameters</span><span class="p">)</span>

    <span class="c1"># ------------------------------</span>
    <span class="c1"># All methods below are modifiers that users can apply. I may move these to</span>
    <span class="c1"># a separate class (e.g. KeywordModifier).</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_a</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density_a modifier means the user wants a specific density along</span>
<span class="sd">        the A lattice vector. They provide this density in per-angstrom units</span>
<span class="sd">        and we return the structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that A vector of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_b</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_c</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_per_atom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">per_atom_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">per_atom_value</span> <span class="o">/</span> <span class="n">structure</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_magmom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">override_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __smart_magmom modifier goes through a series of checks to decide</span>
<span class="sd">        what to set the MAGMOM as for VASP. In order of priority they are...</span>
<span class="sd">            (1) the magmom property attached to each site in the structure object</span>
<span class="sd">            (2) the spin property attached to the site&#39;s specie</span>
<span class="sd">            (3) a value provided explicitly (e.g. {&quot;Co&quot;: 0.5})</span>
<span class="sd">            (4) a value of 0.6</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># grab the default MAGMOM supplied, or use VASP&#39;s default of 1 otherwise</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># we go through each site in the structure and decide what to set the</span>
        <span class="c1"># MAGMOM for each. This allows even different sites of the same</span>
        <span class="c1"># element to have their own MAGMOM</span>
        <span class="n">magnetic_moments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
            <span class="c1"># if the structure object has magmom-decorated sites, we use that</span>
            <span class="c1"># as our first priority</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s2">&quot;magmom&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
            <span class="c1"># next we check if the site&#39;s specie has a spin</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s2">&quot;spin&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
            <span class="c1"># we then look at the override dictionary if there was one provided.</span>
            <span class="c1"># If note, we use 0.6 as a default.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">magnetic_moment</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">magnetic_moment</span><span class="p">)</span>

        <span class="c1"># This feature is in pymatgen, but I haven&#39;t added it here yet.</span>
        <span class="c1"># if self.constrain_total_magmom:</span>
        <span class="c1">#     nupdown = sum([mag if abs(mag) &gt; 0.6 else 0 for mag in incar[&quot;MAGMOM&quot;]])</span>
        <span class="c1">#     incar[&quot;NUPDOWN&quot;] = nupdown</span>

        <span class="k">return</span> <span class="n">magnetic_moments</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ldau</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ldau_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This modifier handles a series of keyword arguments that are associated</span>
<span class="sd">        with LDAU, including LDAUJ, LDAUL, LDAUTYPE, LDAUU, LDAUPRINT, and LMAXMIX.</span>
<span class="sd">        Therefore, a complex dictionary is passed to this. The format looks like this...</span>
<span class="sd">            LDAU__multiple_keywords__smart_ldau = dict(</span>
<span class="sd">                LDAU__auto=True,</span>
<span class="sd">                LDAUTYPE=2,</span>
<span class="sd">                LDAUPRINT=1,</span>
<span class="sd">                LDAUJ={...},</span>
<span class="sd">                LDAUL={...},</span>
<span class="sd">                LDAUU={...},</span>
<span class="sd">                LMAXMIX__auto=True,</span>
<span class="sd">                )</span>
<span class="sd">        The LDAUJ, LDAUL, and LDAUU values can be a dictionary of elements to</span>
<span class="sd">        value, or (most commonly) a nested dictionary. For example...</span>
<span class="sd">            LDAUJ = {&quot;F&quot;:{&quot;Co&quot;:0}}</span>
<span class="sd">        This would mean if the structure is a fluoride, set the LDAUJ for Co to 0.</span>
<span class="sd">        If there are multiple options here (e.g. for fluorides and oxides), then</span>
<span class="sd">        priority is placed on the most electronegative element. This would mean</span>
<span class="sd">        some thing like yttrium oxide fluoride would be treated as a fluoride over</span>
<span class="sd">        an oxide.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first we need to go through the LDAUJ, LDAUL, and LDAUU keywords and</span>
        <span class="c1"># see what their values are. If all of these end up be 0 for all elements</span>
        <span class="c1"># then we actually don&#39;t need LDAU at all! Therefore, we&#39;ll go through</span>
        <span class="c1"># all of these keywords and build a dictionary of settings to return</span>
        <span class="c1"># at the end of this function</span>
        <span class="n">ldau_settings</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># To help decide how we set these values, let&#39;s check what the most</span>
        <span class="c1"># electronegative element is, which will be last in the sorted composition</span>
        <span class="n">most_electroneg</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">elements</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span>

        <span class="c1"># As we go through these settings, we want see if we are even using LDAU.</span>
        <span class="c1"># For example if we ran a calculation on NaCl, we&#39;d probably see that</span>
        <span class="c1"># all LDAUJ/LDAUL/LDAUU values are just 0. In that case, we can just</span>
        <span class="c1"># throw away (i.e. turn off) all LDAU settings. Therefore, we have a term</span>
        <span class="c1"># &quot;using_ldau&quot; that is false until proven otherwise.</span>
        <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">ldau_keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUL&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUU&quot;</span><span class="p">]:</span>

            <span class="c1"># grab the sub-dictionary that maps elements to this keyword.</span>
            <span class="c1"># If it&#39;s not there, just use an empty dictionary.</span>
            <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ldau_keyword</span><span class="p">,</span> <span class="p">{})</span>

            <span class="c1"># check if the most electronegative element is in the override_values</span>
            <span class="c1"># and if so, see if it has a subdictionary in it. We use this</span>
            <span class="c1"># dictionary as our base one to pull values from.</span>
            <span class="k">if</span> <span class="n">most_electroneg</span> <span class="ow">in</span> <span class="n">keyword_config</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">],</span> <span class="nb">dict</span>
            <span class="p">):</span>
                <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">]</span>

            <span class="c1"># now iterate through all the sites and grab the assigned value. If nothing</span>
            <span class="c1"># is set then the default is 0.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">keyword_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span>
            <span class="p">]</span>

            <span class="c1"># now that we have this keyword all set, we add it to our results</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="n">ldau_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

            <span class="c1"># check to see if we are using ldau here (i.e. any value is not 0)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># now check if we actaully need LDAU here. If not, we can throw out all</span>
        <span class="c1"># settings and just return an empty dictionary</span>
        <span class="k">if</span> <span class="n">using_ldau</span> <span class="ow">and</span> <span class="s2">&quot;LDAU__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAU&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># we want to modify LMAXMIX if LSDA+U and there are any d or f electrons</span>
        <span class="k">if</span> <span class="s2">&quot;LMAXMIX__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="c1"># first iterate through all elements and check for f-electrons</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">56</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="c1"># now check for elements that contain d-electrons</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># The remaining LDAU keywords are LDAUPRINT and LDAUTYPE, which we just</span>
        <span class="c1"># leave at what is set in the input</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUPRINT&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUTYPE&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ldau_settings</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ismear</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ismear_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The smearing value used here depends on if we have a semiconductor,</span>
<span class="sd">        insulator, or metal. This modifier makes a &quot;best-guess&quot; on what the</span>
<span class="sd">        material is and uses the proper smearing type. Note that if this</span>
<span class="sd">        guess is wrong, it is useful to have the IncorrectSmearing error</span>
<span class="sd">        handler to fix this as VASP runs.</span>

<span class="sd">        Read more about the VASP recommended ISMEAR settings here:</span>
<span class="sd">            https://www.vasp.at/wiki/index.php/ISMEAR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># for now we just go through the structure and if all elements are</span>
        <span class="c1"># metals, then we say it&#39;s a metal. Otherwise, we treat the structure</span>
        <span class="c1"># as a semiconductor or insulator.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">is_metal</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;non-metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">return</span> <span class="n">ismear_settings</span>
</pre></div>

        </details>

            <div class="docstring"><p>INCAR object for reading and writing INCAR files. This behaves exactly like
a python dictionary, but has a few extra checks and methods attached to it.
You can pass it a dictionary or initialize it just like you would dict(kwargs).
You can consider the dict(kwargs) as equivalent to Incar(parameters).</p>

<p>If you want a given setting to be dependent on the structure or dynamically
determined, then we implement these modifiers. This would enable us to
do things like ENCUT__per_atom or NGZF__density. We can even have more complex
modifiers like multiple_keywords__smart_ldau which signals that our
"smart_ldau" modifier introduces more than one new setting to the INCAR, such
as LDAUJ, LDAUU, LDAUL, LDAUTYPE, and LDAUPRINT.</p>

<p>TODO: In the future, I want to allow modifiers like __relative_to_previous
and __use_previous to string settings accross tasks.</p>
</div>


                            <div id="Incar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Incar</span><span class="signature">(**kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># The kwargs are a dictionary of parameters (e.g. {&quot;PREC&quot;: &quot;accurate&quot;})</span>

        <span class="c1"># Establish the dictionary with the given input</span>
        <span class="c1"># This is the same as doing dict(**kwargs)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Based on the kwargs, go through and make sure each parameter is in</span>
        <span class="c1"># it&#39;s expected datatype. Thus users can supply strings in the typical</span>
        <span class="c1"># VASP format that will be convert to python types here.</span>
        <span class="c1"># OPTIMIZE -- would it be faster if I only did this on from_file init?</span>
        <span class="c1"># and therefore assumed the user to initialize this with proper python</span>
        <span class="c1"># datatypes and formatting? Also will this behave properly if the value</span>
        <span class="c1"># is already in the correct format?</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># parameters may have tags like &quot;__density&quot; added onto them. We don&#39;t</span>
            <span class="c1"># convert to the datatype yet, but instead wait until a structure</span>
            <span class="c1"># is provided (when the to_file or str methods are called below).</span>
            <span class="c1"># These are defined in python and should already be in the correct</span>
            <span class="c1"># data format.</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

            <span class="c1"># Otherwise, we need to convert values to the proper python datatype</span>
            <span class="c1"># because we might be reading from a file where everything is a string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formatted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_to_datatype</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">formatted_value</span><span class="p">})</span>

        <span class="c1"># SPECIAL CASE</span>
        <span class="c1"># If you have LSORBIT=True or LNONCOLLINEAR=True, the MAGMOM class needs</span>
        <span class="c1"># to take on a different form. Instead of a single MAGMOM being set as</span>
        <span class="c1"># a float, it&#39;s now a vector (x,y,z). For example:</span>
        <span class="c1">#   MAGMOM = x1 y1 z1    x2 y2 z2    x3 y3 z3 ...</span>
        <span class="c1">#       [...instead of...]</span>
        <span class="c1">#   MAGMOM = value1 value2 value3 ...</span>
        <span class="c1"># Check if MAGMOM is set along with LSORBIT or LNONCOLLINEAR being True</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;MAGMOM&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LSORBIT&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LNONCOLLINEAR&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># convert the MAGMOM value from...</span>
            <span class="c1">#   [x1,y1,z1,x2,y2,z2,x3,y3,z3] (this can be a string too)</span>
            <span class="c1">#   to...</span>
            <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
            <span class="n">old_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">]</span>
            <span class="n">new_format</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_format</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_format</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># Or If I wanted to do the same thing with numpy:</span>
            <span class="c1">#   new_format = numpy.array_split(old_format, len(old_format) // 3)</span>
            <span class="c1"># now update the dictionary with this value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;MAGMOM&quot;</span><span class="p">:</span> <span class="n">new_format</span><span class="p">})</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Incar.to_evaluated_str" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.to_evaluated_str">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_evaluated_str</span><span class="signature">(self, structure=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_evaluated_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Let&#39;s start with an empty string and build from there</span>
        <span class="n">final_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># First we need to iterate through all parameters and check if we have</span>
        <span class="c1"># ones that are structure-specific. For example, we would need to</span>
        <span class="c1"># evaluate &quot;ENCUT__per_atom&quot;. We go through all these and collect the</span>
        <span class="c1"># paramters into a final settings list.</span>
        <span class="n">final_settings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># if there is no modifier attached to the parameter, we just keep it as-is</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameter</span><span class="p">:</span>
                <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># Otherwise we have a modifier like &quot;__density&quot; and need to evaluate it</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># make sure we have a structure supplied because all modifiers</span>
                <span class="c1"># require one.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;It looks like you used a keyword modifier but didn&#39;t &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;supply a structure! If you want to use </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;then you need to make sure you provide a structure so &quot;</span>
                        <span class="s2">&quot;that the modifier can be evaluated.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># separate the input into the base parameter and modifier.</span>
                <span class="c1"># This also overwrites what our paramter value is.</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">modifier_tag</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>

                <span class="c1"># check that this class has this modifier supported. It should</span>
                <span class="c1"># be a method named &quot;keyword_modifier_mymodifer&quot;.</span>
                <span class="c1"># If everything looks good, we grab the modifier function</span>
                <span class="n">modifier_fxn_name</span> <span class="o">=</span> <span class="s2">&quot;keyword_modifier_&quot;</span> <span class="o">+</span> <span class="n">modifier_tag</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">):</span>
                    <span class="n">modifier_fxn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modifier_fxn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        It looks like you used a keyword modifier that hasn&#39;t</span>
<span class="sd">                        been defined yet! If you want something like ENCUT__smart_encut,</span>
<span class="sd">                        then you need to make sure there is a keyword_modifier_smart_encut</span>
<span class="sd">                        method available.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># now that we have the modifier function, let&#39;s use it to update</span>
                <span class="c1"># our value for this keyword.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">modifier_fxn</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="c1"># if the &quot;parameter&quot; is actually &quot;multiple_keywords&quot;, then we</span>
                <span class="c1"># have our actually parameters as a dictionary. We need to</span>
                <span class="c1"># pull these out of the &quot;value&quot; we have.</span>
                <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;multiple_keywords&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">subparameter</span><span class="p">,</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">final_settings</span><span class="p">[</span><span class="n">subparameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">subvalue</span>

                <span class="c1"># otherwise we were just given back an update value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_settings</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Now that we have all of our parameters evaluated for the structure, we</span>
        <span class="c1"># iterate through each parameter and its set value. Each one will be</span>
        <span class="c1"># put on a separate line.</span>
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">final_settings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># let&#39;s start by adding the parameter key to our output</span>
            <span class="c1"># It will be followed by an equal sign to separate it&#39;s value</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="n">parameter</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span>

            <span class="c1"># If we have a value that is a list (or list of lists)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>

                <span class="c1"># check if we have a list of lists</span>
                <span class="c1"># Take MAGMOM with LSORBIT=True as an example, where we convert...</span>
                <span class="c1">#   [[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]</span>
                <span class="c1"># to...</span>
                <span class="c1"># &quot;x1 y1 z1 x2 y2 z2 x3 y3 z3&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">)</span>

                <span class="c1"># otherwise we just have a list of items</span>
                <span class="c1"># converts [1, 2, 3] to &quot;1 2 3&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>

            <span class="c1"># if it&#39;s not a list, we can just save the string of the value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># we want to start each parameter on a new line, so we need to</span>
            <span class="c1"># add this at the end of each. There will be an extra new line at</span>
            <span class="c1"># the end of the file, but that&#39;s alright</span>
            <span class="n">final_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># we now have our final string and can return it!</span>
        <span class="k">return</span> <span class="n">final_str</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Incar.to_file" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.to_file">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_file</span><span class="signature">(self, filename=&#39;INCAR&#39;, structure=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Incar to a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): filename to write to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we just take the string format and put it in a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_evaluated_str</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Write Incar to a file.
Args:
    filename (str): filename to write to.</p>
</div>


                            </div>
                            <div id="Incar.from_file" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.from_file">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">from_file</span><span class="signature">(filename=&#39;INCAR&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;INCAR&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an Incar object from a file.</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): Filename for file</span>
<span class="sd">        Returns:</span>
<span class="sd">            Incar object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># open the file, grab the lines, and then close it</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="c1"># store parameters in this dictionary</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># go through line by line</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="c1"># If the line starts with a # then its a comment and we should skip.</span>
            <span class="c1"># It also could be an empty line that we should skip,</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># multiple parameters on a single line are separated by a semicolon</span>
            <span class="k">for</span> <span class="n">sub_line</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
                <span class="c1"># the PARAMETER and VALUE are separated by equal sign</span>
                <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sub_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                <span class="c1"># we can use the parameter/value to update our dictionary. The</span>
                <span class="c1"># last thing we do is remove leading/trailing whitespace with strip()</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">parameter</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># return the final dictionary as an Incar object</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reads an Incar object from a file.
Args:
    filename (str): Filename for file
Returns:
    Incar object</p>
</div>


                            </div>
                            <div id="Incar.compare_incars" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.compare_incars">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">compare_incars</span><span class="signature">(self, other_incar)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">compare_incars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_incar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares two Incars and indicates which parameters are the same and</span>
<span class="sd">        which are not. Useful for checking whether two runs were done using</span>
<span class="sd">        the same parameters.</span>
<span class="sd">        Args:</span>
<span class="sd">            other (Incar): The other Incar object to compare to.</span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict of the following format:</span>
<span class="sd">            {&quot;Same&quot; : parameters_that_are_the_same,</span>
<span class="sd">            &quot;Different&quot;: parameters_that_are_different}</span>
<span class="sd">            The value of the other_incar is returned for the paramters that</span>
<span class="sd">            are different are returned as {Parameter: (incar_value, other_incar_value)}</span>
<span class="sd">            where None is used as a placeholder. For the same parameters, the</span>
<span class="sd">            dictionary is returned as {Parameter: shared_value}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">same_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">different_parameters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make a collection of all unique keys used by the two dictionaries</span>
        <span class="c1"># I convert to list() so I can use set() below.</span>
        <span class="c1"># OPTIMIZE -- is there a better way to do this?</span>
        <span class="n">parameters1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">parameters2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_incar</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># iterate through each unique parameter</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters1</span> <span class="o">+</span> <span class="n">parameters2</span><span class="p">):</span>

            <span class="c1"># try to grab the value from both Incar objects</span>
            <span class="c1"># If it doesn&#39;t have the value, None will be provided</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
            <span class="n">value2</span> <span class="o">=</span> <span class="n">other_incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>

            <span class="c1"># compare the two and store</span>
            <span class="k">if</span> <span class="n">value1</span> <span class="o">==</span> <span class="n">value2</span><span class="p">:</span>
                <span class="c1"># it doesn&#39;t matter which value I grab so I just use value1</span>
                <span class="n">same_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">value1</span>
            <span class="c1"># if they are different...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">different_parameters</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Same&quot;</span><span class="p">:</span> <span class="n">same_parameters</span><span class="p">,</span> <span class="s2">&quot;Different&quot;</span><span class="p">:</span> <span class="n">different_parameters</span><span class="p">}</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compares two Incars and indicates which parameters are the same and
which are not. Useful for checking whether two runs were done using
the same parameters.
Args:
    other (Incar): The other Incar object to compare to.
Returns:
    Dict of the following format:
    {"Same" : parameters_that_are_the_same,
    "Different": parameters_that_are_different}
    The value of the other_incar is returned for the paramters that
    are different are returned as {Parameter: (incar_value, other_incar_value)}
    where None is used as a placeholder. For the same parameters, the
    dictionary is returned as {Parameter: shared_value}</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_density" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_density">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_density</span><span class="signature">(structure, density)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The __density modifier means the user wants a specific density. They
provide this density in per-angstrom^3 units and we return the
structure-specific count that gives this density.
For example, density=10 and a structure lattice that volume of 5,
then this returns value=10*5=50.</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_density_a" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_density_a">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_density_a</span><span class="signature">(structure, density)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_a</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density_a modifier means the user wants a specific density along</span>
<span class="sd">        the A lattice vector. They provide this density in per-angstrom units</span>
<span class="sd">        and we return the structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that A vector of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The __density_a modifier means the user wants a specific density along
the A lattice vector. They provide this density in per-angstrom units
and we return the structure-specific count that gives this density.
For example, density=10 and a structure lattice that A vector of 5,
then this returns value=10*5=50.</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_density_b" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_density_b">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_density_b</span><span class="signature">(structure, density)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_b</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Incar.keyword_modifier_density_c" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_density_c">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_density_c</span><span class="signature">(structure, density)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_density_c</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">density</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">density</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Incar.keyword_modifier_per_atom" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_per_atom">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_per_atom</span><span class="signature">(structure, per_atom_value)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_per_atom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">per_atom_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __density modifier means the user wants a specific density. They</span>
<span class="sd">        provide this density in per-angstrom^3 units and we return the</span>
<span class="sd">        structure-specific count that gives this density.</span>
<span class="sd">        For example, density=10 and a structure lattice that volume of 5,</span>
<span class="sd">        then this returns value=10*5=50.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># VASP expect integers for a lot of these values, so we round up</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">per_atom_value</span> <span class="o">/</span> <span class="n">structure</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The __density modifier means the user wants a specific density. They
provide this density in per-angstrom^3 units and we return the
structure-specific count that gives this density.
For example, density=10 and a structure lattice that volume of 5,
then this returns value=10*5=50.</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_smart_magmom" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_smart_magmom">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_smart_magmom</span><span class="signature">(structure, override_values)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_magmom</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">override_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The __smart_magmom modifier goes through a series of checks to decide</span>
<span class="sd">        what to set the MAGMOM as for VASP. In order of priority they are...</span>
<span class="sd">            (1) the magmom property attached to each site in the structure object</span>
<span class="sd">            (2) the spin property attached to the site&#39;s specie</span>
<span class="sd">            (3) a value provided explicitly (e.g. {&quot;Co&quot;: 0.5})</span>
<span class="sd">            (4) a value of 0.6</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># grab the default MAGMOM supplied, or use VASP&#39;s default of 1 otherwise</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># we go through each site in the structure and decide what to set the</span>
        <span class="c1"># MAGMOM for each. This allows even different sites of the same</span>
        <span class="c1"># element to have their own MAGMOM</span>
        <span class="n">magnetic_moments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
            <span class="c1"># if the structure object has magmom-decorated sites, we use that</span>
            <span class="c1"># as our first priority</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s2">&quot;magmom&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
            <span class="c1"># next we check if the site&#39;s specie has a spin</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s2">&quot;spin&quot;</span><span class="p">):</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
            <span class="c1"># we then look at the override dictionary if there was one provided.</span>
            <span class="c1"># If note, we use 0.6 as a default.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">magnetic_moment</span> <span class="o">=</span> <span class="n">override_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>
                <span class="n">magnetic_moments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">magnetic_moment</span><span class="p">)</span>

        <span class="c1"># This feature is in pymatgen, but I haven&#39;t added it here yet.</span>
        <span class="c1"># if self.constrain_total_magmom:</span>
        <span class="c1">#     nupdown = sum([mag if abs(mag) &gt; 0.6 else 0 for mag in incar[&quot;MAGMOM&quot;]])</span>
        <span class="c1">#     incar[&quot;NUPDOWN&quot;] = nupdown</span>

        <span class="k">return</span> <span class="n">magnetic_moments</span>
</pre></div>

        </details>

            <div class="docstring"><p>The __smart_magmom modifier goes through a series of checks to decide
what to set the MAGMOM as for VASP. In order of priority they are...
    (1) the magmom property attached to each site in the structure object
    (2) the spin property attached to the site's specie
    (3) a value provided explicitly (e.g. {"Co": 0.5})
    (4) a value of 0.6</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_smart_ldau" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_smart_ldau">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_smart_ldau</span><span class="signature">(structure, ldau_config)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ldau</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ldau_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This modifier handles a series of keyword arguments that are associated</span>
<span class="sd">        with LDAU, including LDAUJ, LDAUL, LDAUTYPE, LDAUU, LDAUPRINT, and LMAXMIX.</span>
<span class="sd">        Therefore, a complex dictionary is passed to this. The format looks like this...</span>
<span class="sd">            LDAU__multiple_keywords__smart_ldau = dict(</span>
<span class="sd">                LDAU__auto=True,</span>
<span class="sd">                LDAUTYPE=2,</span>
<span class="sd">                LDAUPRINT=1,</span>
<span class="sd">                LDAUJ={...},</span>
<span class="sd">                LDAUL={...},</span>
<span class="sd">                LDAUU={...},</span>
<span class="sd">                LMAXMIX__auto=True,</span>
<span class="sd">                )</span>
<span class="sd">        The LDAUJ, LDAUL, and LDAUU values can be a dictionary of elements to</span>
<span class="sd">        value, or (most commonly) a nested dictionary. For example...</span>
<span class="sd">            LDAUJ = {&quot;F&quot;:{&quot;Co&quot;:0}}</span>
<span class="sd">        This would mean if the structure is a fluoride, set the LDAUJ for Co to 0.</span>
<span class="sd">        If there are multiple options here (e.g. for fluorides and oxides), then</span>
<span class="sd">        priority is placed on the most electronegative element. This would mean</span>
<span class="sd">        some thing like yttrium oxide fluoride would be treated as a fluoride over</span>
<span class="sd">        an oxide.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first we need to go through the LDAUJ, LDAUL, and LDAUU keywords and</span>
        <span class="c1"># see what their values are. If all of these end up be 0 for all elements</span>
        <span class="c1"># then we actually don&#39;t need LDAU at all! Therefore, we&#39;ll go through</span>
        <span class="c1"># all of these keywords and build a dictionary of settings to return</span>
        <span class="c1"># at the end of this function</span>
        <span class="n">ldau_settings</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># To help decide how we set these values, let&#39;s check what the most</span>
        <span class="c1"># electronegative element is, which will be last in the sorted composition</span>
        <span class="n">most_electroneg</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">elements</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span>

        <span class="c1"># As we go through these settings, we want see if we are even using LDAU.</span>
        <span class="c1"># For example if we ran a calculation on NaCl, we&#39;d probably see that</span>
        <span class="c1"># all LDAUJ/LDAUL/LDAUU values are just 0. In that case, we can just</span>
        <span class="c1"># throw away (i.e. turn off) all LDAU settings. Therefore, we have a term</span>
        <span class="c1"># &quot;using_ldau&quot; that is false until proven otherwise.</span>
        <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">ldau_keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUL&quot;</span><span class="p">,</span> <span class="s2">&quot;LDAUU&quot;</span><span class="p">]:</span>

            <span class="c1"># grab the sub-dictionary that maps elements to this keyword.</span>
            <span class="c1"># If it&#39;s not there, just use an empty dictionary.</span>
            <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ldau_keyword</span><span class="p">,</span> <span class="p">{})</span>

            <span class="c1"># check if the most electronegative element is in the override_values</span>
            <span class="c1"># and if so, see if it has a subdictionary in it. We use this</span>
            <span class="c1"># dictionary as our base one to pull values from.</span>
            <span class="k">if</span> <span class="n">most_electroneg</span> <span class="ow">in</span> <span class="n">keyword_config</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">],</span> <span class="nb">dict</span>
            <span class="p">):</span>
                <span class="n">keyword_config</span> <span class="o">=</span> <span class="n">keyword_config</span><span class="p">[</span><span class="n">most_electroneg</span><span class="p">]</span>

            <span class="c1"># now iterate through all the sites and grab the assigned value. If nothing</span>
            <span class="c1"># is set then the default is 0.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">keyword_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span>
            <span class="p">]</span>

            <span class="c1"># now that we have this keyword all set, we add it to our results</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="n">ldau_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

            <span class="c1"># check to see if we are using ldau here (i.e. any value is not 0)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="n">using_ldau</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># now check if we actaully need LDAU here. If not, we can throw out all</span>
        <span class="c1"># settings and just return an empty dictionary</span>
        <span class="k">if</span> <span class="n">using_ldau</span> <span class="ow">and</span> <span class="s2">&quot;LDAU__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAU&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># we want to modify LMAXMIX if LSDA+U and there are any d or f electrons</span>
        <span class="k">if</span> <span class="s2">&quot;LMAXMIX__auto&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="c1"># first iterate through all elements and check for f-electrons</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">56</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="c1"># now check for elements that contain d-electrons</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
                <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LMAXMIX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c1"># The remaining LDAU keywords are LDAUPRINT and LDAUTYPE, which we just</span>
        <span class="c1"># leave at what is set in the input</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUPRINT&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUPRINT&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;LDAUTYPE&quot;</span> <span class="ow">in</span> <span class="n">ldau_config</span><span class="p">:</span>
            <span class="n">ldau_settings</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldau_config</span><span class="p">[</span><span class="s2">&quot;LDAUTYPE&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ldau_settings</span>
</pre></div>

        </details>

            <div class="docstring"><p>This modifier handles a series of keyword arguments that are associated
with LDAU, including LDAUJ, LDAUL, LDAUTYPE, LDAUU, LDAUPRINT, and LMAXMIX.
Therefore, a complex dictionary is passed to this. The format looks like this...
    LDAU__multiple_keywords__smart_ldau = dict(
        LDAU__auto=True,
        LDAUTYPE=2,
        LDAUPRINT=1,
        LDAUJ={...},
        LDAUL={...},
        LDAUU={...},
        LMAXMIX__auto=True,
        )
The LDAUJ, LDAUL, and LDAUU values can be a dictionary of elements to
value, or (most commonly) a nested dictionary. For example...
    LDAUJ = {"F":{"Co":0}}
This would mean if the structure is a fluoride, set the LDAUJ for Co to 0.
If there are multiple options here (e.g. for fluorides and oxides), then
priority is placed on the most electronegative element. This would mean
some thing like yttrium oxide fluoride would be treated as a fluoride over
an oxide.</p>
</div>


                            </div>
                            <div id="Incar.keyword_modifier_smart_ismear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Incar.keyword_modifier_smart_ismear">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">keyword_modifier_smart_ismear</span><span class="signature">(structure, ismear_config)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">keyword_modifier_smart_ismear</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ismear_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The smearing value used here depends on if we have a semiconductor,</span>
<span class="sd">        insulator, or metal. This modifier makes a &quot;best-guess&quot; on what the</span>
<span class="sd">        material is and uses the proper smearing type. Note that if this</span>
<span class="sd">        guess is wrong, it is useful to have the IncorrectSmearing error</span>
<span class="sd">        handler to fix this as VASP runs.</span>

<span class="sd">        Read more about the VASP recommended ISMEAR settings here:</span>
<span class="sd">            https://www.vasp.at/wiki/index.php/ISMEAR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># for now we just go through the structure and if all elements are</span>
        <span class="c1"># metals, then we say it&#39;s a metal. Otherwise, we treat the structure</span>
        <span class="c1"># as a semiconductor or insulator.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">is_metal</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">):</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ismear_settings</span> <span class="o">=</span> <span class="n">ismear_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;non-metal&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">return</span> <span class="n">ismear_settings</span>
</pre></div>

        </details>

            <div class="docstring"><p>The smearing value used here depends on if we have a semiconductor,
insulator, or metal. This modifier makes a "best-guess" on what the
material is and uses the proper smearing type. Note that if this
guess is wrong, it is useful to have the IncorrectSmearing error
handler to fix this as VASP runs.</p>

<p>Read more about the VASP recommended ISMEAR settings here:
    https://www.vasp.at/wiki/index.php/ISMEAR</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.dict</dt>
                                <dd id="Incar.get" class="function">get</dd>
                <dd id="Incar.setdefault" class="function">setdefault</dd>
                <dd id="Incar.pop" class="function">pop</dd>
                <dd id="Incar.popitem" class="function">popitem</dd>
                <dd id="Incar.keys" class="function">keys</dd>
                <dd id="Incar.items" class="function">items</dd>
                <dd id="Incar.values" class="function">values</dd>
                <dd id="Incar.update" class="function">update</dd>
                <dd id="Incar.fromkeys" class="function">fromkeys</dd>
                <dd id="Incar.clear" class="function">clear</dd>
                <dd id="Incar.copy" class="function">copy</dd>

            </div>
                                </dl>
                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>