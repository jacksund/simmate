{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p>This directory hosts the source files for Simmate's online documentation. You can access the live docs here. If you would like to host our documentation locally for offline access, then you can run the following commands after doing a dev install of Simmate:</p> <pre><code>mkdocs build\n</code></pre> <p>You can then open up the generated files to view the offline documentation.</p>"},{"location":"change_log/","title":"Updates","text":""},{"location":"change_log/#check-your-installed-version","title":"Check your installed version","text":"<p>When importing simmate and establishing a connection to the database, a warning message will be displayed if your version is not the most recent one. You can also verify this via the command-line:</p> <pre><code>simmate version\n</code></pre>"},{"location":"change_log/#upgrading-to-the-latest-version","title":"Upgrading to the Latest Version","text":"<p>We strongly advise installing simmate in a fresh conda environment instead of updating it within your current environment: <pre><code>conda create -n my_env -c conda-forge python=3.11 simmate\n</code></pre></p> <p>Ensure that the expected version is installed: <pre><code>simmate version\n</code></pre></p> <p>Update your database to be compatible with the new installation: <pre><code>simmate database update\n</code></pre></p> <p>Warning</p> <p>The command <code>simmate database update</code> is only effective from <code>v0.15.0</code> onwards. Earlier versions of simmate necessitate a complete database reset when updating versions. So, if your original database version is <code>v0.14.0</code> or earlier, you must run <code>simmate database reset</code>.</p>"},{"location":"change_log/#understanding-version-numbers","title":"Understanding Version Numbers","text":"<p>Our releases follow semantic versioning. This implies that versions (e.g., <code>v1.2.3</code>) correspond to <code>MAJOR.MINOR.PATCH</code>. Each version number increases following these changes:</p> <ul> <li><code>MAJOR</code> = incompatible API changes</li> <li><code>MINOR</code> = addition of new functionality (without API changes)</li> <li><code>PATCH</code> = bug fixes and documentation updates (without API changes)</li> </ul> <p>There is one significant exception to the above rules -- <code>MAJOR=0</code> releases. Any <code>v0.x.y</code> release is considered developmental, where APIs are subject to change and are not deemed stable.</p>"},{"location":"change_log/#upcoming-release","title":"Upcoming Release","text":"<p>Tip</p> <p>To view ongoing changes that haven't been finalized or merged yet, check our active pull-requests on GitHub</p> <p>Enhancements</p> <ul> <li>added frontend framework and docs, based off of a fork of <code>django-unicorn</code></li> <li>added custom API token generation and auth backend</li> <li>added <code>CSV</code> download button on the <code>Data</code> web views</li> <li>added <code>api_view</code> decorator for basic REST endpoints </li> <li>added <code>file_upload</code> web component</li> <li>added export of SDF metadata</li> <li>added <code>foriegn_key_link</code> util</li> <li>added <code>tags</code> support in dynamic components</li> <li>added html table and entry context hooks</li> <li>added <code>loading_spinner</code> tag for unicorn components</li> <li>added <code>plotly_figure</code> filter tag for rendering plots</li> <li>added <code>report</code> features to database tables and data_explorer views</li> <li>added <code>StatusTracking</code> model to <code>database.base_data_types</code></li> <li>added <code>is_dueterated</code> methods to <code>Molecule</code></li> <li>added web scrape of news archive for <code>apps.bcpc</code></li> <li>added <code>apps.ppdb</code></li> <li>added dev apps <code>chatbot</code> and <code>analysis_dashboard</code></li> <li>added <code>database.external_connectors</code> utils</li> <li>added proof of concept htmx app for frontend forms</li> <li>added <code>toolkit.datastores</code> and <code>toolkit.dataframes</code> helper modules</li> <li>added molecular and poc apps to the list of df</li> <li>allow conditional postgres-rdkit extension with settings flag</li> <li>added <code>startup_method</code> hook to simmate workers</li> </ul> <p>Refactors</p> <ul> <li>refactored website's workflow tab to use new API backend</li> <li>removed <code>django-contrib-comments</code>, <code>django-crispy-forms</code>, <code>dj-database-url</code>, <code>django-filter</code>, and <code>djangorestframework</code> dependencies</li> <li>update <code>breadcrumbs</code> tag to include deprec <code>breadcrumb_active</code></li> <li>workflows results in the web ui now exists within the Data tab. The workflow tab has been limited to submission, docs, and analytics</li> <li><code>DynamicApiView</code> was split up into separate views for easier debugging and future enhancements</li> <li><code>website.engine</code> apps and others are condensed into <code>core_components</code>, <code>data_explorer</code>, and <code>workflows</code> apps</li> <li>refactored <code>toolkit.featurizers</code> module</li> <li>moved all of <code>simmate.engine</code> module into <code>simmate.workflows</code></li> </ul> <p>Fixes</p> <ul> <li>fix Data tab in website view failing to load due to molecule template</li> <li>fix workflow names that have captial letters next to eachother (e.g, <code>LogDWorkflow</code> --&gt; <code>log-d-workflow</code>)</li> <li>fix <code>parse_multiselect</code> util when nested in a <code>create_many</code> form</li> <li>fix <code>unicorn.loading</code> activity when <code>Unicorn.call()</code> js is called</li> <li>fix <code>to_sdf</code> export</li> </ul>"},{"location":"change_log/#v0180-20250420","title":"v0.18.0 (2025.04.20)","text":"<p>Enhancements</p> <ul> <li>added a molecular toolkit, which is a wrapper around <code>rdkit</code> that cleans up the python api</li> <li>updated Data web pages and UI to be more user friendly</li> <li>added frontend framework for building dynamic web forms/pages</li> <li>enabled data management from web ui -- allowing users to create and update a dataset from the ui</li> <li>added chemdraw support and beta apps for molecular datasets (eMolecules, Enamine, Chemspace, etc)</li> <li>added Quantum Espresso support</li> <li>added rdkit-postgres cartridge support</li> <li>large updates to the <code>BadELF</code> app to support materials with covalent and metallic character</li> </ul> <p>Refactors</p> <ul> <li><code>django_unicorn</code> dependency was forked and refactored into a custom interal version</li> <li>REST APIs for data views no longer use <code>django_rest_framework</code></li> <li>add the <code>simmate.apps.dev</code> module for early-stage, experimental apps</li> <li>the <code>database.third_parties</code> module is now moved into individual apps: <code>materials_project</code>, <code>jarvis</code>, <code>aflow</code>, and <code>oqmd</code></li> </ul> <p>Fixes</p> <ul> <li>many misc fixes to the website UI and settings config</li> </ul>"},{"location":"change_log/#v0170-20240520","title":"v0.17.0 (2024.05.20)","text":"<p>Enhancements</p> <ul> <li>add api authentication via tokens for private Simmate servers</li> <li>add tips for docker installations &amp; permissions</li> <li>allow custom django apps to be added to <code>INSTALLED_APPS</code> via <code>extra_django_apps</code></li> <li>allow override of django settings via <code>django_settings</code></li> <li>add several web UI components (e.g. select2 elements for forms)</li> <li>add \"Table Info\" page and utils for dynamically building database docs</li> <li><code>badelf</code> app was reworked and now uses <code>pybader</code> for its core engine</li> </ul> <p>Refactors</p> <ul> <li>update docs for creating new Simmate apps with URLs</li> </ul> <p>Fixes</p> <ul> <li>fix <code>show_columns</code> bug when there are relations to basic django models (like <code>User</code>)</li> <li>catch incorrect use of <code>simmate database reset</code> when using the maintenance database</li> <li>fix typo in setting email env vars</li> </ul>"},{"location":"change_log/#v0160-20240127","title":"v0.16.0 (2024.01.27)","text":"<p>Enhancements</p> <ul> <li>added <code>dotdict</code> utility for easy dot-access with nested dictionary objects</li> <li>all settings can be added via environment variables for cloud-based deployments</li> <li>add <code>@workflow</code> decorator for easily creating basic workflows</li> <li>add <code>_incar_updates</code> to <code>VaspWorkflow</code>s for cleaner inheritance &amp; syntax</li> <li>add Docker builds for Quantum Espresso to help new users</li> <li>add Docker builds for Bader to help new users</li> <li>add <code>simmate config</code> command to help inspect and update settings</li> </ul> <p>Refactors</p> <ul> <li>Fully reimplemented how all settings are loaded</li> <li>Revised all documentation and tutorials</li> </ul> <p>Fixes</p> <ul> <li>fix bug where user-provided <code>command</code> parameter is not properly loaded</li> </ul> <p>0.16.1 (2024.01.28)</p> <ul> <li>fix bugs for Docker-QE runs</li> <li>fix typos in Getting Started tutorials</li> </ul>"},{"location":"change_log/#v0150-20240104","title":"v0.15.0 (2024.01.04)","text":"<p>Enhancements</p> <ul> <li>Allow custom html templates and static files that override those shipped by default</li> <li>add <code>simmate engine</code> commands like <code>stats-detail</code> and <code>workitems</code> that show details of workitems in the database</li> <li>updated third-party archives (Materials Project, COD, JARVIS, OQMD)</li> <li>eased database updates between simmate versions by using django migrations</li> <li>added <code>bypass_nones</code> utility to help handle imperfect datasets where not all entries have a column</li> <li>misc updates to the website interface, especially to the <code>data explorer</code> pages</li> <li>add Microsoft allauth support to sign in use external account</li> <li>allow \"login required\" access to server via evironment variables (disabled by default)</li> <li>allow \"internal only\" access to server via evironment variables (disabled by default)</li> <li>add <code>django-simple-history</code> support to track user changes on specific models</li> <li>add <code>@check_db_conn</code> decorator to help with database connection closures/timeouts</li> <li>add <code>simmate engine start-schedules</code> which let's you configure periodic tasks for individual apps (e.g. check a table for updates every 5 minutes). Includes error handling and email alerts. (Note: this a quick alternative to full Prefect system)</li> <li>add warren_lab app with Warren Lab preferred VASP settings</li> <li>add badelf app with class oriented tools for performing BadELF analyses</li> <li>add basic quantum espresso support</li> </ul> <p>Refactors</p> <ul> <li>remove mamba support now that libmamba is default conda solver</li> <li>switch CI from mamba back to conda</li> </ul> <p>Fixes</p> <ul> <li>fix bug where workers incorrectly grab substring tag matches (e.g. a worker submited with the tag <code>ex</code> would incorrectly grab jobs like <code>ex-01</code> or <code>ex-02</code>)</li> </ul> <p>0.15.1 (2024.01.11)</p> <ul> <li>refactor &amp; fix bugs for <code>warren_lab</code> and <code>badelf</code> apps</li> </ul>"},{"location":"change_log/#v0140-20230706","title":"v0.14.0 (2023.07.06)","text":"<p>Enhancements</p> <ul> <li>add <code>django-unicorn</code> to deps to enable dynamic fullstack web UIs</li> <li>add ChemDoodle js/css to website headers for use elsewhere</li> <li>add \"Example Scripts\" section to doc website with several new scripts</li> <li>many updates to the web UI to accomodate molecular datasets and workflows</li> <li>add <code>simmate engine</code> commands to help with tags and different queues</li> <li>add docs to help with simmate workers, clusters, and tagging</li> <li>add <code>simmate-vasp</code> command for common VASP utilities like testing config, plotting, and prepping inputs</li> <li>add utilities to chunk larger than memory datafiles (csv, sdf, cifs, etc.)</li> </ul> <p>Refactors</p> <ul> <li>VASP potcar references to \"element mappings\" is now standarized to \"potcar mappings\"</li> <li>refactor docs with new \"Apps\" section</li> <li>full refactor of <code>simmate engine</code> commands. many have been shortened/renamed</li> <li>restrategized workflows that use output files from others. The <code>copy_previous_directory</code> input parameter has been removed and replaced with workflow attributes like <code>use_previous_directory</code> and <code>has_prerequisite</code>, combined with an optional <code>previous_directory</code> parameter.</li> </ul> <p>Fixes</p> <ul> <li>fix bug where hyphens aren't allowed in the database name</li> <li>fix guide for DO database setup</li> <li>fix incorrect evolutionary search imports</li> <li>hide pymatgen POTCAR warnings</li> <li>fix github CI bug for MacOS being unstable</li> <li>fix bug for zombie jobs causing evolutionary search to hang</li> <li>fix premature triggering of frozen error</li> </ul>"},{"location":"change_log/#v0130-20230306","title":"v0.13.0 (2023.03.06)","text":"<p>Enhancements</p> <ul> <li>add <code>relax_bulk</code> and <code>relax_endpoints</code> parameters to optionally turn off pre-relaxations in NEB</li> <li>add CLEASE app for cluster expanison calculations (these workflows are highly experimental at the moment - so use with caution)</li> <li>update \"bad-elf\" workflow to accept an empty-atom template structure or a list of empty sites</li> <li>add python 3.11 support</li> <li><code>simmate database reset</code> now supports Postgres (requires admin user)</li> <li>docker images are now published to DockerHub and Github packages</li> </ul> <p>Refactors</p> <ul> <li><code>calculators</code> module is now the <code>apps</code> module and terminology is changed throughout the repo</li> <li>many dependencies are reworked to optional dependencies as all <code>apps</code> are now optional</li> <li><code>workflow_engine</code> module has been renamed to <code>engine</code> to help shorten commands and import lines</li> <li>rework CI to use mamba instead of conda</li> <li>pull out dependencies for some apps that are now optional</li> <li>reorganize <code>Incar</code> class and move some functionality to general <code>utilities</code></li> <li>NEB module is reorganized to help with building custom sets</li> </ul> <p>Fixes</p> <ul> <li>fix site ordering in NEB supercell structures</li> <li>improve installation speed and guide users to conda alternatives like mamba</li> <li>clean up docs and fix several links</li> <li>apps are now registered to the web UI</li> </ul> <p>Warning</p> <p>The refactoring of simmate \"apps\" led to many breaking changes in the python API. We strongly recommend clearing your <code>~/simmate/</code> directory, especially the <code>my_env-apps.yaml</code> file because app names have changed.</p> <p>0.13.1 (2023.03.11)</p> <ul> <li>recover from <code>connection already closed</code> errors after long workflow runs</li> <li>fix bug where <code>simmate database reset</code> fails when there is no database <code>postgres</code> available</li> <li>update django regression of <code>django.db.backends.postgresql_psycopg2</code> to <code>django.db.backends.postgresql</code></li> <li>fix bug where simmate cannot read vasp results due atypical number (e.g. -0.33328-312)</li> <li>fix bug where postgres cannot json serialize bs or dos results (int64 numbers)</li> <li>fix incorrect pointing of VASP potcars in matproj presets</li> <li>from <code>from_directory</code> method of the <code>Relaxation</code> database class</li> <li>fix HSE bandstructure and DOS kpoint file writing</li> </ul> <p>0.13.2 (2023.03.20)</p> <ul> <li>fix pickling error for <code>workflow.run_cloud</code> command</li> <li><code>simmate.website.third_parties</code> module is now the <code>data_explorer</code> module. With this, you can now specify custom database tables to appear in the \"Data\" section for the web UI</li> </ul>"},{"location":"change_log/#v0120-20221023","title":"v0.12.0 (2022.10.23)","text":"<p>Enhancements</p> <ul> <li>add structure creators for <code>ASE</code>, <code>GASP</code>, <code>PyXtal</code>, <code>AIRSS</code>, <code>CALYPSO</code>, <code>USPEX</code>, and <code>XtalOpt</code> as well as documentation for creators.</li> <li>add <code>simmate version</code> command</li> <li>changelog and update guide added to documentation website</li> <li>add <code>show-stats</code>, <code>delete-finished</code>, and <code>delete-all</code> commands to <code>workflow-engine</code></li> <li>add <code>Cluster</code> base class + commands that allow submitting a steady-state cluster via subprocesses or slurm</li> <li>add <code>started_at</code>, <code>created_at</code>, <code>total_time</code>, and <code>queue_time</code> columns to <code>Calculation</code> tables</li> <li>add <code>exlcude_from_archives</code> field to workflows to optionally delete files when compressing outputs to zip archives</li> <li>various improvements added for evolutionary search workflows, such as parameter optimization, new output files, and website views</li> <li>add <code>Fingerprint</code> database table and integrate it with <code>Fingerprint</code> validator</li> <li>support &gt;2 element hull diargrams and complex chemical systems</li> </ul> <p>Refactors</p> <ul> <li>optimize <code>get_series</code> method of <code>relaxation.vasp.staged</code></li> <li>reorganize <code>selectors</code> module for evolutionary structure prediction</li> </ul> <p>Fixes</p> <ul> <li>fix dynamic loading of toolkit structures from third-party databases</li> <li>fix race condition with workers and empty queues</li> <li>increases default query rate for <code>state.result()</code> to lessen database load</li> </ul>"},{"location":"change_log/#v0110-20220910","title":"v0.11.0 (2022.09.10)","text":"<p>Enhancements</p> <ul> <li>REST API fields can now be specified directly with the <code>api_filters</code> attribute of any <code>DatabaseTable</code> class &amp; fields from mix-ins are automatically added</li> <li>add <code>archive_fields</code> attribute that sets the \"raw data\" for the database table &amp; fields from mix-ins are automatically added</li> <li>accept <code>TOML</code> input files in addition to <code>YAML</code></li> <li>convergence plots and extras are now written for many workflow types (such as relaxations)</li> <li>when <code>use_database=True</code>, output files are automatically written and the workup method is directly paired with the database table.</li> <li>NEB workflow now accepts parameters to tune how distinct pathways are determined, including the max pathway length and cutoffs at 1D percolation.</li> <li>add <code>MatplotlibFigure</code> and <code>PlotlyFigure</code> classes to help with writing output files and also implementing these figures in the website UI</li> <li>update website to include workflow calculator types and add API links</li> <li>custom projects and database tables are now registered with Simmate and a intro guide has been added</li> <li>continued updates for <code>structure-prediction</code> workflows</li> <li>add inspection of methods for default input values and display them in metadata</li> </ul> <p>Refactors</p> <ul> <li>the <code>website.core_components.filters</code> module has been absorbed into the <code>DatabaseTable</code> class/module</li> <li>yaml input for custom workflows now matches the python input format</li> <li>workup methods are largely depreciated and now database entries are returned when a workflow has <code>use_database=True</code></li> <li>several NEB input parameters have been renamed to accurate depict their meaning.</li> <li>customized workflow runs now save in the original database table under the \"-custom\" workflow name</li> <li><code>structure_string</code> column renamed to <code>structure</code> to simplify api logic</li> <li>clean up <code>toolkit.validators</code> module and establish fingerprint base class</li> <li><code>calculators</code> and <code>workflows</code> modules are now based on simmate apps</li> </ul> <p>Fixes</p> <ul> <li>fix bug in windows dev env where <code>simmate run-server</code> fails to find python path</li> <li>fix bug in <code>workflows explore</code> command where 'vasp' is the assumed calculator name</li> <li>fix broken example code in custom workflow docs</li> <li>fix broken website links and workflow views</li> </ul> <p>0.11.1 (2022.09.12)</p> <ul> <li>fix transaction error with workers on a PostGres backend</li> </ul>"},{"location":"change_log/#v0100-20220829","title":"v0.10.0 (2022.08.29)","text":"<p>Enhancements</p> <ul> <li>add NEB base classes to inherit from for making new subflows</li> <li>improve formatting of logging and cli using <code>typer</code> and <code>rich</code></li> <li>cli now supports auto-completion to help with long commands</li> <li>add <code>convergence_limit</code> parameter to evolutionary search that works alongside <code>limit_best_survival</code>. This will absorb minor changes in energy with equivalent structures from prolonging the search.</li> <li>add <code>ExtremeSymmetry</code> transformation to attempt symmetry reduction on disordered structure</li> <li>account for structures in <code>fixed-composition</code> having fewer nsites than input becuase of symmetry reduction during relaxation. Also, add <code>min_structures_exact</code> parameter to ensure we have at least N structures with the expected number of sites</li> <li>add experimental <code>variable-composition</code> (variable refers to nsites, not stoichiometry) and <code>binary-composition</code> evolutionary searches</li> <li>allow custom workflows to run from yaml</li> <li>update MatProj data to new api, and add severl new columns for data (e.g. mag + band gap)</li> </ul> <p>Refactors</p> <ul> <li>isolate optional dependencies so that our install is smaller</li> <li>remove click in favor of higher-level package (typer)</li> <li><code>pre_standardize_structure</code> and <code>pre_sanitize_structure</code> functionality is now merged in to a <code>standardize_structure</code> parameter that accepts different mode. <code>symmetry_tolerance</code> and <code>angle_tolerance</code> parameters can also modify the symmetry analysis done.</li> <li>metadata files are now numbered to allow multiple metadata files in the same directory</li> <li>refactor &amp; clean up transformation module for readability</li> <li>remove <code>SimmateFuture</code> class and merge functionality into <code>WorkItem</code></li> <li>switch from pdoc to mkdocs for documentation and remove <code>get_doc_from_readme</code>. Code and doc organization are now decoupled.</li> <li>rename run commands based on user preference. the <code>run</code> is now <code>run-quick</code>. <code>run-yaml</code> is now <code>run</code>. <code>run-cloud</code> now assumes a yaml input.</li> <li>remove <code>tqdm</code> dependency in favor of <code>rich.progress</code></li> <li>refactor transformations to static methods</li> </ul> <p>Fixes</p> <ul> <li>fix <code>module not found</code> error by adding ASE to dependencies</li> <li>fix bug with postgres database trying to delete sqlite locally</li> <li>fix dask throwing errors with logging</li> <li>fix bug where <code>fixed-composition</code> searches fail to detect individuals that have been symmetrically reduced (and therefore have fewer nsites than expected)</li> <li>fix evolutionary search failures when writing output files while files are opened/locked</li> <li>fix NEB workflows failing due to Walltime handler</li> <li>fix NEB workflows hints for <code>workup</code> failure due to missing start/end image folders</li> </ul>"},{"location":"change_log/#v090-20220817","title":"v0.9.0 (2022.08.17)","text":"<p>Enhancements</p> <ul> <li>improve the warning associated with workflow failure because of \"command not found\" issues</li> <li>workers now ignore and reset tasks that fail with \"command not found\". 2 workers failing with this error will result in the WorkItem being canceled</li> <li><code>RandomWySites</code> can now generate wyckoff combinations lazily (or up front) depending on use case</li> <li>add <code>simmate utilities</code> command group with <code>archive-old-runs</code></li> <li>add <code>start-cluster</code> command for starting many local workers</li> <li>add <code>structure-prediction</code> workflows</li> <li>add plotting/output utilities to <code>EvolutionarySearch</code> and <code>relaxation.vasp.staged</code></li> </ul> <p>Refactors</p> <ul> <li>evolutionary search now delay creations, transformations, and validation until runtime (used to be at time of structure submission)</li> <li><code>directory</code>, <code>compress_ouput</code>, and <code>run_id</code> are now default input parameters for subclasses of <code>Workflow</code>. If these are unused, the <code>run_config</code> must include <code>**kwargs</code></li> <li>add <code>isort</code> for organizing module imports throughout package</li> </ul> <p>Fixes</p> <ul> <li>fixed when <code>source</code> is not being registered by several workflows</li> <li>fix docker image for installing anaconda, blender, and simmate on ubuntu</li> </ul>"},{"location":"change_log/#v080-20220811","title":"v0.8.0 (2022.08.11)","text":"<p>Enhancements</p> <ul> <li>NEB workflows now accept parameters for changing supercell size and number of images used</li> <li>add HSE workflows for static energy, relaxation, and DOS/BS electronic states</li> <li>add NPT and MatProj molecular dynamics workflows</li> <li>add SCAN workflows for static energy and relaxation</li> <li>test files can be provided within zip files, fixing excessive line counts on git commits</li> <li>add simmate worker that can run \"out-of-box\" and requires no set up</li> <li>add logging for useful debugging and monitoring of workflows</li> <li>pinned dependencies to maximum versions and manage with dependabot</li> </ul> <p>Refactors</p> <ul> <li>to simplify the creation of new workflows, <code>S3Task</code> is now <code>S3Workflow</code> and database tables are dynamically determined using the workflow name</li> <li>workflows of a given type (e.g. relaxation or static-energy) now share database tables in order to simplify overall database architecture</li> <li>migrate from <code>os.path</code> to <code>pathlib.Path</code> throughout package</li> <li>isolate prefect use to separate executors</li> <li>updated tutorials for new workflow engine and workers</li> <li>remove use of <code>setup.py</code> in favor of <code>pyproject.toml</code></li> </ul>"},{"location":"change_log/#v070-20220719","title":"v0.7.0 (2022.07.19)","text":"<p>Enhancements</p> <ul> <li>add guide for installing VASP v5 to Ubuntu v22.04 (@scott-materials, #183)</li> <li>add <code>simmate database load-remote-archives</code> command and <code>load_remote_archives</code> utility that populates all tables from <code>database.third_parties</code></li> <li>add <code>load_default_sqlite3_build</code> utility that downloads a pre-built database with all third-party data present. This is an alternative to calling <code>load_all_remote_archives</code> if you are using sqlite3 and saves a significant amount of time for users.</li> <li>standardize workflow naming. Note this breaks from python naming conventions for classes (#150)</li> <li>dynamically determine <code>register_kwargs</code> and rename property to <code>parameters_to_register</code></li> <li>add full-run unittests that call workflows and vasp (without emulation)</li> <li>add walltime error handler that properly shuts down calculations when a SLURM job is about to expire</li> <li>add option to restart workflows from a checkpoint</li> <li>automatically build api documentation using github actions</li> </ul> <p>Refactors</p> <ul> <li>refactor <code>start-worker</code> command to use prefect instead of the experimental django executor</li> <li>remove experimental <code>workflow_engine.executor</code></li> <li>move contents of <code>configuration.django.database</code> to <code>database.utilities</code></li> <li>upgraded to Prefect v2 (\"Orion\"). This involved the refactoring the entire <code>workflow_engine</code> module, and therefore the entire workflow library. (#185).</li> </ul> <p>0.7.1 (2022.07.19)</p> <ul> <li>fix incorrect handling of prefect v2 futures by workflows</li> </ul> <p>0.7.2 (2022.08.03)</p> <ul> <li>fix missing SVG files for web UI (#196).</li> </ul> <p>0.7.3 (2022.08.04)</p> <ul> <li>fix incorrect passing of <code>source</code> in NEB all-paths workflow causing it to fail</li> </ul>"},{"location":"change_log/#v060-20220625","title":"v0.6.0 (2022.06.25)","text":"<p>Enhancements</p> <ul> <li>add <code>AflowPrototypes</code> to the <code>database.third_parties</code> module (only includes data distributed through pymatgen)</li> <li>add new modules to <code>toolkit.structure_prediction</code> and <code>toolkit.creation</code>, including ones to provide <code>known</code>, <code>substitution</code>, and <code>prototype</code> based structures.</li> <li>add <code>created_at</code> and <code>updated_at</code> columns to all database tables</li> <li>check if there is a newer version of Simmate available and let the user know about the update</li> <li>add experimental <code>badelf</code> workflow for determining electride character</li> <li>add <code>electronic-structure</code> workflow which carries out both DOS and BS calculations</li> <li>add <code>database_obj</code> attribute to the <code>toolkit.Structure</code> base class that is dynamically set</li> </ul> <p>Refactors</p> <ul> <li>standardize <code>database_table</code> attribute for workflows by merging <code>calculation_table</code> and <code>result_table</code> attributes (#102)</li> <li>removed use of <code>-s</code>, <code>-c</code>, and <code>-d</code> shortcuts from the <code>workflows</code> commands</li> <li>refactor <code>relaxation/staged</code> workflow to run in single parent directory</li> <li>refactor evolutionary search algorithm (alpha feature)</li> <li>condense where parsing/deserialization of workflow parameters occurs to the refactored the <code>load_input_and_register</code> task. Originally, this would occur in multiple places (e.g. in the CLI module before submission, in the workflow run_cloud method, in the LoadInputAndRegister task, etc.) and involved boilerplate code. (#173)</li> <li>refactor experimental features <code>register_kwargs</code> and <code>customized</code> workflows</li> <li>refactor <code>LoadInputAndRegister</code> and <code>SaveOutputTask</code> to <code>load_input_and_register</code> and <code>save_result</code></li> </ul> <p>Fixes</p> <ul> <li>fix import for <code>visualization.structure.blender</code> module (@bocklund, #180)</li> <li>fix bug where <code>command</code> or <code>directory</code> improperly passes <code>None</code> when they are not set in the <code>simmate workflows run</code> command</li> <li>fix bug where <code>update_all_stabilities</code> grabs incomplete calculations (#177)</li> <li>fix bug where SCF calculation is not completed before the non-SCF DOS or BS calculation and causes the workflows to fail (#171)</li> <li>fix bug for Bader workflow by registering the prebader workflow (#174)</li> <li>fix bug where <code>source</code> is not determined with yaml-file submissions (#172)</li> </ul>"},{"location":"change_log/#v050-20220530","title":"v0.5.0 (2022.05.30)","text":"<ul> <li>update CI to test all OSs and pin pytest&lt;7.1 as temporary fix for #162</li> <li>fix spelling typos in <code>keyword_modifiers</code> (@laurenmm, #165)</li> <li>users can now apply their own unique keyword modifiers to Incars -- such as how we allow \"__per_atom\" or \"__smart_ismear\" tags on Incar settings. This change involved refactoring how <code>keyword_modifiers</code> are implemented for the <code>vasp.inputs.Incar</code> class. Rather than static methods attached to the base class, modifiers are now dynamically applied using the <code>add_keyword_modifier</code> classmethod.</li> <li>large update of <code>calculators.vasp.tasks</code> module where many new presets are reimplemented from <code>pymatgen.io.vasp.sets</code>. This includes robust unit testing to confirm that generated inputs match between simmate and pymatgen (see #157 for a list of presets)</li> <li>catch error with vasp freezing when <code>Brmix</code> handler switches to kerker mixing (@becca9835, #159)</li> </ul>"},{"location":"change_log/#v040-20220424","title":"v0.4.0 (2022.04.24)","text":"<ul> <li>add <code>description_doc_short</code> + <code>show_parameters</code> to workflows and use these to update the UI</li> <li>add django-allauth dependency for account management and google/github sign-ins</li> <li>archive directory as <code>simmate_attempt_01.zip</code> whenever an error handler is triggered</li> <li>depreciate the workflow parameter <code>use_prev_directory</code> in favor of <code>copy_previous_directory</code></li> </ul>"},{"location":"change_log/#v030-20220419","title":"v0.3.0 (2022.04.19)","text":"<ul> <li>add highly customizable VASP workflow</li> <li>add Bader analysis and ELF workflows</li> <li>update module readmes to warn of experimental features</li> <li>reorganize <code>toolkit</code> module</li> </ul>"},{"location":"change_log/#v020-20220415","title":"v0.2.0 (2022.04.15)","text":"<ul> <li>start the CHANGELOG!</li> <li>refactor API views and add <code>SimmateAPIViewSet</code> class</li> <li>refactor <code>simmate start-project</code> command and underlying methods</li> <li>refactor <code>simmate workflow-engine run-cluster</code> command and underlying methods</li> <li>continue outlining <code>file_converters</code> module</li> </ul>"},{"location":"change_log/#v014-20220412","title":"v0.1.4 (2022.04.12)","text":"<ul> <li>web interface styling</li> <li>minor bug fixes</li> </ul>"},{"location":"change_log/#v000-20220328","title":"v0.0.0 (2022.03.28)","text":"<ul> <li>initial release</li> <li>adding tests and docs</li> </ul>"},{"location":"home/","title":"Welcome!","text":""},{"location":"home/#before-you-begin","title":"Before you begin","text":"<p>This website is your go-to resource for all our tutorials and guides. Before diving in, you might want to explore:</p> <ul> <li>Our main website at simmate.org</li> <li>Our source code at github.com/jacksund/simmate</li> </ul>"},{"location":"home/#what-is-simmate","title":"What is Simmate?","text":"<p>Simmate is a full-stack framework for chemistry research. It helps you calculate properties and explore third-party databases for both for molecular and crystalline systems. For experts, it also provides a toolbox to build out your own chemistry applications.</p> <p>The computational side of chemistry research can be intimidating because there are so many programs to choose from, and it's challenging to select and combine them for your specific project. Simmate aims to be a link between the many diverse programs, databases, and utilities out there, and in turn, simplify the setup and execution of chemistry projects. Third-party datasets and tools are ingetrated into Simmate as \"apps\", where there is a growing list of supported software and databases. </p> <p>You can mix &amp; match these apps to meet your research needs and to even build out your own custom applications. Simmate includes a core chemical toolkit, workflow management system, database ORM, and web component library -- giving you a framework with essential frontend and backend tools. Our goal is for Simmate to be \"batteries-included\", so all of these apps &amp; tools are available within the base installation. To learn more about Simmate's scope &amp; design, as well as how it compares to other popular chemistry frameworks, visit our comparisons page.</p>"},{"location":"home/#a-sneak-peak-of-features","title":"A Sneak-Peak of Features","text":""},{"location":"home/#prebuilt-workflows","title":"Prebuilt Workflows","text":"<p>Simmate comes with ready-to-use workflows for most common calculated properties, ranging from simple XRD pattern prediction to intensive dynamic simulations. All workflows can be submitted via a website user-interface, the command-line, or custom python scripts:</p> yamlcommand linetomlpythonwebsite <pre><code># in example.yaml\nworkflow_name: relaxation.vasp.matproj\nstructure: NaCl.cif\ncommand: mpirun -n 8 vasp_std &gt; vasp.out\n</code></pre> <pre><code>simmate workflows run example.yaml\n</code></pre> <pre><code>simmate workflows run-quick relaxation.vasp.matproj --structure NaCl.cif\n</code></pre> <pre><code># in example.toml\nworkflow_name = \"relaxation.vasp.matproj\"\nstructure = \"NaCl.cif\"\ncommand = \"mpirun -n 8 vasp_std &gt; vasp.out\"\n</code></pre> <pre><code>simmate workflows run example.toml\n</code></pre> <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"relaxation.vasp.matproj\")\nstatus = workflow.run(structure=\"NaCl.cif\")\nresult = status.result()\n</code></pre> <pre><code>https://simmate.org/workflows/static-energy/vasp/matproj/submit\n</code></pre>"},{"location":"home/#scalable-orchestration","title":"Scalable Orchestration","text":"<p>Simmate can easily scale along with your project, whether you're on a single computer or across thousands of machines. It supports various setups, including university clusters with SLURM or PBS, and cloud platforms using Kubernetes and Docker.</p> create workflowschedule jobsadd remote resources <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef hello(name, **kwargs):  # (1)\n    print(f\"Hello {name}!\")\n    print(f\"Extra parameters configured for you: {kwargs}\")\n</code></pre> <ol> <li>We always use <code>**kwargs</code> because Simmate automatically provides extra variables at runtime, such as <code>run_id</code> and <code>directory</code>.</li> </ol> <pre><code>state = workflow.run_cloud(name=\"Jack\")  # (1)\nresult = state.result()  # (2)\n</code></pre> <ol> <li>On your local computer, schedule your workflow run. This returns a \"future-like\" object.</li> <li>This will wait until the job completes and return the result. Note, the job won't run until you start a worker that is connected to the same database</li> </ol> <pre><code>simmate engine start-worker  # (1)\n</code></pre> <ol> <li>In a separate terminal or even on a remote HPC cluster, you can start a worker that will start running any scheduled jobs in your database.</li> </ol>"},{"location":"home/#full-feature-database","title":"Full-Feature Database","text":"<p>Simmate's database can manage your perosnal data while also integrating with third-party databases such as COD, Materials Project, JARVIS, and others. It automatically constructs tables with common data types by including a wide range of standard columns. You can then access this data through a web interface, REST API, SQL, or Python ORM:</p> pythonSQLREST APIwebsite <pre><code>from simmate.database import connect # (1)\nfrom simmate.apps.materials_project.models import MatprojStructure\n\n# Query the database\nstructures = MatprojStructure.objects.filter(  # (2)\n    nsites__gte=3,\n    energy__isnull=False,\n    density__range=(1,5),\n    elements__icontains='\"C\"',\n    spacegroup__number=167,\n).all()\n\n# Convert to excel, a pandas dataframe, toolkit structures, etc.\ndf = structures.to_dataframe()\nstructures = structures.to_toolkit()\n</code></pre> <ol> <li>Follow the database tutorial to build our initial database with the command <code>simmate database reset</code></li> <li>This filter retrieves structures with: greater or equal to 3 sites, an energy value, density between 1 and 5, the element Carbon, and spacegroup number 167</li> </ol> <pre><code>SELECT *\nFROM materials_project__structures\nWHERE nsites &gt;= 3\n  AND energy IS NOT NULL\n  AND density BETWEEN 1 AND 5\n  AND elements ILIKE '%\"C\"%'\n  AND spacegroup_number = 167;\n</code></pre> <pre><code>https://simmate.org/third-parties/MatprojStructure/?format=json\n</code></pre> <pre><code>https://simmate.org/third-parties/MatprojStructure/\n</code></pre>"},{"location":"home/#beginner-friendly-toolkit","title":"Beginner-Friendly Toolkit","text":"<p>Simmate includes a <code>toolkit</code> that builds off popular packages in the chemistry community, specifically <code>rdkit</code> for molecules and <code>pymatgen</code> for periodic crystals. The end result is a toolkit for rapidly prototyping analyses. Here is an eample script that is straightforward &amp; clean with Simmate's toolkit, but less intuitive &amp; Pythonic for others:</p> simmate-toolkitrdkitoe-toolkit <pre><code>from simmate.toolkit import Molecule\n\n# STEP 1\nmolecules = Molecule.from_sdf_file(\"example.sdf\")\n\n# STEP 2\nmolecules_filtered = []\nfor molecule in molecules:\n    if molecule.num_stereocenters &gt; 3:\n        continue\n    if molecule.num_atoms_heavy &gt; 30:\n        continue\n    if \"Na\" in molecule.elements:\n        continue\n    molecules_filtered.append(molecule)\n\n# STEP 3\ninchi_keys = [m.to_inchi_key() for m in molecules_filtered]\n</code></pre> <pre><code>from rdkit import Chem\nfrom rdkit.Chem import FindMolChiralCenters, Descriptors\n\n# STEP 1\nmolecules = []\nwith Chem.SDMolSupplier(\"example.sdf\") as supplier:\nfor molecule in supplier:\n    if mol is None:\n        continue\n    molecules.append(molecule)\n\n# STEP 2\nmolecules_filtered = []\nfor molecule in molecules:\n\n    chiral_centers = FindMolChiralCenters(\n        molecule,\n        force=True,\n        includeUnassigned=True,\n        useLegacyImplementation=False,\n    )\n    if len(chiral_centers) &gt; 3:\n        continue\n\n    nheavy = Descriptors.HeavyAtomCount(molecule)\n    if nheavy &gt; 30:\n        continue\n\n    has_na = False  # false until proven otherwise\n    for atom in molecule.GetAtoms():\n        if atom.GetSymbol() == \"Na\":\n            has_na = True\n            break\n    if has_na:\n        continue\n\n    molecules_filtered.append(molecule)\n\n# STEP 3\ninchi_keys = [Chem.MolToInchiKey(m) for m in molecules_filtered]\n</code></pre> <pre><code>from openeye import oechem\nfrom openeye import oeiupac\n\n# STEP 1\nmolecules = []\nwith oechem.oemolistream(\"example.sdf\") as ifs:\n    for mol in ifs.GetOEMols():\n        if mol is None:\n            continue\n        molecules.append(mol)\n\n# STEP 2\nmolecules_filtered = []\nfor mol in molecules:\n\n    stereo_count = sum(1 for atom in mol.GetAtoms() if atom.IsChiral())\n    if stereo_count &gt; 3:\n        continue\n\n    heavy_atom_count = sum(\n        1 for atom in mol.GetAtoms() if atom.GetAtomicNum() &gt; 1\n    )\n    if heavy_atom_count &gt; 30:\n        continue\n\n    has_na = any(atom.GetAtomicNum() == 11 for atom in mol.GetAtoms())\n    if has_na:\n        continue\n\n    molecules_filtered.append(mol)\n\n# STEP 3\ninchi_keys = [oeiupac.OECreateInChIKey(m) for m in molecules_filtered]\n</code></pre>"},{"location":"home/#need-help","title":"Need help?","text":"<p>Post your questions and feedback in our discussion section. </p>"},{"location":"parameters/","title":"Parameters","text":""},{"location":"parameters/#introduction","title":"Introduction","text":""},{"location":"parameters/#about","title":"About","text":"<p>This section provides a detailed overview of all unique parameters for all workflows.</p> <p>To identify the parameters allowed for a specific workflow, use the <code>explore</code> command or <code>workflow.show_parameters()</code>:</p> command linepython <pre><code>simmate workflows explore\n</code></pre> <pre><code>workflow.show_parameters()\n</code></pre>"},{"location":"parameters/#file-vs-python-formats","title":"File vs. Python formats","text":"<p>When switching from Python to YAML, make sure you adjust the input format of your parameters. This is especially important if you use python a <code>list</code> or <code>dict</code> for one of your input parameters. Further, if you have complex input parameters (e.g. nested lists, matricies, etc.), we recommend using a TOML input file instead:</p> listsdictionariesnested liststuple <p><pre><code># in python\nmy_parameter = [1,2,3]\n</code></pre> <pre><code># in yaml\nmy_parameter:\n    - 1\n    - 2\n    - 3\n</code></pre></p> <p><pre><code># in python\nmy_parameter = {\"a\": 123, \"b\": 456, \"c\": [\"apple\", \"orange\", \"grape\"]}\n</code></pre> <pre><code># in yaml\nmy_parameter:\n    a: 123\n    b: 456\n    c:\n        - apple\n        - orange\n        - grape\n</code></pre> <pre><code># in toml\n[my_parameter]\na = 123\nb = 456\nc = [\"apple\", \"orange\", \"grape\"]\n</code></pre></p> <p><pre><code># in python\nmy_parameter = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]\n</code></pre> <pre><code># in yaml (we recommend switching to TOML!)\nmy_parameter:\n    - - 1\n        - 2\n        - 3\n    - - 4\n        - 5\n        - 6\n    - - 7\n        - 8\n        - 9\n</code></pre> <pre><code># in toml\nmy_parameter = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]\n</code></pre></p> <p><pre><code># in python\nmy_parameter = (1,2,3)\n</code></pre> <pre><code># in yaml\nmy_parameter:\n    - 1\n    - 2\n    - 3\n# WARNING: This will return a list! Make sure you call \n#   `tuple(my_parameter)`\n# at the start of your workflow's `run_config` if you need a tuple.\n</code></pre> <pre><code># in toml\nmy_parameter = [1, 2, 3]\n# WARNING: This will return a list! Make sure you call \n#   `tuple(my_parameter)`\n# at the start of your workflow's `run_config` if you need a tuple.\n</code></pre></p>"},{"location":"parameters/#algorithm","title":"algorithm","text":"<p>This parameter is specific to the BadELf workflows in the warrenapp. Options include <code>badelf</code>, <code>voronelf</code>, or <code>zero-flux</code>.</p> <p><code>zero-flux</code> will use traditional bader-like partitioning. <code>voronelf</code> will use planes located at minima in the ELF along atomic bonds. <code>badelf</code> will use a hybrid, separating atoms with planes and bare electrons with a zero-flux surface.</p> yamltomlpython <pre><code>algorithm: badelf\n</code></pre> <pre><code>algorithm = \"badelf\"\n</code></pre> <pre><code>algorithm = \"badelf\"\n</code></pre>"},{"location":"parameters/#angle_tolerance","title":"angle_tolerance","text":"<p>This parameter is used to determine if the angles between sites are symmetrically equivalent when <code>standardize_structure=True</code>. The value is in degrees.</p> yamltomlpython <pre><code>angle_tolerance: 10.0\n</code></pre> <pre><code>angle_tolerance = 10.0\n</code></pre> <pre><code>angle_tolerance = 10.0\n</code></pre>"},{"location":"parameters/#chemical_system","title":"chemical_system","text":"<p>This parameter specifies the chemical system to be used in the analysis. It should be given as a string in the format <code>Element1-Element2-Element3-...</code>. For example, <code>Na-Cl</code>, <code>Y-C</code>, and <code>Y-C-F</code> are valid chemical systems.</p> yamltomlpython <pre><code>chemical_system: Na-Cl\n</code></pre> <pre><code>chemical_system = \"Na-Cl\"\n</code></pre> <pre><code>chemical_system = \"Na-Cl\"\n</code></pre> <p>Warning</p> <p>Some workflows only accept a chemical system with a specific number of elements. An example of this is the <code>structure-prediction.python.binary-composition</code> search which only allows two elements (e.g. <code>Y-C-F</code> would raise an error)</p>"},{"location":"parameters/#command","title":"command","text":"<p>This parameter specifies the command that will be called during the execution of a program. There is typically a default set for this that you only need to change if you'd like parallelization. For example, VASP workflows use <code>vasp_std &gt; vasp.out</code> by default but you can override this to use <code>mpirun</code>.</p> yamltomlpython <pre><code>command: mpirun -n 8 vasp_std &gt; vasp.out\n</code></pre> <pre><code>command = \"mpirun -n 8 vasp_std &gt; vasp.out\"\n</code></pre> <pre><code>command = \"mpirun -n 8 vasp_std &gt; vasp.out\"\n</code></pre>"},{"location":"parameters/#composition","title":"composition","text":"<p>The composition input can be anything compatible with the <code>Composition</code> toolkit class. Note that compositions are sensitive to atom counts / multiplicity. There is a difference between giving <code>Ca2N</code> and <code>Ca4N2</code> in several workflows. Accepted inputs include:</p> <p>a string (recommended)</p> yamltomlpython <pre><code>composition: Ca2NF\n</code></pre> <pre><code>composition = \"Ca2NF\"\n</code></pre> <pre><code>composition = \"Ca2NF\"\n</code></pre> <p>a dictionary that gives the composition</p> yamltomlpython <pre><code>composition:\n    Ca: 2\n    N: 1\n    F: 1\n</code></pre> <pre><code>[composition]\nCa = 2\nN = 1\nF = 1\n</code></pre> <pre><code>composition={\n    \"Ca\": 2, \n    \"N\": 1, \n    \"F\": 1,\n}\n</code></pre> <p>a <code>Composition</code> object (best for advanced logic)</p> python <pre><code>from simmate.toolkit import Compositon\n\ncomposition = Composition(\"Ca2NF\")\n</code></pre>"},{"location":"parameters/#compress_output","title":"compress_output","text":"<p>This parameter determines whether to compress the <code>directory</code> to a zip file at the end of the run. After compression, it will also delete the directory. The default is False.</p> yamltomlpython <pre><code>compress_output: true\n</code></pre> <pre><code>compress_output = true\n</code></pre> <pre><code>compress_output = True\n</code></pre>"},{"location":"parameters/#copy_previous_directory","title":"copy_previous_directory","text":"<p>This parameter determines whether to copy the directory from the previous calculation (if one exists) and use it as a starting point for the new calculation. This is only possible if you provided an input that points to a previous calculation. For instance, <code>structure</code> would need to use a database-like input:</p> yamltomlpython <pre><code>structure:\n    database_table: Relaxation\n    database_id: 123\ncopy_previous_directory: true\n</code></pre> <pre><code>copy_previous_directory: true\n\n[structure]\ndatabase_table = \"Relaxation\"\ndatabase_id = 123\n</code></pre> <pre><code>structure = {\"database_table\": \"Relaxation\", \"database_id\": 123}\ncopy_previous_directory=True\n</code></pre>"},{"location":"parameters/#diffusion_analysis_id","title":"diffusion_analysis_id","text":"<p>(advanced users only) This is the entry id from the <code>DiffusionAnalysis</code> table to link the results to. This is set automatically by higher-level workflows and rarely (if ever) set by the user.</p>"},{"location":"parameters/#directory","title":"directory","text":"<p>This is the directory where everything will be run -- either as a relative or full path. This is passed to the utilities function <code>simmate.ulitities.get_directory</code>, which generates a unique folder name if not provided (such as <code>simmate-task-12390u243</code>). This will be converted into a <code>pathlib.Path</code> object. Accepted inputs include:</p> <p>leave as default (recommended)</p> <p>a string</p> yamltomlpython <pre><code>directory: my-new-folder-00\n</code></pre> <pre><code>directory = \"my-new-folder-00\"\n</code></pre> <pre><code>directory = \"my-new-folder-00\"\n</code></pre> <p>a <code>pathlib.Path</code> (best for advanced logic)</p> python <pre><code>from pathlib import Path\n\ndirectory = Path(\"my-new-folder-00\")\n</code></pre>"},{"location":"parameters/#directory_new","title":"directory_new","text":"<p>Exclusive to the <code>restart.simmate.automatic</code> workflow, this is the folder where the workflow will be continued. It follows the same rules/inputs as the <code>directory</code> parameter.</p>"},{"location":"parameters/#directory_old","title":"directory_old","text":"<p>Exclusive to the <code>restart.simmate.automatic</code> workflow, this is the original folder that should be used as the starting point. It follows the same rules/inputs as the <code>directory</code> parameter.</p>"},{"location":"parameters/#downscale_resolution","title":"downscale_resolution","text":"<p>Exclusive to BadELF workflows. This is the resolution in voxels/Angstroms^3 that the ELF will be downscaled to in the ElfAnalysisToolkit to increase speed. This can be ignored by setting the value to <code>None</code>.</p> yamltomlpython <pre><code>downscale_resolution: 1200\n</code></pre> <pre><code>downscale_resolution = 1200\n</code></pre> <pre><code>downscale_resolution = 1200\n</code></pre>"},{"location":"parameters/#elf_analyzer_kwargs","title":"elf_analyzer_kwargs","text":"<p>Exclusive to BadELF workflows. These are the keyword arguments passed to the <code>ElfAnalyzerToolkit</code> class that control how features in the ELF (e.g. bare electrons, covalent/metallic bonds, etc.) are automatically found and labeled.</p> yamltomlpython <pre><code>elf_analyzer_kwargs:\n    resolution: 0.01,\n    include_lone_pairs: false,\n    include_shared_features: true,\n    metal_depth_cutoff: 0.1,\n    min_covalent_angle: 135,\n    min_covalent_bond_ratio: 0.4,\n    shell_depth: 0.05,\n    electride_elf_min: 0.5,\n    electride_depth_min: 0.2,\n    electride_charge_min: 0.5,\n    electride_volume_min: 10,\n    electride_radius_min: 0.3,\n    radius_refine_method: linear,\n    write_results: true,\n</code></pre> <pre><code>[elf_analyzer_kwargs]\nresolution = 0.01\ninclude_lone_pairs = false\ninclude_shared_features = true\nmetal_depth_cutoff = 0.1\nmin_covalent_angle = 135\nmin_covalent_bond_ratio = 0.4\nshell_depth = 0.05\nelectride_elf_min = 0.5\nelectride_depth_min = 0.2\nelectride_charge_min = 0.5\nelectride_volume_min = 10\nelectride_radius_min = 0.3\nradius_refine_method = \"linear\",\nwrite_results = true,\n</code></pre> <pre><code>elf_analyzer_kwargs = dict(\n    resolution = 0.01,\n    include_lone_pairs = false,\n    include_shared_features = true,\n    metal_depth_cutoff = 0.1,\n    min_covalent_angle = 135,\n    min_covalent_bond_ratio = 0.4,\n    shell_depth = 0.05,\n    electride_elf_min = 0.5,\n    electride_depth_min = 0.2,\n    electride_charge_min = 0.5,\n    electride_volume_min = 10,\n    electride_radius_min = 0.3,\n    radius_refine_method = \"linear\",\n    write_results = True,\n)\n</code></pre> <p>Each keyword argument controls an aspect of how ELF features are found:</p>"},{"location":"parameters/#resolution","title":"resolution","text":"<p>The interval at which to scan the ELF to generate BifurcationGraphs. Larger values will be faster, but may miss bifurcations.</p>"},{"location":"parameters/#include_lone_pairs","title":"include_lone_pairs","text":"<p>Whether or not to include lone-pairs in the labeled structure. It is generally recommended to leave this as <code>false</code> when using plane partitioning for atoms.</p>"},{"location":"parameters/#include_shared_features","title":"include_shared_features","text":"<p>Whether or not to include shared features such as metallic/covalent bonds in the labeled structure. If splitting these features at their maxima with planes is the desired output, set to <code>false</code>. If the goal is a comprehensive charge analysis of these features, set to <code>true</code>. If set to <code>true</code>, the <code>shared_feature_algorithm</code> parameter will control how they are separated from nearby atoms/features.</p>"},{"location":"parameters/#metal_depth_cutoff","title":"metal_depth_cutoff","text":"<p>For ELF features other than atom cores/shells or lone-pairs, this parameter controls the maximum depth (Difference from ELF maximum to bifurcation) that a metallic feature can have. Any non-atomic/lone-pair feature with a depth below this value will be assigned as metallic.</p>"},{"location":"parameters/#min_covalent_angle","title":"min_covalent_angle","text":"<p>For features other than atom cores/shells, the algorithm will check whether the feature is along an atomic bond within an angle tolerance. This corresponds to the angle between the neighboring atoms and the feature. Any feature with an angle below this value will not be assigned covalent.</p>"},{"location":"parameters/#min_covalent_bond_ratio","title":"min_covalent_bond_ratio","text":"<p>When determining between a lone-pair or covalent bond, the algorithm will check how far along the bond the feature is (noramalized to 1). Anything below this parameters value will be considered a lone-pair. This is done to avoid misassignment in situations where the lone-pairs align with nearby atoms in a dipole interaction.</p>"},{"location":"parameters/#shell_depth","title":"shell_depth","text":"<p>In ionic compounds, the unshared electrons will form a sphere around the more electronegative atom. As the bond becomes more covalent, this feature will break into smaller features along the atomic bonds. As covalency increases, the depth of these features increases. Thus, this parameter effectively defines a cutoff for what should be considered covalent vs. ionic.</p> <p>Additionally, due to voxelation, atomic shells may split into many different basins around their ELF maximum. This parameter also controls recombining these voxelated basins into one.</p>"},{"location":"parameters/#electride_elf_min","title":"electride_elf_min","text":"<p>The minimum ELF value that a bare-electron feature must have to be considered an electride.</p>"},{"location":"parameters/#electride_depth_min","title":"electride_depth_min","text":"<p>The minimum ELF depth that a bare-electron feature must have to be considered an electride.</p>"},{"location":"parameters/#electride_charge_min","title":"electride_charge_min","text":"<p>The minimum charge that a bare-electron feature must have to be considered an electride.</p>"},{"location":"parameters/#electride_volume_min","title":"electride_volume_min","text":"<p>The minimum volume that a bare-electron feature must have to be considered an electride.</p>"},{"location":"parameters/#electride_radius_min","title":"electride_radius_min","text":"<p>The minimum ELF radius that a bare-electron feature must have to be considered an electride. The radius is defined as the distance from the feature to the closest atom minus that atoms radius. Atomic radii are determined by checking the EN difference between the atom and its nearest neighbors. If the EN difference is above 1.6, the average ionic radii for the atom is used. If the EN is below 1.6, the atomic radius is used.</p>"},{"location":"parameters/#radius_refine_method","title":"radius_refine_method","text":"<p>The type of interpolation used to refine the ionic radius. This only effects the data stored in the graphs created using the ElfAnalyzerToolkit, not the planes used in the BadELF algorithm. However, it does effect the radius used to find electride features.</p>"},{"location":"parameters/#write_results","title":"write_results","text":"<p>Whether or not to write the bifurcation plot and labeled structure generated by the BadELF algorithm to the assigned directory.</p>"},{"location":"parameters/#find_electrides","title":"find_electrides","text":"<p>Exclusive to the BadELF workflows. This parameter indicates whether the algorithm should search for electrides. Reasons to set this as false may be that the user knows there is no electride character in the structure of interest or if the user would like to manually indicate the location of electrides.</p> <p>Warning</p> <p>If this parameter is set to false, the <code>labeled_structure_up</code> and/or <code>labeled_structure_down</code> parameters must be set.</p> yamltomlpython <pre><code>find_electrides: true\n</code></pre> <pre><code>find_electrides = true\n</code></pre> <pre><code>find_electrides = True\n</code></pre>"},{"location":"parameters/#fitness_field","title":"fitness_field","text":"<p>(advanced users only) For evolutionary searches, this is the value that should be optimized. Specifically, it should minimize this value (lower value = better fitness). The default is <code>energy_per_atom</code>, but you may want to set this to a custom column in a custom database table.</p>"},{"location":"parameters/#ignore_low_pseudopotentials","title":"ignore_low_pseudopotentials","text":"<p>Exclusive to BadELF workflows. Indicates whether the algorithm should throw an exception when the used pseudopotential didn't contain enough valence electrons. It is generally recommended to leave this as False as the results will likely be nonsense. Instead it is recommended to use pseudopotentials with more electrons, such as Vasp's GW PPs.</p> yamltomlpython <pre><code>ignore_low_pseudopotentials: false\n</code></pre> <pre><code>ignore_low_pseudopotentials = false\n</code></pre> <pre><code>ignore_low_pseudopotentials = False\n</code></pre>"},{"location":"parameters/#input_parameters","title":"input_parameters","text":"<p>(experimental feature) Exclusive to <code>customized.vasp.user-config</code>. This is a list of parameters to pass to <code>workflow_base</code>.</p>"},{"location":"parameters/#is_restart","title":"is_restart","text":"<p>(experimental feature) This parameter indicates whether the calculation is a restarted workflow run. The default is False. If set to true, the workflow will go through the given directory (which must be provided) and determine where to resume.</p> yamltomlpython <pre><code>directory: my-old-calc-folder\nis_restart: true\n</code></pre> <pre><code>directory = \"my-old-calc-folder\"\nis_restart = true\n</code></pre> <pre><code>directory = \"my-old-calc-folder\"\nis_restart = True\n</code></pre>"},{"location":"parameters/#labeled_structure_up","title":"labeled_structure_up","text":"<p>In BadELF workflows, if <code>find_electrides</code> is set to false, this parameter is a structure with \"dummy\" atoms representing non-atomic features in the spin-up system. Inputs options are the same as for the <code>structure</code> parameter.</p> <p>Note</p> <p>If a non-polarized ELF/charge density is used, this represents the labeled structure for the total system.</p> <p>The required labels for each type of non-atomic feature are:</p> Feature Label Covalent Bond \"Z\" Lone-Pair \"Lp\" Metal \"M\" Electride \"E\" Other Bare Electron \"Le\" yamltomlpython <pre><code>labeled_structure_up: Ca2N_labeled_up.cif\n</code></pre> <pre><code>labeled_structure_up = Ca2N_labeled_up.cif\n</code></pre> <pre><code>labeled_structure_up: \"Ca2N_labeled_up.cif\"\n</code></pre>"},{"location":"parameters/#labeled_structure_down","title":"labeled_structure_down","text":"<p>The equivalent setting to <code>labeled_structure_up</code> for the spin-down system.</p> yamltomlpython <pre><code>labeled_structure_down: Ca2N_labeled_down.cif\n</code></pre> <pre><code>labeled_structure_down = Ca2N_labeled_down.cif\n</code></pre> <pre><code>labeled_structure_down: \"Ca2N_labeled_down.cif\"\n</code></pre>"},{"location":"parameters/#max_atoms","title":"max_atoms","text":"<p>For workflows that involve generating a supercell or random structure, this will be the maximum number of sites to allow in the generated structure(s). For example, an evolutionary search may set this to 10 atoms to limit the compositions &amp; stoichiometries that are explored.</p> yamltomlpython <pre><code>max_atoms: 10\n</code></pre> <pre><code>max_atoms = 10\n</code></pre> <pre><code>max_atoms = 10\n</code></pre>"},{"location":"parameters/#max_path_length","title":"max_path_length","text":"<p>For diffusion workflows, this is the maximum length allowed for a single path.</p> yamltomlpython <pre><code>max_path_length: 3.5\n</code></pre> <pre><code>max_path_length = 3.5\n</code></pre> <pre><code>max_path_length = 3.5\n</code></pre>"},{"location":"parameters/#max_stoich_factor","title":"max_stoich_factor","text":"<p>This is the maximum stoichiometric ratio that will be analyzed. In a binary system evolutionary search, this will only look at non-reduced compositions up to the max_stoich_factor. For example, this means Ca2N and max factor of 4 would only look up to Ca8N4 and skip any compositions with more atoms (e.g. Ca10N5 is skipped)</p> yamltomlpython <pre><code>max_stoich_factor: 5\n</code></pre> <pre><code>max_stoich_factor = 5\n</code></pre> <pre><code>max_stoich_factor = 5\n</code></pre>"},{"location":"parameters/#max_supercell_atoms","title":"max_supercell_atoms","text":"<p>For workflows that involve generating a supercell, this will be the maximum number of sites to allow in the generated structure(s). For example, NEB workflows would set this value to something like 100 atoms to limit their supercell image sizes.</p> yamltomlpython <pre><code>max_supercell_atoms: 100\n</code></pre> <pre><code>max_supercell_atoms = 100\n</code></pre> <pre><code>max_supercell_atoms = 100\n</code></pre>"},{"location":"parameters/#max_structures","title":"max_structures","text":"<p>For workflows that generate new structures (and potentially run calculations on them), this will be the maximum number of structures allowed. The workflow will end at this number of structures regardless of whether the calculation/search is converged or not.</p> yamltomlpython <pre><code>max_structures: 100\n</code></pre> <pre><code>max_structures = 100\n</code></pre> <pre><code>max_structures = 100\n</code></pre>"},{"location":"parameters/#migrating_specie","title":"migrating_specie","text":"<p>This is the atomic species/element that will be moving in the analysis (typically NEB or MD diffusion calculations). Note, oxidation states (e.g. \"Ca2+\") can be used, but this requires your input structure to be oxidation-state decorated as well.</p> yamltomlpython <pre><code>migrating_specie: Li\n</code></pre> <pre><code>migrating_specie = \"Li\"\n</code></pre> <pre><code>migrating_specie = \"Li\"\n</code></pre>"},{"location":"parameters/#migration_hop","title":"migration_hop","text":"<p>(advanced users only) The atomic path that should be analyzed. Inputs are anything compatible with the <code>MigrationHop</code> class of the <code>simmate.toolkit.diffusion</code> module. This includes:</p> <ul> <li><code>MigrationHop</code> object</li> <li>a database entry in the <code>MigrationHop</code> table</li> </ul> <p>(TODO: if you'd like full examples, please ask our team to add them)</p>"},{"location":"parameters/#migration_images","title":"migration_images","text":"<p>The full set of images (including endpoint images) that should be analyzed. Inputs are anything compatible with the <code>MigrationImages</code> class of the <code>simmate.toolkit.diffusion</code> module, which is effectively a list of <code>structure</code> inputs. This includes:</p> <p><code>MigrationImages</code> object</p> <p>a list of <code>Structure</code> objects</p> <p>a list of filenames (cif or POSCAR)</p> yamltomlpython <pre><code>migration_images:\n    - image_01.cif\n    - image_02.cif\n    - image_03.cif\n    - image_04.cif\n    - image_05.cif\n</code></pre> <pre><code>migration_images = [\n    \"image_01.cif\",\n    \"image_02.cif\",\n    \"image_03.cif\",\n    \"image_04.cif\",\n    \"image_05.cif\",\n]\n</code></pre> <pre><code>migration_images = [\n    \"image_01.cif\",\n    \"image_02.cif\",\n    \"image_03.cif\",\n    \"image_04.cif\",\n    \"image_05.cif\",\n]\n</code></pre>"},{"location":"parameters/#min_atoms","title":"min_atoms","text":"<p>This is the opposite of <code>max_atoms</code> as this will be the minimum number of sites allowed in the generate structure(s). See <code>max_atoms</code> for details.</p>"},{"location":"parameters/#min_supercell_atoms","title":"min_supercell_atoms","text":"<p>This is the opposite of <code>max_supercell_atoms</code> as this will be the minimum number of sites allowed in the generated supercell structure.</p>"},{"location":"parameters/#min_supercell_vector_lengths","title":"min_supercell_vector_lengths","text":"<p>When generating a supercell, this is the minimum length for each lattice vector of the generated cell (in Angstroms). For workflows such as NEB, larger is better but more computationally expensive.</p> yamltomlpython <pre><code>min_supercell_vector_lengths: 7.5\n</code></pre> <pre><code>min_supercell_vector_lengths = 7.5\n</code></pre> <pre><code>min_supercell_vector_lengths = 7.5\n</code></pre>"},{"location":"parameters/#nfirst_generation","title":"nfirst_generation","text":"<p>For evolutionary searches, no mutations or \"child\" individuals will be scheduled until this number of individuals have been calculated. This ensures we have a good pool of candidates calculated before we start selecting parents and mutating them.</p> yamltomlpython <pre><code>nfirst_generation: 15\n</code></pre> <pre><code>nfirst_generation = 15\n</code></pre> <pre><code>nfirst_generation = 15\n</code></pre>"},{"location":"parameters/#nimages","title":"nimages","text":"<p>The number of images (or structures) to use in the analysis. This does NOT include the endpoint images (start/end structures). More is better, but computationally expensive. We recommend keeping this value odd in order to ensure there is an image at the midpoint.</p> yamltomlpython <pre><code>nimages: 5\n</code></pre> <pre><code>nimages = 5\n</code></pre> <pre><code>nimages = 5\n</code></pre> <p>Danger</p> <p>For apps such as VASP, your <code>command</code> parameter must use a number of cores that is divisible by <code>nimages</code>. For example, <code>nimages=3</code> and <code>command=\"mpirun -n 10 vasp_std &gt; vasp.out\"</code> will fail because 10 is not divisible by 3.</p>"},{"location":"parameters/#nsteadystate","title":"nsteadystate","text":"<p>This parameter sets the number of individual workflows to be scheduled at once, effectively setting the queue size of an evolutionary search. The number of workflows run in parallel is determined by the number of <code>Workers</code> started. However, the <code>nsteadystate</code> value sets the maximum number of parallel runs as the queue size will never exceed this value. This parameter is closely tied with <code>steadystate_sources</code>.</p> yamltomlpython <pre><code>nsteadystate: 50\n</code></pre> <pre><code>nsteadystate = 50\n</code></pre> <pre><code>nsteadystate = 50\n</code></pre>"},{"location":"parameters/#nsteps","title":"nsteps","text":"<p>This parameter sets the total number of steps for the calculation. For instance, in molecular dynamics workflows, the simulation will stop after this many steps.</p> yamltomlpython <pre><code>nsteps: 10000\n</code></pre> <pre><code>nsteps = 10000\n</code></pre> <pre><code>nsteps = 10000\n</code></pre>"},{"location":"parameters/#percolation_mode","title":"percolation_mode","text":"<p>This parameter sets the percolating type to detect. The default is \"&gt;1d\", which searches for percolating paths up to the <code>max_path_length</code>. Alternatively, this can be set to \"1d\" to stop unique pathway finding when 1D percolation is achieved.</p> yamltomlpython <pre><code>percolation_mode: 1d\n</code></pre> <pre><code>percolation_mode = \"1d\"\n</code></pre> <pre><code>percolation_mode = \"1d\"\n</code></pre>"},{"location":"parameters/#relax_bulk","title":"relax_bulk","text":"<p>This parameter determines whether the bulk structure (typically the input structure) should be relaxed before running the rest of the workflow.</p> yamltomlpython <pre><code>relax_bulk: false\n</code></pre> <pre><code>relax_bulk: false\n</code></pre> <pre><code>relax_bulk: false\n</code></pre>"},{"location":"parameters/#relax_endpoints","title":"relax_endpoints","text":"<p>This parameter determines whether the endpoint structures for an NEB diffusion pathway should be relaxed before running the rest of the workflow.</p> yamltomlpython <pre><code>relax_endpoints: false\n</code></pre> <pre><code>relax_endpoints: false\n</code></pre> <pre><code>relax_endpoints: false\n</code></pre>"},{"location":"parameters/#run_id","title":"run_id","text":"<p>This parameter is the id assigned to a specific workflow run/calculation. If not provided, this will be randomly generated. It is highly recommended to leave this at the default value. This id is based on unique-ids (UUID), so every id should be 100% unique and in a string format.</p> yamltomlpython <pre><code>run_id: my-unique-id-123\n</code></pre> <pre><code>run_id = \"my-unique-id-123\"\n</code></pre> <pre><code>run_id = \"my-unique-id-123\"\n</code></pre>"},{"location":"parameters/#search_id","title":"search_id","text":"<p>(advanced users only) This parameter is the evolutionary search that this individual is associated with. This allows us to determine which <code>Selector</code>, <code>Validator</code>, and <code>StopCondition</code> should be used when creating and evaluating the individual. When running a search, this is set automatically when submitting a new flow.</p>"},{"location":"parameters/#selector_kwargs","title":"selector_kwargs","text":"<p>(advanced users only) This parameter is a dictionary of extra conditions to use when initializing the selector class. <code>MySelector(**selector_kwargs)</code>. This is closely tied with the <code>selector_name</code> parameter.</p>"},{"location":"parameters/#selector_name","title":"selector_name","text":"<p>(experimental feature; advanced users only) This parameter is the base selector class that should be used. The class will be initialized using <code>MySelector(**selector_kwargs)</code>. The input should be given as a string.</p> <p>Warning</p> <p>Currently, we only support truncated selection, so this should be left at its default value.</p>"},{"location":"parameters/#separate_spin","title":"separate_spin","text":"<p>In BadELF workflows, determines whether the spin-up and spin-down ELF/charge-density should be treated separately. Setting to <code>false</code> more closely matches the original BadELF paper, but relies on the assumption that the system is closed and the spin-up/spin-down are identical.</p> yamltomlpython <pre><code>separate_spin: true\n</code></pre> <pre><code>separate_spin = true\n</code></pre> <pre><code>separate_spin = True\n</code></pre>"},{"location":"parameters/#shared_feature_algorithm","title":"shared_feature_algorithm","text":"<p>For BadELF workflows, this parameter determines how shared ELF features such as covalent/metallic bonds are seperated from nearby atoms. Options are \"zero-flux\" or \"voronoi\" corresponding to bader-like and plane-like seperations.</p> yamltomlpython <pre><code>covalent_bond_alg: zero-flux\n</code></pre> <pre><code>covalent_bond_alg = \"zero-flux\"\n</code></pre> <pre><code>covalent_bond_alg = \"zero-flux\"\n</code></pre>"},{"location":"parameters/#shared_feature_separation_method","title":"shared_feature_separation_method","text":"<p>For BadELF workflows, this parameter determines how the charge in shared ELF features such as covalent/metallic bonds is divided and assigned to nearby atoms. Options are \"pauling\", \"plane\", or \"equal\".</p> <p>Pauling: Divides charge based on the electronegativities of the neighboring atoms. The fraction of charge assigned is defined as Xi/(X0+X1+X2+...Xn) where Xi is the pauling electronegativity for each neighboring atom.</p> <p>Equal: Divides charge equally to each neighboring atom.</p> <p>Plane: Divides charge by placing a voronoi plane at the maximum of covalent bonds between atoms. May not work well for systems with metallic features not along atom bonds.</p> yamltomlpython <pre><code>covalent_bond_alg: pauling\n</code></pre> <pre><code>covalent_bond_alg = \"pauling\"\n</code></pre> <pre><code>covalent_bond_alg = \"pauling\"\n</code></pre>"},{"location":"parameters/#singleshot_sources","title":"singleshot_sources","text":"<p>(experimental feature; advanced users only) This parameter is a list of structure sources that run once and never again. This includes generating input structures from known structures (from third-party databases), prototypes, or substituting known structures.</p> <p>In the current version of simmate, these features are not enabled and this input should be ignored.</p>"},{"location":"parameters/#sleep_step","title":"sleep_step","text":"<p>This parameter is the amount of time in seconds that the workflow will shutdown before restarting the cycle when there is a cycle within a workflow (such as iteratively checking the number of subworkflows submitted and updating results). For evolutionary searches, setting this to a larger value will save on computation resources and database load, so we recommend increasing it where possible.</p> yamltomlpython <pre><code>run_id: 180\n</code></pre> <pre><code>run_id = 180\n</code></pre> <pre><code>sleep_step = 180  # 3 minutes\n</code></pre>"},{"location":"parameters/#source","title":"source","text":"<p>(experimental feature; advanced users only) This parameter indicates where the input data (and other parameters) came from. The source could be a number of things including a third party id, a structure from a different Simmate database table, a transformation of another structure, a creation method, or a custom submission by the user.</p> <p>By default, this is a dictionary to account for the many different scenarios. Here are some examples of values used in this column:</p> python <pre><code># from a thirdparty database or separate table\nsource = {\n    \"database_table\": \"MatprojStructure\",\n    \"database_id\": \"mp-123\",\n}\n\n# from a random structure creator\nsource = {\"creator\": \"PyXtalStructure\"}\n\n# from a templated structure creator (e.g. substituition or prototypes)\nsource = {\n    \"creator\": \"PrototypeStructure\",\n    \"database_table\": \"AFLOWPrototypes\",\n    \"id\": 123,\n}\n\n# from a transformation\nsource = {\n    \"transformation\": \"MirrorMutation\",\n    \"database_table\":\"MatprojStructure\",\n    \"parent_ids\": [\"mp-12\", \"mp-34\"],\n}\n</code></pre> <p>Typically, the <code>source</code> is set automatically, and users do not need to update it.</p>"},{"location":"parameters/#standardize_structure","title":"standardize_structure","text":"<p>This parameter determines whether to standardize the structure during our setup(). This means running symmetry analysis on the structure to reduce the symmetry and convert it to some standardized form. There are three different forms to choose from and thus 3 different values that <code>standardize_structure</code> can be set to:</p> <ul> <li><code>primitive</code>: for the standard primitive unitcell</li> <li><code>conventional</code>: for the standard conventional unitcell</li> <li><code>primitive-LLL</code>: for the standard primitive unitcell that is then LLL-reduced</li> <li><code>False</code>: this is the default and will disable this feature</li> </ul> <p>We recommend using <code>primitive-LLL</code> when the smallest possible and most cubic unitcell is desired.</p> <p>We recommend using <code>primitive</code> when calculating band structures and ensuring we have a standardized high-symmetry path. Note,Existing band-structure workflows use this automatically.</p> <p>To control the tolerances used to symmetrize the structure, you can use the symmetry_precision and angle_tolerance attributes.</p> <p>By default, no standardization is applied.</p> yamltomlpython <pre><code>standardize_structure: primitive-LLL\n</code></pre> <pre><code>standardize_structure = \"primitive-LLL\"\n</code></pre> <pre><code>standardize_structure = \"primitive-LLL\"\n</code></pre>"},{"location":"parameters/#steadystate_source_id","title":"steadystate_source_id","text":"<p>(advanced users only) This parameter is the structure source that this individual is associated with. This allows us to determine how the new individual should be created. When running a search, this is set automatically when submitting a new flow.</p>"},{"location":"parameters/#steadystate_sources","title":"steadystate_sources","text":"<p>(experimental feature; advanced users only) This parameter is a dictionary of sources that will be scheduled at a \"steady-state\", meaning there will always be a set number of individuals scheduled/running for this type of structure source. This should be defined as a dictionary where each is <code>{\"source_name\": percent}</code>. The percent determines the number of steady stage calculations that will be running for this at any given time. It will be a percent of the <code>nsteadystate</code> parameter, which sets the total number of individuals to be scheduled/running. For example, if <code>nsteadystate=40</code> and we add a source of <code>{\"RandomSymStructure\": 0.30, ...}</code>, this means 0.25*40=10 randomly-created individuals will be running/submitted at all times. The source can be from either the <code>toolkit.creator</code> or <code>toolkit.transformations</code> modules.</p> yamltomlpython <pre><code>singleshot_sources:\n    RandomSymStructure: 0.30\n    from_ase.Heredity: 0.30\n    from_ase.SoftMutation: 0.10\n    from_ase.MirrorMutation: 0.10\n    from_ase.LatticeStrain: 0.05\n    from_ase.RotationalMutation: 0.05\n    from_ase.AtomicPermutation: 0.05\n    from_ase.CoordinatePerturbation: 0.05\n</code></pre> <pre><code>[singleshot_sources]\n\"RandomSymStructure\": 0.30\n\"from_ase.Heredity\": 0.30\n\"from_ase.SoftMutation\": 0.10\n\"from_ase.MirrorMutation\": 0.10\n\"from_ase.LatticeStrain\": 0.05\n\"from_ase.RotationalMutation\": 0.05\n\"from_ase.AtomicPermutation\": 0.05\n\"from_ase.CoordinatePerturbation\": 0.05\n</code></pre> <pre><code>singleshot_sources = {\n    \"RandomSymStructure\": 0.30,\n    \"from_ase.Heredity\": 0.30,\n    \"from_ase.SoftMutation\": 0.10,\n    \"from_ase.MirrorMutation\": 0.10,\n    \"from_ase.LatticeStrain\": 0.05,\n    \"from_ase.RotationalMutation\": 0.05,\n    \"from_ase.AtomicPermutation\": 0.05,\n    \"from_ase.CoordinatePerturbation\": 0.05,\n}\n</code></pre> <p>Note: if your percent values do not sum to 1, they will be rescaled. When calculating <code>percent*nsteadystate</code>, the value will be rounded to the nearest integer.</p> <p>We are moving towards accepting kwargs or class objects as well, but this is not yet allowed. For example, anything other than <code>percent</code> would be treated as a kwarg:</p> toml <pre><code>[singleshot_sources.RandomSymStructure]\npercent: 0.30\nspacegroups_exclude: [1, 2, 3]\nsite_generation_method: \"MyCustomMethod\"\n</code></pre>"},{"location":"parameters/#stop_conditions","title":"stop_conditions","text":"<p>(experimental feature; advanced users only) This parameter provides a set of stop conditions that will be checked periodically to determine if a FixedComposition evolutionary search should be stopped. It should be defined as a dictionary where each key is the string name of a StopCondition and the value is any kwargs that are needed to instantiate the class.</p> yamltomlpython <pre><code>stop_conditions:\n    BasicStopConditions:\n        max_structures: 1000\n        min_structures_exact: 100\n        convergence_cutoff: 0.001\n        best_survival_cutoff: 100\n    ExpectedStructure:\n        structure: NaCl.cif\n</code></pre> <pre><code>[stop_conditions.BasicStopConditions]\nmax_structures = 1000\nmin_structures_exact = 100\nconvergence_cutoff = 0.001\nbest_survival_cutoff = 100\n[stop_conditions.ExpectedStructure]\nstructure: NaCl.cif\n</code></pre> <pre><code>stop_conditions = {\n    \"BasicStopConditions\": {\n    \"max_structures\": 1000,\n    \"min_structures_exact\": 100,\n    \"convergence_cutoff\": 0.001\n    \"best_survival_cutoff\": 100\n    },\n    \"ExpectedStructure\": {\n    \"structure\": \"NaCl.cif\"\n    },\n}\n</code></pre> <p>Currently, only the BasicStopConditions and ExpectedStructure stop conditions are supported. They each have the following subparameters</p> <p>BasicStopConditions The <code>BasicStopConditions</code> are those that are important to all searches. If this <code>StopCondition</code> is not provided, defaults will be constructed.</p>"},{"location":"parameters/#max_structures_1","title":"max_structures","text":"<p>The maximum number of structures generated. The search will end at this number of structures regardless of if the search has converged. If not provided, the workflow estimates a reasonable value based on the number of atoms.</p> <p>Warning</p> <p><code>min_structure_exact</code> takes priority over this setting, so it is possible  for your search to exceed your maximum number of structures. If you want  <code>max_structures</code> to have absolute control, you can set <code>min_structure_exact</code>  to 0.</p>"},{"location":"parameters/#min_structures_exact","title":"min_structures_exact","text":"<p>The minimum number of structures that must be calculated with exactly matching nsites as specified in fixed-composition. If not provided, the workflow estimates a reasonable value based on the number of atoms.</p>"},{"location":"parameters/#convergence_cutoff","title":"convergence_cutoff","text":"<p>The search will be considered converged when the best structure is not changing by this amount (in eV). In order to officially signal the end of the search, the best structure must survive within this convergence limit for a specific number of new individuals -- this is controlled by the best_survival_cutoff. The default of 1meV is typically sufficient and does not need to be changed. More often, users should update best_survival_cutoff instead.</p>"},{"location":"parameters/#best_survival_cutoff","title":"best_survival_cutoff","text":"<p>The search will stop when the best individual remains unbeaten for this number of new individuals.</p> <p>To account for similar structures (e.g., identical structures with minor energy differences), structures within the convergence_cutoff parameter (e.g., +1meV) are not considered when counting historical structures. This helps to prevent the search from continuing in cases where the search is likely already converged but making &lt;0.1meV improvements. If not provided, the workflow estimates a reasonable value based on the number of atoms.</p> <p>ExpectedStructure The <code>ExpectedStructure</code> stop condition will compare all structures generated in the search to a provided structure and immediately halt the search if there is a match.</p>"},{"location":"parameters/#expected_structure","title":"expected_structure","text":"<p>When a structure is found in the search that matches this structure, the search will be stopped. The allowed inputs follow the same scheme as in the Structure parameter.</p>"},{"location":"parameters/#structure","title":"structure","text":"<p>The crystal structure to be used for the analysis. The input can be anything compatible with the <code>Structure</code> toolkit class. Accepted inputs include:</p> <p>a filename (cif or poscar) (recommended)</p> yamltomlpython <pre><code>structure: NaCl.cif\n</code></pre> <pre><code>structure = NaCl.cif\n</code></pre> <pre><code>structure=\"NaCl.cif\"\n</code></pre> <p>a dictionary that points to a database entry. </p> yamltomlpython <pre><code># example 1\nstructure:\n    database_table: MatprojStructure\n    database_id: mp-123\n\n# example 2\nstructure:\n    database_table: StaticEnergy\n    database_id: 50\n\n# example 3\nstructure:\n    database_table: Relaxation\n    database_id: 50\n    structure_field: structure_final\n</code></pre> <pre><code># example 1\n[structure]\ndatabase_table: MatprojStructure\ndatabase_id: mp-123\n\n# example 2\n[structure]\ndatabase_table: StaticEnergy\ndatabase_id: 50\n\n# example 3\n[structure]\ndatabase_table: Relaxation\ndatabase_id: 50\nstructure_field: structure_final\n</code></pre> <pre><code># example 1\nstructure={\n    \"database_table\": \"MatprojStructure\",\n    \"database_id\": \"mp-123\",\n}\n\n# example 2\nstructure={\n    \"database_table\": \"StaticEnergy\",\n    \"database_id\": 50,\n}\n\n# example 3\nstructure={\n    \"database_table\": \"Relaxation\",\n    \"database_id\": 50,\n    \"structure_field\": \"structure_final\",\n}\n</code></pre> <p>Note</p> <p>instead of <code>database_id</code>, you can also use the <code>run_id</code> or <code>directory</code> to indicate which entry to load. Further, if the database table is linked to multiple structures (e.g. relaxations have a <code>structure_start</code> and <code>structure_final</code>), then you can also add the <code>structure_field</code> to specify which to choose. </p> <p>a <code>Structure</code> object (best for advanced logic)</p> python <pre><code>from simmate.toolkit import Structure\n\nstructure = Structure(\n    lattice=[\n        [2.846, 2.846, 0.000],\n        [2.846, 0.000, 2.846],\n        [0.000, 2.846, 2.846],\n    ],\n    species=[\"Na\", \"Cl\"],\n    coords=[\n        [0.5, 0.5, 0.5],\n        [0.0, 0.0, 0.0],\n    ],\n    coords_are_cartesian=False,\n)\n</code></pre> <p>a <code>Structure</code> database object</p> python <pre><code>structure = ExampleTable.objects.get(id=123)\n</code></pre> <p>json/dictionary serialization from pymatgen</p>"},{"location":"parameters/#subworkflow_kwargs","title":"subworkflow_kwargs","text":"<p>This parameter is a dictionary of parameters to pass to each subworkflow run. For example, the workflow will be ran as <code>subworkflow.run(**subworkflow_kwargs)</code>. Note, many workflows that use this argument will automatically pass information that is unique to each call (such as <code>structure</code>).</p> yamltomlpython <pre><code>subworkflow_kwargs:\n    command: mpirun -n 4 vasp_std &gt; vasp.out\n    compress_output: true\n</code></pre> <pre><code>[subworkflow_kwargs]\ncommand = \"mpirun -n 4 vasp_std &gt; vasp.out\"\ncompress_output = true\n</code></pre> <pre><code>subworkflow_kwargs=dict(\n    command=\"mpirun -n 4 vasp_std &gt; vasp.out\",\n    compress_output=True,\n)\n</code></pre>"},{"location":"parameters/#subworkflow_name","title":"subworkflow_name","text":"<p>This parameter is the name of workflow that used to evaluate structures generated. Any workflow that is registered and accessible via the <code>get_workflow</code> utility can be used instead. If you wish to submit extra arguments to each workflow run, you can use the <code>subworkflow_kwargs</code> parameter.</p> yamltomlpython <pre><code>subworkflow_name: relaxation.vasp.staged\n</code></pre> <pre><code>subworkflow_name = \"relaxation.vasp.staged\"\n</code></pre> <pre><code>subworkflow_name = \"relaxation.vasp.staged\"\n</code></pre>"},{"location":"parameters/#supercell_end","title":"supercell_end","text":"<p>This parameter is the endpoint image supercell to use. This is really just a <code>structure</code> parameter under a different name, so everything about the <code>structure</code> parameter also applies here.</p>"},{"location":"parameters/#supercell_start","title":"supercell_start","text":"<p>This parameter is the starting image supercell to use. This is really just a <code>structure</code> parameter under a different name, so everything about the <code>structure</code> parameter also applies here.</p>"},{"location":"parameters/#symmetry_precision","title":"symmetry_precision","text":"<p>If standardize_structure=True, then this is the cutoff value used to determine if the sites are symmetrically equivalent. (in Angstroms)</p> yamlpython <pre><code>symmetry_precision: 0.1\n</code></pre> <pre><code>symmetry_precision = 0.1\n</code></pre>"},{"location":"parameters/#tags","title":"tags","text":"<p>When submitting workflows via the <code>run_cloud</code> command, tags are 'labels' that help control which workers are allowed to pick up and run the submitted workflow. Workers should be started with matching tags in order for these scheduled flows to run.</p> <p>When no tags are set, the following default tags will be used for a Simmate workflow:</p> <ul> <li> <code>simmate</code> (this is the default worker tag as well)</li> <li> the workflow's type name</li> <li> the workflow's app name</li> <li> the full workflow name</li> </ul> <p>For example, the <code>static-energy.vasp.matproj</code> would have the following tags: <pre><code>- simmate\n- static-energy\n- vasp\n- static-energy.vasp.matproj\n</code></pre></p> <p>To override these default tags, use the following:</p> yamltomlpython <pre><code>tags:\n    - my-tag-01\n    - my-tag-02\n</code></pre> <pre><code>tags = [\"my-tag-01\", \"my-tag-02\"]\n</code></pre> <pre><code>tags = [\"my-tag-01\", \"my-tag-02\"]\n</code></pre> <p>Warning</p> <p>When you have a workflow that is submitting many smaller workflows (such as  <code>structure-prediction</code> workflows), make sure you set the tags in the <code>subworkflow_kwargs</code> settings: <pre><code>subworkflow_kwargs:\n    tags:\n        - my-tag-01\n        - my-tag-02\n</code></pre></p> <p>Bug</p> <p>Filtering tags does not always work as expected in SQLite3 because a worker with  <code>my-tag</code> will incorrectly grab jobs like <code>my-tag-01</code> and <code>my-tag-02</code>. This issue is known by both Django and SQLite3. Simmate addresses this issue by requiring all tags to be 7 characters long AND fully lowercase when using SQLite3.</p>"},{"location":"parameters/#temperature_end","title":"temperature_end","text":"<p>For molecular dynamics simulations, this is the temperature to end the simulation at (in Kelvin). This temperature will be reached through a linear transition from the <code>temperature_start</code> parameter.</p> yamlpython <pre><code>temperature_end: 1000\n</code></pre> <pre><code>temperature_end = 1000\n</code></pre>"},{"location":"parameters/#temperature_start","title":"temperature_start","text":"<p>For molecular dynamics simulations, this is the temperature to begin the simulation at (in Kelvin).</p> yamltomlpython <pre><code>temperature_start: 250\n</code></pre> <pre><code>temperature_start = 250\n</code></pre> <pre><code>temperature_start = 250\n</code></pre>"},{"location":"parameters/#threads","title":"threads","text":"<p>For BadELF algorithms, determines how many threads will be used during pybader calculations. If None this will be automatically set to 90% of available threads.</p> yamltomlpython <pre><code>threads: 8\n</code></pre> <pre><code>threads = 8\n</code></pre> <pre><code>threads = 8\n</code></pre>"},{"location":"parameters/#time_step","title":"time_step","text":"<p>For molecular dynamics simulations, this is time time between each ionic step (in femtoseconds).</p> yamltomlpython <pre><code>time_step: 1.5\n</code></pre> <pre><code>time_step = 1.5\n</code></pre> <pre><code>time_step = 1.5\n</code></pre>"},{"location":"parameters/#updated_settings","title":"updated_settings","text":"<p>(experimental feature) Unique to <code>customized.vasp.user-config</code>. This is a list of parameters to update the <code>workflow_base</code> with. This often involves updating the base class attributes.</p>"},{"location":"parameters/#vacancy_mode","title":"vacancy_mode","text":"<p>For NEB and diffusion workfows, this determines whether vacancy or interstitial diffusion is analyzed. Default of True corresponds to vacancy-based diffusion.</p> yamltomlpython <pre><code>vacancy_mode: false\n</code></pre> <pre><code>vacancy_mode = false\n</code></pre> <pre><code>vacancy_mode = False\n</code></pre>"},{"location":"parameters/#validator_kwargs","title":"validator_kwargs","text":"<p>(advanced users only) This parameter is a dictionary of extra conditions to use when initializing the validator class. <code>MyValidator(**validator_kwargs)</code>. This is closely tied with the <code>validator_name</code> parameter.</p>"},{"location":"parameters/#validator_name","title":"validator_name","text":"<p>(experimental feature; advanced users only) This parameter is the base validator class that should be used. The class will be initialized using <code>MyValidator(**validator_kwargs)</code>. The input should be given as a string.</p> <p>Warning</p> <p>Currently, we only support <code>CrystallNNFingerprint</code> validation, so this should be left at its default value.</p>"},{"location":"parameters/#workflow_base","title":"workflow_base","text":"<p>(experimental feature) Unique to <code>customized.vasp.user-config</code>. This is the base workflow to use when updating critical settings.</p>"},{"location":"parameters/#write_electride_files","title":"write_electride_files","text":"<p>This parameter is unique to BadELF workflows. If set to True and ELFCAR and CHGCAR will be written containing only the values where the volume belongs to an electride and zero elsewhere.</p> yamltomlpython <pre><code>write_electride_files: false\n</code></pre> <pre><code>write_electride_files = false\n</code></pre> <pre><code>write_electride_files = False\n</code></pre>"},{"location":"parameters/#write_ion_radii","title":"write_ion_radii","text":"<p>This parameter is unique to BadELF workflows. If set to True, the ionic radii of each atom determined from the ELF will be written to a summary file.</p> yamltomlpython <pre><code>write_ion_radii: true\n</code></pre> <pre><code>write_ion_radii = true\n</code></pre> <pre><code>write_ion_radii = True\n</code></pre>"},{"location":"parameters/#write_labeled_structure","title":"write_labeled_structure","text":"<p>This parameter is unique to BadELF workflows. If set to True, the structure labeled with non-atomic ELF features (e.g. bare electrons, covalent bonds, metal bonds) will be written to a summary file.</p> yamltomlpython <pre><code>write_labeled_structure: true\n</code></pre> <pre><code>write_labeled_structure = true\n</code></pre> <pre><code>write_labeled_structure = True\n</code></pre>"},{"location":"parameters/#write_summary_files","title":"write_summary_files","text":"<p>This parameter determines whether or not to write output files. For some workflows, writing output files can cause excessive load on the database and possibly make the calculation IO bound. In cases such as this, you can set this to <code>False</code>.</p> yamltomlpython <pre><code>write_summary_files: false\n</code></pre> <pre><code>write_summary_files = false\n</code></pre> <pre><code>write_summary_files = False\n</code></pre> <p>Tip</p> <p>Beginners can often ignore this setting. This is typically only relevant in a setup where you have many computational resources and have many evolutionary searches (&gt;10) running at the same time.</p>"},{"location":"_old_notes/benchmarks/","title":"Comparisons and Benchmarks","text":"<p>This page gives an overview of alternatives to Simmate and also benchmarks some of our core features. Because there are so many subcomponents, we therefore organize our comparisons by use-case below:</p> <ol> <li>Overview</li> <li>Toolkit</li> <li>Database</li> <li>Workflow Engine</li> <li>Workflow Library</li> <li>Apps</li> </ol> <p>There are always new programs being developed and new features being added to Simmate, so our comparisons and benchmarks may not be up to date. If you would like us to mention a software or benchmark a new feature, let us know!</p> <p></p>"},{"location":"_old_notes/benchmarks/#overview","title":"Overview","text":"<p>Simmate aims to be a full framework AND toolset, which means our overall package is largely the combination of many smaller modules and features. Meanwhile, most other teams/softwares have their framework and toolsets broken into smaller, independent packages. </p> <p>To illustrate this difference, a perfect example is the collection of softwares for the Materials Project. Their organization is powered by many smaller packages, each with a specific use-case. You can view all of these on their github organization page. Many of their packages have direct analogs to the parts of Simmate:</p> Component Materials Project Simmate Defining and submitting workflows fireworks prefect MatSci workflow library atomate our <code>workflows</code> module Tasks &amp; Error handling custodian our <code>engine</code> module IO to different programs pymatgen.io our <code>apps</code> module Database backend MongoDB any engine supported by django Database API emmet our <code>database.base_data_types</code> module Web API mapidoc built dynamically by our <code>website</code> module Utilities &amp; toolkit pymatgen our <code>toolkit</code> module (built w. <code>pymatgen</code>) Website components crystaltoolkit our <code>website.core_components</code> module Third-party Data mpcontribs tables within <code>apps.**.models</code> modules more comparisons can be made too! ..... .... <p>There are more comparisons that can be made between this organization and Simmate, but this table gets to the major analogies between the two.</p> <p>In addition to the Materials Project, there are many other organizations (the AFLOW and AiiDA ecosystems) that have analogous components to those in Simmate. A detailed comparison to each of these is beyond the scope of this page, but overall, we can say that the biggest differences are...</p> <ol> <li> <p>Simmate is an all-in-one package while others break-up their components</p> <ul> <li>This is much more beginner-friendly and helps non-coders understand advanced features without jumping between several github repos and api pages.</li> <li>When building new packages off of Simmate, we favor building features as custom apps that easily be incorporated to our source-code (as individual apps). This is very different from (and easier than) building a new package entirely -- like you'd do with other ecosystems.</li> </ul> </li> <li> <p>Simmate prefers the use of large-scale popular packages over custom implementations</p> <ul> <li>Whereas other ecosystems write workflow managers and task distribution from scratch, we uses popular packages like Prefect, Dask, and Django. This greatly facilitates the addition of new features while also enabling best-practices with the communities outside of materials science.</li> <li>The exception to this rule is with materials science software. There are several cases where we create a new implementation from scratch -- as we are materials chemists and can't help trying to improve upon these codes! An example of this includes our effort to make a new module for evolutionary structure prediction.</li> </ul> </li> <li> <p>Simmate is younger and smaller than other ecosystems</p> <ul> <li>The python ecosystem has grown substanially over time, and we can easily take advantage of new softwares and packages, whereas other ecosystems are often tied to outdated practices or packages.</li> <li>Other ecosystems have built up massive libraries and toolkits, where we are catching up on the diverse set of functionality (though we are catching up quickly!).</li> <li>Because we still have a small user-base, our team will be able to prioritize your work if you post a question or need hands-on helps.</li> <li>Our test suite is not as encompassing as other ecosystems, but we are slowly building up functionality over time.</li> </ul> </li> </ol> <p></p>"},{"location":"_old_notes/benchmarks/#toolkit","title":"Toolkit","text":"<p>The <code>simmate.toolkit</code> module is currently an extension of <code>pymatgen</code>. It some cases it can be also be viewed fork of <code>pymatgen</code>, but our added features/reorganization is limited for now.</p>"},{"location":"_old_notes/benchmarks/#toolkit-alternatives","title":"<code>toolkit</code> alternatives","text":"<ul> <li>pymatgen</li> <li>ase</li> <li>jarvis-tools</li> </ul>"},{"location":"_old_notes/benchmarks/#toolkitbase_data_types-alternatives","title":"<code>toolkit.base_data_types</code> alternatives","text":"<ul> <li>pymatgen.core</li> <li>ase</li> </ul>"},{"location":"_old_notes/benchmarks/#toolkitfeaturizers-alternatives","title":"<code>toolkit.featurizers</code> alternatives","text":"<ul> <li>matminer</li> </ul>"},{"location":"_old_notes/benchmarks/#toolkitstructure_creation-alternatives","title":"<code>toolkit.structure_creation</code> alternatives","text":"<ul> <li>pyxtal</li> <li>pymatgen.analysis.structure_prediction</li> </ul>"},{"location":"_old_notes/benchmarks/#toolkitstructure_predictionevolution-alternatives","title":"<code>toolkit.structure_prediction.evolution</code> alternatives","text":"<ul> <li>uspex</li> <li>xtalopt</li> <li>calypso</li> <li>ase.ga</li> <li>airss</li> <li>gasp</li> </ul>"},{"location":"_old_notes/benchmarks/#toolkitdiffusion-alternatives","title":"<code>toolkit.diffusion</code> alternatives","text":"<ul> <li>pymatgen.analysis.diffusion</li> </ul>"},{"location":"_old_notes/benchmarks/#database","title":"Database","text":"<p>The <code>simmate.database</code> module is an independent implementation that builds off of Django ORM and the schemas are largely inspired by emmet and qmpy.</p>"},{"location":"_old_notes/benchmarks/#databasebase_data_types-alternatives","title":"<code>database.base_data_types</code> alternatives","text":"<ul> <li>emmet</li> <li>qmpy</li> </ul>"},{"location":"_old_notes/benchmarks/#appsmodels-alternatives","title":"<code>apps.*.models</code> alternatives","text":"<ul> <li>mpcontribs</li> <li>matminer.data_retrieval</li> <li>pymatgen.ext</li> <li>OPTIMADE APIs</li> </ul>"},{"location":"_old_notes/benchmarks/#databaseworkflow_results-alternatives","title":"<code>database.workflow_results</code> alternatives","text":"<ul> <li>atomate</li> <li>qmpy</li> <li>matador</li> </ul>"},{"location":"_old_notes/benchmarks/#workflow-engine","title":"Workflow Engine","text":"<p>The <code>simmate.workflows</code> module builds off of Prefect where a lot of the core functionality is inspired by fireworks and custodian.</p>"},{"location":"_old_notes/benchmarks/#engines3task-alternatives","title":"<code>engine.s3task</code> alternatives","text":"<ul> <li>custodian</li> </ul>"},{"location":"_old_notes/benchmarks/#engineworkflow-alternatives","title":"<code>engine.workflow</code> alternatives","text":"<ul> <li>fireworks</li> <li>aiida-core</li> </ul>"},{"location":"_old_notes/benchmarks/#workflow-library","title":"Workflow Library","text":"<p>The <code>simmate.workflows</code> module is an independent implementation of materials science workflows where much of our inspiration comes from atomate.</p>"},{"location":"_old_notes/benchmarks/#workflows-alternatives","title":"<code>workflows</code> alternatives","text":"<ul> <li>atomate</li> <li>aiida-common-workflows</li> <li>abipy</li> </ul>"},{"location":"_old_notes/benchmarks/#apps","title":"Apps","text":"<p>The <code>simmate.apps</code> module is an independent implementation of materials science workflows where much of our inspiration comes from pymatgen.io and ase.calculators. In several cases, we use some of pymatgen/ase functions directly in our module -- serving as a placeholder until we refactor/fork the their implementation.</p>"},{"location":"_old_notes/benchmarks/#apps-alternatives","title":"<code>apps</code> alternatives","text":"<ul> <li>pymatgen.io</li> <li>ase.calculators</li> </ul>"},{"location":"_old_notes/benchmarks/#overview-of-softwares-and-utilities-used-by-our-lab","title":"Overview of Softwares and Utilities used by our lab","text":"<p>Table of external codes that we support like vasp, pymatgen, django... (see table below)</p> Component Package Other Packages (not used) Materials Science PyMatGen ASE Website Backend Framework Django Flask Website Frontend Framework None Angular, React, Vue.js Website CSS Bootstrap ... Templating Django-templates Jinja Database ORM Django-ORM SQLAlchemy Database API None RESTfulAPI (django-REST), GraphQL (Graphene) Database backend SQLite PostgreSQL, MongoDB Dataframe storage CSV JSON, YAML Dataframe utilities Pandas ... Workflow Engine Prefect FireWorks, Luigi, AirFlow Workflow Management Prefect-cloud Prefect-server, FireWorks Workflow Execution None (local) Dask, FireWorks Workflow Library None Atomate JIT Task Management None Prefect, Custodian Desktop App None Kivy, Django (test server), PyQt Continuous Integration GithubActions TravisCI, CircleCI Plotting None MatPlotLib, Plotly, Bokeh, Seaborn 3D Modeling Blender (bpy) VTK 3D App Verge3D Three.js Testing PyTest UnitTest Density Function Theory VASP ABINIT, CASTEP Datamining Engine SciKit-Learn TensorFlow, Keras Datamining Library None Matminer Reference Style None BibTex, RIS Reference Management SciWheel Mendeley, Zotero, EndNote SVG Editting Inkscape Adobe Illustrator Graphics Editting GIMP Adobe Photoshop Command Line Interface Click Argparse, Python-Fire, Typer Code Formatting Black PyLint"},{"location":"_old_notes/digital_ocean/","title":"Setting up DigitalOcean database and website servers","text":"<p> You can avoid this guide if you choose to collaborate with Simmate! Make sure you have read through our database tutorial before deciding to take on the work of managing your own database and server.</p> <p>In this guide, you will learn how to setup a cloud database and webserver for Simmate using DigitalOcean.</p> <ol> <li>Create an account</li> <li>Automatic setup</li> <li>Manual setup (stage 1): PostgreSQL Database<ul> <li>create the cloud database</li> <li>connect to the database</li> <li>make a separate the database for testing (on the same server)</li> <li>create a connection pool</li> <li>build-our-database-tables</li> </ul> </li> <li> <p>Manual setup (stage 2): Website Server</p> <ul> <li>set up our website server</li> <li>create our static file server (CDN)</li> <li>set up our website domain name (simmate.org)</li> </ul> </li> <li> <p>Dockerfile-based build (developers-only)</p> </li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#create-an-account","title":"Create an account","text":"<p>To start, make an account on DigitalOcean using this link (which uses our refferal). We recommend using your Github account to sign in. This referral link does two things:</p> <ol> <li>DigitialOcean gives you $100 credit for servers (for 60 days)</li> <li>DigitialOcean gives the Simmate team $10 credit, which will help fund our servers</li> </ol> <p>If you have any issues, please make sure that DigitalOcean is still actually offering this deal here. Simmate is not affiliated with DigitalOcean.</p> <p></p>"},{"location":"_old_notes/digital_ocean/#automatic-setup","title":"Automatic setup","text":"<p>The button below will launch a new DigitalOcean app (server+database) using a template from our team. Make sure you have already signed-in to your DigitalOcean account before opening the link:</p> <p> </p> <p> Note to developers, if you fork this repository and want this button to work for your new repo, you must update the link for this button. For more information, see here</p> <p>Steps to set up servers on DigitalOcean:</p> <ol> <li>Make sure you created a DigitalOcean account (you can use your Github account) and are signed in</li> <li>Select the \"Deploy to DigitalOcean\" button above. On this new page, you'll see \"Python Detected\".</li> <li>Under \"Environment Variables\", update <code>DJANGO_SECRET_KEY</code> to a random password using only numbers and letters. You can use this random-password site to generate your random key.</li> <li>Move on to the next page, and complete the information as you see fit! When selecting server size, you can go as small as you'd like -- even the basic plan for 500MB + 1CPU will suffice ($5/mo at the time of writing this guide). Note, the starter database is can be switched out later on.</li> <li>Once you launch your app, the first build can take 15-30 minutes. Once complete, you should be able to view your new Simmate website at the link shown.</li> <li>The website won't work properly right away. This is because we haven't built database tables. Go to the \"Console\" tab and initalize your database with... <pre><code>simmate database reset\n</code></pre></li> <li>Database connection details are found in the \"Settings\" tab -&gt; \"simmate-starter-database\" component -&gt; \"Connection details\". You can use the connect-to-database section section below to connect to this server on your local computer and start submitting calculations!</li> <li>As your group grows, you may want to switch to a larger database than the starter one. To do this, you'll have to setup a managed database on DigitalOcean. To do this in your App, select \"Actions\" -&gt; \"Create/Attach Database\".</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#manual-setup-stage-1-postgresql-database","title":"Manual setup (stage 1): PostgreSQL Database","text":"<p> This section is only required if you do not wish to use the automatic setup described in the section above it -- or if you need a customized setup.</p> <p>First, we need to set up our Cloud database, tell Simmate how to connect to it, and build our tables.</p>"},{"location":"_old_notes/digital_ocean/#create-the-cloud-database","title":"create the cloud database","text":"<ol> <li>On our DigitalOcean dashboard, click the green \"Create\" button in the top right and then select \"Database\". It should bring you to this page.</li> <li>For \"database engine\", select the newest version of PostgreSQL (currently v14)</li> <li>The remainder of the page's options can be left at their default values.</li> <li>Select Create a Database Cluster when you're ready.</li> <li>For the new homepage on your cluster, there is a \"Get Started\" button. We will go through this dialog in the next section.</li> </ol> <p>Note, this is the database cluster, which can host multiple databases on it (each with all their own tables).</p> <p></p>"},{"location":"_old_notes/digital_ocean/#connect-to-the-database","title":"connect to the database","text":"<p>Before we set up our database on this cluster, we are are first going to try connecting the default database on it (named <code>defaultdb</code>).</p> <ol> <li>On your new database's page, you'll see a \"Getting Started\" dialog -- select it!</li> <li>For \"Restrict inbound connections\", this is completely optional and beginneers should skip this for now. We skip this because if you'll be running calculations on some supercomputer/cluster, then you'll need to add ALL of the associated IP addresses in order for connections to work properly. That's a lot of IP addresses to grab and configure properly -- so we leave this to advanced users.</li> <li>\"Connection details\" is what we need to give to Simmate/Django. Let's copy this information. As an example, here is what the details look like on DigitalOcean: <pre><code>username = doadmin\npassword = asd87a9sd867fasd\nhost = db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\nport = 25060\ndatabase = defaultdb\nsslmode = require\n</code></pre></li> <li>We need to pass this information to Simmate (which connects using Django). To do this, add a file named <code>my_env-database.yaml</code> (using your conda env name) to your simmate config directory (<code>~/simmate</code>) with the following content -- be sure substute in your connection information and note that ENGINE tells Django we are using Postgres: <pre><code>default:\n  ENGINE: django.db.backends.postgresql_psycopg2\n  HOST: db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\n  NAME: defaultdb\n  USER: doadmin\n  PASSWORD: asd87a9sd867fasd\n  PORT: 25060\n  OPTIONS:\n    sslmode: require\n</code></pre></li> <li>Make sure you can connect to this database on your local computer by running the following in Spyder: <pre><code>from simmate.configuration.django.settings import DATABASES\n\nprint(DATABASES)  # this should give your connect info!\n</code></pre></li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#make-a-separate-the-database-for-testing-on-the-same-server","title":"make a separate the database for testing (on the same server)","text":"<p>Just like how we don't use the <code>(base)</code> environment in Anaconda, we don't want to use the default database <code>defaultdb</code> on our cluster. Here will make a new database -- one that we can delete if we'd  like to restart.</p> <ol> <li>On DigitalOcean with your Database Cluster page, select the \"Users&amp;Databases\" tab.</li> <li>Create a new database using the \"Add new database\" button and name this <code>simmate-database-00</code>. We name it this way because you may want to make new/separate databases and numbering is a quick way to keep track of these.</li> <li>In your connection settings (from the section above), switch the NAME from defaultdb to <code>simmate-database-00</code>. You will change this in your <code>my_env-database.yaml</code> file.</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#create-a-connection-pool","title":"create a connection pool","text":"<p>When we have a bunch of calculations running at once, we need to make sure our database can handle all of these connections. Therefore, we make a connection pool which allows for thousands of connections. This \"pool\" works like a waitlist where the database handles each connection request in order.</p> <ol> <li>Select the \"Connection Pools\" tab and then \"Create a Connection Pool\"</li> <li>Name your pool <code>simmate-database-00-pool</code> and select <code>simmate-database-00</code> for the database</li> <li>Select \"Transaction\" for our mode (the default) and set our pool size to 10 (or modify this value as you wish)</li> <li>Create the pool when you're ready!</li> <li>You'll have to update your <code>my_env-database.yaml</code> file to these connection settings. At this point your file will look similar to this (note, our NAME and PORT values have changed): <pre><code>default:\n  ENGINE: django.db.backends.postgresql_psycopg2\n  HOST: db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\n  NAME: simmate-database-00-pool  # THIS LINE WAS UPDATED\n  USER: doadmin\n  PASSWORD: asd87a9sd867fasd\n  PORT: 25061\n  OPTIONS:\n    sslmode: require\n</code></pre></li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#build-our-database-tables","title":"build our database tables","text":"<p>Now that we set up and connected to our database, we can now make our Simmate database tables and start filling them with data! We do this the same way we did without a cloud database:</p> <ol> <li>In your terminal, make sure you have you Simmate enviornment activated</li> <li>Run the following command:  <pre><code>simmate database reset\n</code></pre></li> <li>You're now ready to start using Simmate with your new database!</li> <li>If you want to share this database with others, you simply need to have them copy your config file: <code>my_env-database.yaml</code>. They won't need to run <code>simmate database reset</code> because you did it for them.</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#manual-setup-stage-2-setting-up-a-django-website-server","title":"Manual setup (stage 2): Setting up a Django Website Server","text":"<p>If you want to host your Simmate installation as website just for you team, you can use DigitalOcean to host a Django Website server.</p> <p>This section follows the tutorials listed here. If you are struggling with our guide or want additional explanation, you can refer to these sources: 1. Overview that links to other tutorials 2. Step-by-step guide along with how to configure settings.py 3. Example github repo to practice with</p>"},{"location":"_old_notes/digital_ocean/#uploading-our-project-to-github","title":"uploading our project to github","text":"<p>(TODO --&gt; maybe link to another tutorial)</p> <p></p>"},{"location":"_old_notes/digital_ocean/#set-up-our-website-server","title":"set up our website server","text":"<ol> <li>On our DigitalOcean dashboard, click the green \"Create\" button in the top right and then select \"Apps\". It should bring you to this page.</li> <li>Select Github (and give github access if this is your first time)</li> <li>For your \"Source\", we want to select our project. For me, this is \"jacksund/simmate\". Leave everything else at its default.</li> <li>When you go to the next page, you should see that Python was detected. We will now update some of these settings in steps 5-8.</li> <li> <p>Edit \"Enviornment Variables\" to include the following. Also note that we are connecting to our database pool and that your secret key should be randomly generated and encrypted!: <pre><code>DJANGO_ALLOWED_HOSTS=${APP_DOMAIN}\nDEBUG=False\nDJANGO_SECRET_KEY=randomly-generated-passord-12345\n</code></pre></p> <p>note to simmate devs: consider switching to setting all database variables directly</p> </li> <li> <p>Change our \"Build Command\" to... (<code>pip install .</code> is ran automatically) <pre><code>pip install gunicorn psycopg2; prefect backend cloud;\n</code></pre></p> </li> </ol> <ol> <li>Change our \"Run Command\" to... <pre><code>gunicorn --worker-tmp-dir /dev/shm simmate.website.core.wsgi\n</code></pre></li> <li>Use the button at the bottom of this page to connect to our PostgreSQL database set-up above</li> <li>We can stick with the defaults for the rest of the pages! Create your server when you're ready!</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#create-our-static-file-server-cdn","title":"create our static file server (CDN)","text":"<p> it looks like DigitalOcean is updating the way this is done, so [their guide] is no longer accurate. My guide below may also be outdated.</p> <p>Everything for our website should work except for the static files. This is because Django doesn't serve static files when DEBUG=False. They want us to serve these separately as a static site (via a CDN). This isn't a big deal because the extra server is free for us on DigitalOcean.</p> <ol> <li>On our current app, go to \"Settings\" and then select \"+Add Component\" button on the top right. We want to add a \"Static Site\"</li> <li>Select the same github repo as before and make sure python is detected</li> <li>On this page, change \"HTTP Request Routes\" to <code>/static</code> and  the \"Output Directory\" to <code>/src/simmate/website/static</code></li> <li>That's it! Start the server when you're ready!</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#set-up-our-website-domain-name-simmateorg","title":"set up our website domain name (simmate.org)","text":"<p>We use google domains as I found it had the easiest setup and cheapest prices. For connecting this to DigitalOcean, I followed these guides: 1, 2, 3. These can give extra details if the steps below aren't enough.</p> <ol> <li>Purchase your website (domain) name on https://domains.google.com/registrar/</li> <li>Select the domain you just purchased and now go to its \"DNS\" tab. For example, ours brings us to https://domains.google.com/registrar/simmate.org/DNS</li> <li>Switch to the \"Custom name servers\" tab and add the following three servers:<ul> <li>ns1.digitalocean.com</li> <li>ns2.digitalocean.com</li> <li>ns3.digitalocean.com</li> </ul> </li> <li>Save these and be sure to select \"Switch to these settings\" at the top to enable them</li> <li>Jump back to your DigitalOcean dashboard and go to the Networking tab</li> <li>The first page here is the Domain view where you should now add your new domain name</li> <li>Now switch back to our DigitalOcean App (from above) and go to settings</li> <li>Under \"Domains\", we want to edit and then add <code>simmate.org</code> (or your chosen name). Let DigitalOcean manages the DNS.</li> </ol> <p></p>"},{"location":"_old_notes/digital_ocean/#dockerfile-based-build","title":"Dockerfile-based build","text":"<p> this section holds notes for Simmate developers and will help implement future features. Users can ignore this section for now.</p> <p>This build fails at the moment, but I still include the <code>Dockerfile</code> and <code>deploy.template.Dockerfile.yaml</code> files future reference --  as I'd like to revisit Dockerfile-based builds. These would have the advantage of (1) installing everything using Anaconda and (2) installing extra programs such as Blender.</p> <p>Taha Fatima was trying help troubleshoot, but I dropped my attempt once I ran into \"memory exceeded\" errors during my build. Taha mentioned that this can be fixed using Github Actions, so the following links would be the  best place to give this another attempt:   - https://github.com/digitalocean/app_action   - https://github.com/tahafatimaDO/test-DOCR</p> <p>Docker docs on building images automatically using github actions: - https://docs.docker.com/docker-hub/builds/link-source/ - https://docs.docker.com/docker-hub/repos/</p> <p>Open-source projects might be able to get GithubActions+DockerHub for free: - https://www.docker.com/community/open-source/application/</p> <p>I could also use DigitalOcean to store images, but this is meant for private images, which we don't want: - https://cloud.digitalocean.com/registry</p>"},{"location":"apps/aflow/","title":"AFLOW","text":""},{"location":"apps/aflow/#about","title":"About","text":"<p>Quote</p> <p>Automatic FLOW (AFLOW) is \"a software framework for high-throughput calculation of crystal structure properties of alloys, intermetallics and inorganic compounds\" that is used to generate \"a globally available database of [&gt;3,500,000] material compounds with over [&gt;725,000,000] calculated properties, and growing\".</p> <ul> <li>AFLOW Website</li> <li>AFLOW Paper</li> <li>AFLOW Prototype Encyclopedia</li> </ul>"},{"location":"apps/aflow/#about-this-app","title":"About this App","text":"<p>Simmate's <code>aflow</code> app helps to download AFLOW data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.aflow</code>"},{"location":"apps/aflow/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>aflow</code> to the list of installed Simmate apps with: <pre><code>simmate config add aflow\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test aflow\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all AFLOW datasets: <pre><code>simmate database download aflow\n</code></pre></p> </li> </ol>"},{"location":"apps/aflow/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Prototypes --- --- <code>aflow__prototypes</code> <code>AflowPrototype</code> Structures --- --- <code>aflow__structures</code> <code>AflowStructure</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.aflow.models import AflowPrototype, AflowStructure\n\nprototype_data = AflowPrototype.objects.to_dataframe()\n\nstructures_sample_data = AflowStructure.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/bader_henkelman/","title":"Overview of Bader App","text":""},{"location":"apps/bader_henkelman/#about","title":"About","text":"<p>Bader Charge Analysis (\"Bader\" for short) is a technique for partitioning charge density to predict oxidation states. This module is specifically tailored for the Henkelman Group's code that performs this analysis. You can access their open-source code here.</p> <p>Meanwhile, Simmate's Bader app builds workflows and utilities on top of the Bader code from the Henkelman Lab. Typically, other workflows oversee the execution of the workflows registered in this app. For example, workflows in the <code>Warren Lab</code> app combine Bader, VASP, and rational settings. Hence, beginners are recommended to start with other apps.</p>"},{"location":"apps/bader_henkelman/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>bader</code> to the list of installed Simmate apps with: <pre><code>simmate config add bader\n</code></pre></p> </li> <li> <p>Make sure you have the Bader command installed using one of two options:</p> <ul> <li>(for beginners) Install Docker-Desktop. Then run the following command:       <pre><code>simmate config update \"bader.docker.enable=True\"\n</code></pre></li> <li>(for experts) Install Bader using offical guides and make sure <code>bader</code> is in the path</li> </ul> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test bader\n</code></pre></p> </li> </ol>"},{"location":"apps/bader_henkelman/#helpful-resources","title":"Helpful Resources","text":"<ul> <li>Bader Website (includes documentation and guide)</li> </ul>"},{"location":"apps/bcpc/","title":"BCPC","text":""},{"location":"apps/bcpc/#about","title":"About","text":"<p>The Compendium of Pesticide Common Names (BCPC):</p> <p>Quote</p> <p>This electronic compendium is intended to provide details of the status of all pesticide common names (not just those assigned by ISO), together with their systematic chemical names, molecular formulae, chemical structures and CAS Registry Numbers\u00ae. It is designed to function like a database, with several indexes that provide access to the data sheets.</p> <ul> <li>BCPC Website</li> <li>BCPC Index of Common Names</li> </ul>"},{"location":"apps/bcpc/#about-this-app","title":"About this App","text":"<p>Simmate's <code>bcpc</code> app helps to download BCPC data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.bcpc</code>"},{"location":"apps/bcpc/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>bcpc</code> to the list of installed Simmate apps with: <pre><code>simmate config add bcpc\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test bcpc\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all BCPC datasets: <pre><code>simmate database download bcpc\n</code></pre></p> </li> </ol>"},{"location":"apps/bcpc/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class ISO Names --- --- <code>bcpc__iso_pesticides__molecules</code> <code>BcpcIsoPesticide</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.bcpc.models import BcpcIsoPesticide\n\npesticides_data = BcpcIsoPesticide.objects.to_dataframe()\n</code></pre>"},{"location":"apps/biovia_cosmo/","title":"BIOVIA COSMO","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/cas_registry/","title":"CAS Registry\u00ae","text":"<p>Warning</p> <p>While the Simmate app is free, a license is required to use the CAS Registry\u00ae API &amp; access their data. If you are looking for a free alternative to CAS API, we allow using the PubChem API as the backend for this app, but it comes as the cost of being inaccurate for a small set of CAS Registry Numbers\u00ae (&lt;1%). Proceed with caution.</p>"},{"location":"apps/cas_registry/#about","title":"About","text":"<p>The collection of CAS Registry Numbers\u00ae:</p> <p>Quote</p> <p>A CAS Registry Number is a unique and unambiguous identifier for a specific substance that allows clear communication and, with the help of CAS scientists, links together all available data and research about that substance. Governmental agencies rely on CAS Registry Numbers for substance identification in regulatory applications because they are unique, easy validated, and internationally recognized.</p> <ul> <li>CAS Registry Website</li> <li>CAS Registry Web Search</li> <li>CAS Registry Licensing</li> </ul>"},{"location":"apps/cas_registry/#about-this-app","title":"About this App","text":"<p>Simmate's <code>cas_registry</code> app helps to download CAS Registry data &amp; load it into the Simmate database. The data is sourced using one of two options:</p> <ul> <li>option 1: from the PubChem API (the default)</li> <li>option 2: from the CAS Registry API (disabled by default, requires a license)</li> </ul> <p>For both options, data is loaded lazily. This means you must specifically request a CAS Number in order for the related compound data to be downloaded and brought into the Simmate database. We do this because the full CAS database is extremely large (&gt;200 million compounds), making it very expensive to download in full.</p> Module CLI Workflows Data <code>simmate.apps.cas_registry</code>"},{"location":"apps/cas_registry/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>cas_registry</code> to the list of installed Simmate apps with: <pre><code>simmate config add cas_registry\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test cas_registry\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all CAS datasets: <pre><code>simmate database download cas_registry\n</code></pre></p> </li> </ol>"},{"location":"apps/cas_registry/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class CAS Molecules --- --- <code>cas_registry__molecules</code> <code>CasRegistryMolecule</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.cas_registry.models import CasRegistryMolecule\n\ncas_sample_data = CasRegistryMolecule.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/chembl/","title":"ChEMBL","text":""},{"location":"apps/chembl/#about","title":"About","text":"<p>The ChEMBL Database:</p> <p>Quote</p> <p>ChEMBL is a manually curated database of bioactive molecules with drug-like properties. It brings together chemical, bioactivity and genomic data to aid the translation of genomic information into effective new drugs.</p> <ul> <li>ChEMBL Website</li> <li>ChEMBL Web Search</li> <li>ChEMBL Downloads</li> </ul>"},{"location":"apps/chembl/#about-this-app","title":"About this App","text":"<p>Simmate's <code>chembl</code> app helps to download The ChEMBL Database data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.chembl</code>"},{"location":"apps/chembl/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>chembl</code> to the list of installed Simmate apps with: <pre><code>simmate config add chembl\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test chembl\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all ChEMBL datasets: <pre><code>simmate database download chembl\n</code></pre></p> </li> </ol>"},{"location":"apps/chembl/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Molecules --- --- <code>chembl__molecules</code> <code>ChemblMolecule</code> Source Documents --- --- <code>chembl__documents</code> <code>ChemblDocument</code> Molecules --- --- <code>chembl__assay_results</code> <code>ChemblAssayResult</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.chembl.models import (\n    ChemblMolecule,\n    ChemblDocument,\n    ChemblAssayResult,\n)\n\nmol_sample_data = ChemblMolecule.objects.to_dataframe(limit=5_000)\ndoc_sample_data = ChemblDocument.objects.to_dataframe(limit=5_000)\nassay_sample_data = ChemblAssayResult.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/chemspace/","title":"ChemSpace","text":""},{"location":"apps/chemspace/#about","title":"About","text":"<p>Quote</p> <p>Encompassing REAL and Freedom Spaces, [ChemSpace] boasts over 50 billion accessible molecules. It serves as an ideal platform for efficient hit finding and exploration \u2013 from uncovering previously unknown starting points for your discovery projects to rapid hit expansion and optimization using cutting-edge technologies in Computational Chemistry, Bioinformatics, and Machine Learning.</p> <ul> <li>ChemSpace Website</li> <li>ChemSpace Web Search</li> <li>ChemSpace Downloads</li> </ul>"},{"location":"apps/chemspace/#about-this-app","title":"About this App","text":"<p>Simmate's <code>chemspace</code> app helps to download The ChEMBL Database data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.chemspace</code>"},{"location":"apps/chemspace/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>chemspace</code> to the list of installed Simmate apps with: <pre><code>simmate config add chemspace\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test chemspace\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all ChEMBL datasets: <pre><code>simmate database download chemspace\n</code></pre></p> </li> </ol>"},{"location":"apps/chemspace/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Freedom Molecules --- --- <code>chemspace__freedom_space__molecules</code> <code>ChemSpaceFreedomSpaceMolecule</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.chemspace.models import ChemSpaceFreedomSpaceMolecule\n\nmol_sample_data = ChemSpaceFreedomSpaceMolecule.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/clease/","title":"CLEASE","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/clease/#about","title":"About","text":"<p>Quote</p> <p>The Cluster Expansion in Atomic Simulation Environment (CLEASE) is a software package that simplifies the intricate setup and construction process of cluster expansion (CE). It provides a comprehensive set of tools for defining CE parameters, generating training structures, fitting effective cluster interaction (ECI) values, and running Monte Carlo simulations.</p> <ul> <li>GitLab Repository</li> <li>Official Documentation</li> <li>Published Paper</li> </ul>"},{"location":"apps/cod/","title":"COD","text":""},{"location":"apps/cod/#about","title":"About","text":"<p>The Crystallography Open Database (COD):</p> <p>Quote</p> <p>The Crystallography Open Database (COD) is as of the time of writing the largest open-access collection of mineral, metal organic, organometallic, and small organic crystal structures, excluding biomolecules that are stored separately in the Protein Data Bank (PBD).</p> <ul> <li>COD Website</li> <li>COD Paper</li> <li>COD Web Search</li> </ul>"},{"location":"apps/cod/#about-this-app","title":"About this App","text":"<p>Simmate's <code>cod</code> app helps to download COD data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.cod</code>"},{"location":"apps/cod/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>cod</code> to the list of installed Simmate apps with: <pre><code>simmate config add cod\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test cod\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all COD datasets: <pre><code>simmate database download cod\n</code></pre></p> </li> </ol>"},{"location":"apps/cod/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Structures --- --- <code>cod__structures</code> <code>CodStructure</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.cod.models import CodStructure\n\ncod_sample_data = CodStructure.objects.to_dataframe()\n</code></pre>"},{"location":"apps/deepmd/","title":"DeePMD","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/deepmd/#about","title":"About","text":"<ul> <li>GitHub Repository</li> <li>Official Documentation</li> <li>Research Paper</li> </ul>"},{"location":"apps/emolecules/","title":"eMolecules","text":"<p>Warning</p> <p>While the Simmate app is free, eMolecules has a catalog of free and paid datasets -- both of which require you to make an account on their website. Our app is configured to use the free datasets by default. However, you must download these datasets through your personal account as Simmate cannot automate the download for you.</p>"},{"location":"apps/emolecules/#about","title":"About","text":"<p>Quote</p> <p>Instant access to the molecules you need. The world\u2019s largest in-stock chemical space at your finger tips. Faster, more reliable delivery to hit your timelines. Services and capabilities to drive compound procurement and management efficiencies throughout the drug discovery research process. It all adds up to eMolecules, your partner for gaining advantage..</p> <ul> <li>eMolecules Website</li> <li>eMolecules Web Search</li> <li>eMolecules Downloads</li> </ul>"},{"location":"apps/emolecules/#about-this-app","title":"About this App","text":"<p>Simmate's <code>emolecules</code> app helps to download eMolecules data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.emolecules</code>"},{"location":"apps/emolecules/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>emolecules</code> to the list of installed Simmate apps with: <pre><code>simmate config add emolecules\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test emolecules\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all eMolecules datasets: <pre><code>simmate database download emolecules\n</code></pre></p> </li> </ol>"},{"location":"apps/emolecules/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Molecules --- --- <code>emolecules__molecules</code> <code>EmoleculesMolecule</code> Supplier Offers --- --- <code>emolecules__supplier_offers</code> <code>EmoleculesSupplierOffer</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.emolecules.models import EmoleculesMolecule, EmoleculesSupplierOffer\n\nmol_sample_data = EmoleculesMolecule.objects.to_dataframe(limit=5_000)\noffer_sample_data = EmoleculesSupplierOffer.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/enamine/","title":"Enamine","text":""},{"location":"apps/enamine/#about","title":"About","text":"<p>Quote</p> <p>Encompassing REAL and Freedom Spaces, [Enamine] boasts over 50 billion accessible molecules. It serves as an ideal platform for efficient hit finding and exploration \u2013 from uncovering previously unknown starting points for your discovery projects to rapid hit expansion and optimization using cutting-edge technologies in Computational Chemistry, Bioinformatics, and Machine Learning.</p> <ul> <li>Enamine Website</li> <li>Enamine Web Search</li> <li>Enamine Downloads</li> </ul>"},{"location":"apps/enamine/#about-this-app","title":"About this App","text":"<p>Simmate's <code>enamine</code> app helps to download Enamine data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.enamine</code>"},{"location":"apps/enamine/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>enamine</code> to the list of installed Simmate apps with: <pre><code>simmate config add enamine\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test enamine\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all ChEMBL datasets: <pre><code>simmate database download enamine\n</code></pre></p> </li> </ol>"},{"location":"apps/enamine/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class REAL Molecules --- --- <code>enamine__real__molecules</code> <code>EnamineRealMolecule</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.enamine.models import EnamineFreedomSpaceMolecule\n\nmol_sample_data = EnamineFreedomSpaceMolecule.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/eppo_gd/","title":"EPPO Global Database","text":""},{"location":"apps/eppo_gd/#about","title":"About","text":"<p>Quote</p> <p>EPPO Global Database is maintained by the Secretariat of the European and Mediterranean Plant Protection Organization (EPPO). The aim of the database is to provide all pest-specific information that has been produced or collected by EPPO. The database contents are constantly being updated by the EPPO Secretariat.</p> <ul> <li>EPPO GD Website</li> </ul>"},{"location":"apps/eppo_gd/#about-this-app","title":"About this App","text":"<p>Simmate's <code>eppo_gd</code> app helps to download EPPO Global database &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.eppo_gd</code>"},{"location":"apps/eppo_gd/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>eppo_gd</code> to the list of installed Simmate apps with: <pre><code>simmate config add eppo_gd\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test eppo_gd\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all EPPO GD datasets: <pre><code>simmate database download eppo_gd\n</code></pre></p> </li> </ol>"},{"location":"apps/eppo_gd/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class EPPO Codes --- --- <code>eppo_gd__eppo_codes</code> <code>EppoCode</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.eppo_gd.models import EppoCode\n\neppo_sample_data = EppoCode.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/evolution/","title":"Evolutionary Searches","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p> <p>Danger</p> <p> Ensure you are using a cloud database if your workers are operating on separate machines or an HPC cluster. </p> <p>The default database backend (sqlite) is not designed for parallel connections from different computers. Your calculations will be slower and more prone to errors with sqlite.</p> <p>If you encounter the error <code>database is locked</code>, it means you have exceeded the capabilities of sqlite.</p> <p>Danger</p> <p>The default relaxation workflow requires VASP to be installed. This will soon be replaced with QE (+docker support)</p>"},{"location":"apps/evolution/#quick-start","title":"Quick Start","text":""},{"location":"apps/evolution/#fixed-composition-search","title":"Fixed-Composition Search","text":"<p>1) Familiarize yourself with the input options and default settings of the <code>structure-prediction.toolkit.fixed-composition</code> workflow. <pre><code>simmate workflows explore\n</code></pre></p> <p>2) (Optional) If you wish to include prototype structures or known materials at the start of your search, ensure you have loaded the data into your cloud database.  This was discussed in a previous tutorial.</p> <p>3) Create your input <code>yaml</code> file (e.g. <code>my_search.yaml</code>). Refer to the full example for best practices.</p> Basic InputBest-Practice Input <pre><code>workflow_name: structure-prediction.toolkit.fixed-composition\ncomposition: Ca8N4F8\n</code></pre> <pre><code>workflow_name: structure-prediction.toolkit.fixed-composition\ncomposition: Ca8N4F8\n\nsubworkflow_kwargs:  # (1)\n    command: mpirun -n 8 vasp_std &gt; vasp.out  # (2)\n    compress_output: true  # (3)\n    # see 'simmate workflows explore' on `relaxation.vasp.staged`\n    # for other optional subworkflow_kwargs\n\nsleep_step: 300  # (4)\nnsteadystate: 100  # (5)\n\n# see 'simmate workflows explore' output for other optional inputs\n</code></pre> <ol> <li>The default input parameter <code>subworkflow: relaxation.vasp.staged</code> is used to analyze each structure. You can modify this workflow's behavior with the <code>subworkflow_kwargs</code> setting.</li> <li>This is the command each relaxation step will use.</li> <li>Since you probably won't be reviewing the output files of each calculation, and these results can consume a lot of disk space, this setting will convert completed calculations to <code>zip</code> files to save space.</li> <li>The status of individual structures and the writing of output files are checked in cycles. If your average relaxation takes 30 minutes, you don't need to check/update every 60 seconds (the default). Longer sleep steps help reduce database load.</li> <li>By default, <code>nsteadystate</code> is set to 40, meaning the search will maintain 40 total calculations in the queue at all times, regardless of the number of available workers. The number of workers (not <code>nsteadystate</code>) controls the number of parallel calculations. Only change this value if you want more than 40 calculations to run in parallel, which requires &gt;40 running workers. Therefore, you can increase this value if needed, but do NOT decrease <code>nsteadystate</code>.</li> </ol> <p>4) Submit the workflow settings file to start scheduling jobs. <pre><code>simmate workflows run my_search.yaml\n</code></pre></p> <p>5) Start workers by submitting the <code>start-worker</code> command to a cluster's queue (e.g., SLURM) or wherever you want jobs to run. Submit as many workers as the number of workflows you want to run in parallel:</p> Basic WorkerBest-Practice Worker <pre><code>simmate engine start-worker\n</code></pre> <pre><code># (1)\nsimmate engine start-worker --close-on-empty-queue --nitems-max 10\n</code></pre> <ol> <li><code>--close-on-empty-queue</code> shuts down the worker when the queue is empty, freeing up computational resources. <code>--nitems-max</code> limits the number of workflows each worker will run. Short-lived workers help maintain the health of a cluster and allow other SLURM jobs to cycle through the queue, preventing resource hogging.</li> </ol> <p>6) Monitor the output and log files for any issues. Important error information can also be accessed via the command line: <pre><code>simmate engine stats\nsimmate engine error-summary\n</code></pre></p> <p>7) Submit new workers or cancel stale workers as needed.</p>"},{"location":"apps/evolution/#chemical-system-search","title":"Chemical System Search","text":"<ol> <li> <p>Follow the steps from the <code>fixed-composition</code> search above. The only differences here are the input yaml and follow-up searches. Ensure you read and understand the best practices as well.</p> </li> <li> <p>Create your input yaml file: <pre><code>workflow_name: structure-prediction.toolkit.chemical-system\nchemical_system: Ca-N\n</code></pre></p> </li> <li> <p>Submit the search <pre><code>simmate workflows run my_search.yaml\n</code></pre></p> </li> <li> <p>Submit workers as needed <pre><code>simmate engine start-worker\n</code></pre></p> </li> </ol>"},{"location":"apps/jarvis/","title":"JARVIS","text":""},{"location":"apps/jarvis/#about","title":"About","text":"<p>Quote</p> <p>Encompassing REAL and Freedom Spaces, [JARVIS] boasts over 50 billion accessible molecules. It serves as an ideal platform for efficient hit finding and exploration \u2013 from uncovering previously unknown starting points for your discovery projects to rapid hit expansion and optimization using cutting-edge technologies in Computational Chemistry, Bioinformatics, and Machine Learning.</p> <ul> <li>JARVIS Website</li> <li>JARVIS Web Search</li> <li>JARVIS Downloads</li> </ul>"},{"location":"apps/jarvis/#about-this-app","title":"About this App","text":"<p>Simmate's <code>jarvis</code> app helps to download JARVIS data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.jarvis</code>"},{"location":"apps/jarvis/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>jarvis</code> to the list of installed Simmate apps with: <pre><code>simmate config add jarvis\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test jarvis\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all JARVIS datasets: <pre><code>simmate database download jarvis\n</code></pre></p> </li> </ol>"},{"location":"apps/jarvis/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Freedom Molecules --- --- <code>jarvis__structures</code> <code>JarvisStructure</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.jarvis.models import JarvisStructure\n\njarvis_sample_data = JarvisStructure.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/materials_project/","title":"The Materials Project","text":""},{"location":"apps/materials_project/#about","title":"About","text":"<p>The Materials Project:</p> <p>Quote</p> <p>The Materials Project is a multi-institution, multi-national effort to compute the properties of all inorganic materials and provide the data and associated analysis algorithms for every materials researcher free of charge. The ultimate goal of the initiative is to drastically reduce the time needed to invent new materials by focusing costly and time-consuming experiments on compounds that show the most promise computationally.</p> <ul> <li>Materials Project website</li> <li><code>pymatgen</code> website</li> <li><code>atomate</code> website</li> </ul>"},{"location":"apps/materials_project/#about-this-app","title":"About this App","text":"<p>Simmate's <code>materials_project</code> app...</p> <ul> <li>helps to download Materials Project data &amp; load it into the Simmate database</li> <li>provides many workflows &amp; error handlers from <code>pymatgen</code> and <code>atomate</code></li> </ul> <p>NOTE: our Simmate workflows are full reimplementations of Materials Project workflows</p> Module CLI Workflows Data <code>simmate.apps.materials_project</code>"},{"location":"apps/materials_project/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>materials_project</code> to the list of installed Simmate apps with: <pre><code>simmate config add materials_project\n</code></pre></p> </li> <li> <p>(optional) For Bader workflows, make sure you have the Bader command (from the Henkleman group) installed using one of two options:</p> <ul> <li>(for beginners) Install Docker-Desktop. Then run the following command:       <pre><code>simmate config update \"bader.docker.enable=True\"\n</code></pre></li> <li>(for experts) Install Bader using offical guides and make sure <code>bader</code> is in the path</li> </ul> </li> <li> <p>(optional) For VASP workflows, make sure you have the <code>vasp_std</code> command installed using one of two options:</p> <ul> <li> <p>(for beginners) Install Docker-Desktop. Then run the following commands:       <pre><code>simmate config update \"vasp.docker.enable=True\"\nsimmate config update \"vasp.docker.image=example.com:vasp/latest\"\n</code></pre></p> <p>Danger</p> <p>VASP is a commercial software, so we cannot provide Docker images for it. This is why you must provide a private image via <code>image=example.com:vasp/latest</code>.</p> </li> <li> <p>(for experts) Install VASP using offical guides and make sure <code>vasp_std</code> is in the path</p> </li> </ul> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test materials_project\n</code></pre></p> </li> <li> <p>Download all Materials Project datasets: <pre><code>simmate database download materials_project\n</code></pre></p> </li> </ol>"},{"location":"apps/materials_project/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Structures --- --- <code>materials_project__structures</code> <code>MatprojStructure</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.materials_project.models import MatprojStructure\n\nmp_sample_data = MatprojStructure.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/materials_project/#workflows","title":"Workflows","text":"<pre><code>diffusion.vasp.neb-all-paths-mit\ndiffusion.vasp.neb-from-endpoints-mit\ndiffusion.vasp.neb-from-images-mit\ndiffusion.vasp.neb-from-images-mvl-ci\ndiffusion.vasp.neb-single-path-mit\ndynamics.vasp.matproj\ndynamics.vasp.mit\ndynamics.vasp.mvl-npt\nelectronic-structure.vasp.matproj-full\nelectronic-structure.vasp.matproj-hse-full\npopulation-analysis.vasp-bader.bader-matproj\npopulation-analysis.vasp.elf-matproj\nrelaxation.vasp.matproj\nrelaxation.vasp.matproj-hse\nrelaxation.vasp.matproj-hsesol\nrelaxation.vasp.matproj-metal\nrelaxation.vasp.matproj-pbesol\nrelaxation.vasp.matproj-scan\nrelaxation.vasp.mit\nrelaxation.vasp.mvl-grainboundary\nrelaxation.vasp.mvl-neb-endpoint\nrelaxation.vasp.mvl-slab\nstatic-energy.vasp.matproj\nstatic-energy.vasp.matproj-hse\nstatic-energy.vasp.matproj-hsesol\nstatic-energy.vasp.matproj-pbesol\nstatic-energy.vasp.matproj-scan\nstatic-energy.vasp.mit\nstatic-energy.vasp.mvl-neb-endpoint\nstatic-energy.vasp.prebadelf-matproj\nstatic-energy.vasp.prebader-matproj\n</code></pre> <p>Tip</p> <p>Read through our workflow guide to learn how to run workflows</p> <p>Example</p> python <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow_name = \"static-energy.vasp.matproj\"\nworkflow = get_workflow(workflow_name)\n\nstatus = workflow.run(structure=\"my_example.cif\")  # replace with your own file\nresult = status.result()\n</code></pre>"},{"location":"apps/openeye_omega/","title":"OpenEye OMEGA","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/oqmd/","title":"OQMD","text":""},{"location":"apps/oqmd/#about","title":"About","text":"<p>Quote</p> <p>The OQMD is a database of DFT calculated thermodynamic and structural properties of [&gt;1,200,000] materials, created in Chris Wolverton's group at Northwestern University.</p> <ul> <li>OQMD Website</li> </ul>"},{"location":"apps/oqmd/#about-this-app","title":"About this App","text":"<p>Simmate's <code>oqmd</code> app helps to download OQMD data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.oqmd</code>"},{"location":"apps/oqmd/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>oqmd</code> to the list of installed Simmate apps with: <pre><code>simmate config add oqmd\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test oqmd\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all OQMD datasets: <pre><code>simmate database download oqmd\n</code></pre></p> </li> </ol>"},{"location":"apps/oqmd/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Freedom Molecules --- --- <code>oqmd__structures</code> <code>OqmdStructure</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.oqmd.models import OqmdStructure\n\noqmd_sample_data = OqmdStructure.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/overview/","title":"Overview","text":""},{"location":"apps/overview/#what-is-an-app","title":"What is an App?","text":"<p>Apps are installable Simmate add-ons. Each one adds support for a third-party software/dataset or helps with a specific analysis. Learn more in the <code>Apps</code> section within the <code>Full Guides</code>.</p> <p>Example</p> <p>VASP is a program capable of running a variety of density functional theory (DFT) calculations. However, since it's not written in Python, we require some \"helper\" code to execute VASP commands, create input files, and extract data from the outputs. This helper code is what makes up Simmate's <code>vasp</code> app.</p> <p>Example</p> <p>The <code>evolution</code> app includes workflows for running evolutionary structure prediction. It also utilizies datasets from other data-providing apps like <code>oqmd</code>, <code>jarvis</code>, and <code>aflow</code> into the evolutionary searches.</p>"},{"location":"apps/overview/#summary-table","title":"Summary Table","text":"App Type CLI Workflows Data AFLOW <code>crystal</code> BadELF <code>crystal</code> Bader (henkelman) <code>crystal</code> BCPC <code>molecule</code> CAS Registry <code>molecule</code> ChEMBL <code>molecule</code> ChemSpace <code>molecule</code> COD <code>crystal</code> eMolecules <code>molecule</code> Enamine <code>molecule</code> EPPO Global Database <code>other</code> Evolutionary Searches <code>crystal</code> JARVIS <code>crystal</code> Materials Project <code>crystal</code> OQMD <code>crystal</code> PDB <code>molecule</code> PPDB <code>molecule</code> Quantum Espresso <code>crystal</code> RDKit <code>molecule</code> VASP <code>crystal</code> Warren Lab <code>crystal</code>"},{"location":"apps/pdb/","title":"The Protein Data Bank","text":""},{"location":"apps/pdb/#about","title":"About","text":"<p>Quote</p> <p>Since 1971, the Protein Data Bank archive (PDB) has served as the single repository of information about the 3D structures of proteins, nucleic acids, and complex assemblies.</p> <ul> <li>PDB Website</li> <li>PDB Ligand Downloads</li> <li>PDB Archives</li> </ul>"},{"location":"apps/pdb/#about-this-app","title":"About this App","text":"<p>Simmate's <code>pdb</code> app helps to download PDB data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.pdb</code>"},{"location":"apps/pdb/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>pdb</code> to the list of installed Simmate apps with: <pre><code>simmate config add pdb\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test pdb\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all PDB datasets: <pre><code>simmate database download pdb\n</code></pre></p> </li> </ol>"},{"location":"apps/pdb/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Ligand Molecules --- --- <code>pdb__ligands</code> <code>PdbLigand</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.pdb.models import PdbLigand\n\nmol_sample_data = PdbLigand.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/ppdb/","title":"The Pesticide Properties DataBase","text":"<p>Warning</p> <p>While the Simmate app is free, a license is required to download PPDB data. For this reason, Simmate does NOT redistribute any of their data -- instead, you must purchase a license and their raw data from PPDB directly. Also note that Simmate is NOT associated with the PPDB. Proceed with caution.</p>"},{"location":"apps/ppdb/#about","title":"About","text":"<p>Quote</p> <p>The PPDB is a comprehensive relational database of pesticide chemical identity, physicochemical, human health and ecotoxicological data. It also contains data for other related substances such as adjuvants, biostimulants and wood preservatives. It has been developed by the Agriculture &amp; Environment Research Unit (AERU) at the University of Hertfordshire for a variety of end users to support risk assessments and risk management.</p> <ul> <li>PPDB Website</li> <li>PPDB Full Index</li> <li>PPDB Purchasing &amp; Licensing</li> </ul>"},{"location":"apps/ppdb/#about-this-app","title":"About this App","text":"<p>Simmate's <code>ppdb</code> app helps to download PPDB data &amp; load it into the Simmate database.</p> Module CLI Workflows Data <code>simmate.apps.ppdb</code>"},{"location":"apps/ppdb/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>ppdb</code> to the list of installed Simmate apps with: <pre><code>simmate config add ppdb\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test ppdb\n</code></pre></p> </li> <li> <p>Add new tables to your database: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Download all PDB datasets: <pre><code>simmate database download ppdb\n</code></pre></p> </li> </ol>"},{"location":"apps/ppdb/#datasets","title":"Datasets","text":"Dataset Disk Space Rows (#) SQL Table Python Class Molecules --- --- <code>ppdb__molecules</code> <code>PpdbMolecule</code> <p>Tip</p> <p>Read through our database guide to learn how to work with these datasets</p> <p>Example</p> python <pre><code>from simmate.database import connect\nfrom simmate.apps.ppdb.models import PpdbMolecule\n\nmol_sample_data = PpdbMolecule.objects.to_dataframe(limit=5_000)\n</code></pre>"},{"location":"apps/quantum_espresso/","title":"Overview of Quantum Espresso App","text":""},{"location":"apps/quantum_espresso/#about","title":"About","text":"<p>Quantum ESPRESSO (QE) is widely used in computational chemistry and condensed matter physics to study the electronic structure of solids and molecules. It employs density functional theory (DFT) to calculate properties like electronic energy, charge density, and total energy. Researchers use it to gain insights into material properties at the quantum level.</p> <p>It can be considered an alternative to popular DFT softwares such as VASP, CASTEP, and ABINIT.</p> <p>Meanwhile, Simmate's QE app builds workflows and utilities on top of the QE code. Typically, other workflows oversee the execution of the workflows registered in this app.</p>"},{"location":"apps/quantum_espresso/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>quantum_espresso</code> to the list of installed Simmate apps with: <pre><code>simmate config add quantum_espresso\n</code></pre></p> </li> <li> <p>Make sure you have Quantum Espresso (QE) installed using one of two options:</p> <ul> <li>(for beginners) Install Docker-Desktop. Then run the following command:       <pre><code>simmate config update \"quantum_espresso.docker.enable=True\"\n</code></pre></li> <li>(for experts) Install QE using offical guides and make sure <code>pw.x</code> is in the path</li> </ul> </li> <li> <p>To run calculations with QE, we need psuedopotentials. Simmate helps load these from the popular SSSP library: <pre><code>simmate-qe setup sssp\n</code></pre></p> </li> <li> <p>Update your database to include custom tables from the app: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test quantum_espresso\n</code></pre></p> </li> </ol>"},{"location":"apps/quantum_espresso/#helpful-resources","title":"Helpful Resources","text":"<ul> <li>Quantum Espresso website (includes documentation and guides)</li> </ul>"},{"location":"apps/rdkit/","title":"RDkit","text":"<p>(documentation still being written)</p>"},{"location":"apps/schrodinger/","title":"Schrodinger","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/surflex/","title":"Surflex","text":"<p>Danger</p> <p>This app is currently in early testing. It is not advised to use it outside of the Warren Lab.</p>"},{"location":"apps/warren_lab/","title":"The Warren Lab Application","text":"<p>Note</p> <p>The current maintainer of this application is Sam Weaver</p>"},{"location":"apps/warren_lab/#about","title":"About","text":"<p>The Warren Lab App is a product of Scott Warren's Materials Discovery Lab at the University of North Carolina (Chapel Hill). Our lab focuses on electrides, fluoride-ion batteries, and 2D materials. </p> <p>The <code>Warren Lab</code> application incorporates workflows for our lab's preferred DFT settings and common analyses. Registering this app will introduce numerous new workflow presets that build on several other apps (VASP, Bader, BadELF, etc.).</p>"},{"location":"apps/warren_lab/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>warren_lab</code> (and it's dependencies) to the list of installed Simmate apps with: <pre><code>simmate config add warren_lab\n</code></pre></p> </li> <li> <p>For Bader &amp; BadELF workflows, make sure you have the Bader command (from the Henkleman group) installed using one of two options:</p> <ul> <li>(for beginners) Install Docker-Desktop. Then run the following command:       <pre><code>simmate config update \"bader.docker.enable=True\"\n</code></pre></li> <li>(for experts) Install Bader using offical guides and make sure <code>bader</code> is in the path</li> </ul> </li> <li> <p>For VASP workflows, make sure you have the <code>vasp_std</code> command installed using one of two options:</p> <ul> <li> <p>(for beginners) Install Docker-Desktop. Then run the following commands:       <pre><code>simmate config update \"vasp.docker.enable=True\"\nsimmate config update \"vasp.docker.image=example.com:vasp/latest\"\n</code></pre></p> <p>Danger</p> <p>VASP is a commercial software, so we cannot provide Docker images for it. This is why you must provide a private image via <code>image=example.com:vasp/latest</code>.</p> </li> <li> <p>(for experts) Install VASP using offical guides and make sure <code>vasp_std</code> is in the path</p> </li> </ul> </li> <li> <p>Update your database to include custom tables from the app: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test warren_lab\n</code></pre></p> </li> </ol>"},{"location":"apps/warren_lab/#included-workflows","title":"Included Workflows","text":""},{"location":"apps/warren_lab/#vasp-relaxation","title":"VASP (Relaxation)","text":"<pre><code>relaxation.vasp.warren-lab-hse\nrelaxation.vasp.warren-lab-hse-with-wavecar\nrelaxation.vasp.warren-lab-hsesol\nrelaxation.vasp.warren-lab-pbe\nrelaxation.vasp.warren-lab-pbe-metal\nrelaxation.vasp.warren-lab-pbe-with-wavecar\nrelaxation.vasp.warren-lab-pbesol\nrelaxation.vasp.warren-lab-scan\n</code></pre>"},{"location":"apps/warren_lab/#vasp-static-energy","title":"VASP (Static Energy)","text":"<pre><code>static-energy.vasp.warren-lab-hse\nstatic-energy.vasp.warren-lab-hsesol\nstatic-energy.vasp.warren-lab-pbe\nstatic-energy.vasp.warren-lab-pbe-metal\nstatic-energy.vasp.warren-lab-pbesol\nstatic-energy.vasp.warren-lab-prebadelf-hse\nstatic-energy.vasp.warren-lab-prebadelf-pbesol\nstatic-energy.vasp.warren-lab-scan\n</code></pre>"},{"location":"apps/warren_lab/#badelf","title":"BadELF","text":"<pre><code>bad-elf-analysis.badelf.badelf-pbesol\n</code></pre>"},{"location":"apps/warren_lab/#helpful-resources","title":"Helpful Resources","text":"<ul> <li>Scott Warren (UNC contact page)</li> <li>Lab Website</li> </ul>"},{"location":"apps/badelf/background/","title":"Calculating Charge with the ELF","text":""},{"location":"apps/badelf/background/#badelf-in-ionic-systems","title":"BadELF in Ionic Systems","text":"<p>Oxidation states play a major role in our understanding chemistry. Correspondingly, many methods of calculating charge from first-principles calculations have been developed. Perhaps the most common method comes from Bader's Quantum Theory of Atoms in Molecules.</p> <p>The method defines regions of space that belong to each atom in the system using the charge density. Barriers are defined by a zero-flux surface surrounding each atom. The zero-flux surface can be thought of as a 3D equivalent to the minimum of a line. Each atom's region can then be integrated over to calculate a charge, and compared to the neutral atom to get an oxidation state.</p> <p></p> <p>This method has been shown to be quite effective for most standard systems. For electride systems, however, it tends to fail. This is due to the relatively small charge on each bare electride electron (~1-2 e<sup>-</sup>) which results in a bias of the zero-flux surface towards the bare electron and a small or zero charge assignment:</p> <p></p> <p>To correct for this, it would be ideal to have a function similar to the charge density with high values at both the bare electron sites and nearby atoms. Luckily, this function exists in the form of the Electron Localization Function (ELF) developed by Becke and Edgecomb. The ELF is a measure of how much each wave function contributes to the kinetic energy density. It approaches 1 when only one wave function significantly contributes and 0 when many contribute. Importantly, it approaches 1 for highly localized electrons such as those found in covalent bonds or electride electrons. This allows one to define zero-flux surfaces using the ELF, then integrate resulting volume in the charge-density:</p> <p></p> <p>The result is a more useful depiction of charge on the bare electrons. Though the use of this method for electrides has only been recognized recently, the idea of calculating charge with zero-flux surfaces in the ELF dates back nearly to the functions conception.</p> <p>Despite the usefullnes of the zero-flux partitioning of the ELF there is one unfortunate downside over traditional Bader analysis. Partitioning in this way results in atom oxidation states very near integer values. For example, application to NaCl results in oxidation states of +0.97/-0.97. While this nearly match our natural expectation of +1/-1, Bader analysis gives values around +0.88/-0.88. This turns out to be much more useful, as it implies a degree of covalency in the system. Ideally, we could recover these expected values.</p> <p>Investigating the ELF around the zero-flux surface indicate a cause of this problem. Anionic atoms tend to have higher ELF values, resulting in all of the interstitial space being assigned to them, and oddly shaped convex volumes. To account for this, we can use voronoi-like planes to separate atoms at minima rather than the zero-flux surface:</p> <p></p> <p>The use of these planes is justified by the nearly spherical shape of the atoms with radii nearly matching those of shannon and prewitt. Ideally, this method could also be used for the bare electrons which likely also experience some bias in the interstital space. However, electride electrons are often extremely non-spherical, resulting in unreasonable plane placements and oxidation states. As a result, we have chosen to use a hybrid method of partitioning, with bare electrons separated using a zero-flux surface and atoms separated with planes.</p> <p>It is this hybrid method that makes BadELF a unique algorithm, providing reasonable charges for bare electrons while still providing a sense of covalency for the atoms in ionic materials. Ultimately, the choice of partitioning is still up to the user and we provide the ability to use a more traditional Bader-like analyses or a plane-only partitioning scheme (See the <code>algorithm</code> parameter.</p>"},{"location":"apps/badelf/background/#badelf-in-covalentmetallic-systems","title":"BadELF in Covalent/Metallic Systems","text":"<p>BadELF was originally created with only highly ionic electrides in mind. For electrides with considerable covalent or metallic character, there will be maxima throughout the system corresponding to covalent bonds and metallic features. Typically this results in maxima along the atomic bonds which conflict with the planes used to separate atoms at minima in ionic structures.</p> <p>There are several ways one might choose to handle these features. For example, one could choose to place planes at the maximum along bonds instead of the minima, retaining a hybrid separation similar to BadELF. A more traditional method is to treat these features as separate entities, similar to our treatment of bare electrons. The number of electrons found in the bonds can be related to bond order and gives a measure of bonding strength See Silvi and Savin. Given this, we recommend using the zero-flux surface algorithm and analyzing these features individually.</p>"},{"location":"apps/badelf/background/#badelf-with-spin-polarized-calculations","title":"BadELF with Spin Polarized calculations","text":"<p>The original BadELF algorithm assumed a closed system where the spin-up and spin-down ELF and charge density are identical. However, in many cases, such as the ferromagnetic electride Y<sub>2</sub>C, this assumption does not hold. In these cases, the ELF values of the bare electrons can vary considerably, and in extreme cases they may localize to different sites. To handle this, BadELF can be run separately to obtain the charges on atoms and bare electrons in each spin system and the charges can be combined in post. We typically recommend treating electride systems this way even if differences in the spin-up and spin-down systems are small.</p>"},{"location":"apps/badelf/background/#automatic-finding-electrides","title":"Automatic Finding Electrides","text":"<p>To use BadELF, the algorithm first needs to know that the system contains bare electrons and where these electrons are localized to. BadELF uses a \"dummy\" atom system in which the input structure is labeled with fake atoms representing the location of bare electrons. While these can be placed manually, this can be quite inconvenient and requires prior knowledge that the system is an electride.</p> <p>To assist with this issue, we developed an algorithm that automatically finds features in the ELF that correspond to atoms, covalent bonds, metals, and bare electride electrons. This allows for each of these features to be analyzed and treated separately. Because the scope of this method is not limited only to electrides, in principal it can also be used to assist in more traditional ELF topology analysis. For more theory behind this method and its use, see the ElfAnalyzerToolkit class</p>"},{"location":"apps/badelf/python/","title":"BadELF in Python: The BadElfToolkit Class","text":"<p>In addition to running BadELF as a Simmate workflow, the BadELF app also contains a suite of python modules for assisting in BadELF analysis. These can be accessed under the <code>simmate.apps.badelf.core</code> module. The most useful of these are the <code>BadElfToolkit</code>/<code>SpinBadElfToolkit</code> classes which allow users to run BadELF directly and the ElfAnalyzerToolkit class which helps analyze features of the ELF. Directly using these classes can provide additional control over the process that is unavailable when using Simmate's workflow system.</p> <p>The <code>BadElfToolkit</code> is the backbone for BadELF analyses, and is used under the hood when BadELF is called through .yaml files or the command line. It automates the process of finding electride sites, running Bader partitioning through pybader, calculating the location of partitioning planes for atoms, and integrating charge. After the BadELF analysis is complete, all of the information collected through the process can be accessed directly from the <code>BadElfToolkit</code> class. The <code>SpinBadElfToolkit</code> class is a wrapper for the <code>BadElfToolkit</code> class with the same basic usage. It creates two <code>BadElfToolkit</code> instances for the spin-up and spin-down ELF/charge density, and combines the results from the two. </p> <p>Note</p> <p>It is recommended to use the <code>SpinBadElfToolkit</code> by default, even if you are not providing results from a spin-polarized calculation. This is because the <code>SpinBadElfToolkit</code> class is designed to automatically detect if a calculation is not spin-polarized.</p> <p>Warning</p> <p>Running BadELF directly through the <code>BadElfToolkit</code>/<code>SpinBadElfToolkit</code> will not save results to your Simmate database.</p> <p>Using the <code>BadElfToolkit</code> class requires two basic steps:</p>"},{"location":"apps/badelf/python/#1-initializing-the-badelftoolkit-class","title":"(1) Initializing the BadElfToolkit class","text":"<p>The BadElfToolkit class can be initialized with the <code>from_files</code> method: <pre><code>from simmate.apps.badelf.core import BadElfToolkit\n\nbadelf = BadElfToolkit.from_files(\n    directory=\"/path/to/folder\", # This is the directory where the files are located as well as the directory where BadELF will run\n    partitioning_file=\"partitioning_filename\", # e.g. ELFCAR\n    charge_file=\"charge_filename\", # e.g. CHGCAR\n)\n</code></pre></p> <p>Alternatively, the BadElfToolkit can be initialized by providing the partitioning and charge density grids as Grid class objects. The Grid class inherits from pymatgen's VolumetricData class. </p> <pre><code>from simmate.apps.badelf.core import BadElfToolkit\nfrom simmate.apps.bader.toolkit import Grid\nfrom pathlib import Path\n\ndirectory = Path(\"path/to/folder\") # indicates the path to the folder where BadELF should run\npartitioning_grid = Grid.from_file(\"path/to/partitioning_file\")\ncharge_grid = Grid.from_file(\"path/to/partitioning_file\")\n\nbadelf = BadElfToolkit(\n    directory=directory,\n    partitioning_grid=partitioning_grid,\n    charge_grid=charge_grid        \n)\n</code></pre> <p>When initializing the BadELF class through either of these methods, the same optional parameters used in the .yaml file are also available. For a complete list of parameters and their usage, see the parameters page</p>"},{"location":"apps/badelf/python/#2-running-badelf-and-viewing-results","title":"(2) Running BadELF and viewing results","text":"<p>Once the BadElfToolkit class is initialized, the BadELF algorithm is run as follows:</p> <pre><code>badelf_results = badelf.results\n</code></pre> <p>This will return a dictionary object that includes useful information such as the oxidation states and volumes of each atom/electride electron. The keys of this dictionary match with the columns for the BadElf table in the Simmate database. </p> <p>In addition to the results dictionary, many other results calculated through the BadELF process are available through class properties/methods. These results may not be available when using Simmate's default workflow system. For example, regions assigned to a given atom or species can be written to a CHGCAR or ELFCAR type file for convenient visualization in programs such as VESTA or OVITO:</p> <pre><code># Write ELF or Charge Density for all atoms of a given type\nbadelf.write_species_file(\n    file_type=\"ELFCAR\", # can also be CHGCAR\n    species=\"E\", # E is used as a placeholder for electride electrons\n)\n\n# Write ELF or Charge Density for one atom\nbadelf.write_atom_file(\n    file_type=\"ELFCAR\", # can also be CHGCAR\n    atom_index=0, # The index of the atom to write the charge for\n)\n</code></pre> <p>Other results, such as a pandas dataframe representing the partitioning planes separating atoms, are stored as class properties (e.g. <code>badelf.partitioning</code>). We encourage users to explore these properties if they are interested in the underlying components of the algorithm.</p>"},{"location":"apps/badelf/quick_start/","title":"The BadELF App","text":"<p>Note</p> <p>The current maintainer of this application is Sam Weaver</p> <p>The BadELF algorithm and application are based on the following research:</p> <ul> <li>\"Counting Electrons in Electrides\" (JACS 2023)</li> <li>\"Assessing Dimensionality in Electrides\" (JPCC 2025)</li> </ul>"},{"location":"apps/badelf/quick_start/#about","title":"About","text":"<p>BadELF is a method that combines Bader Charge Analysis and the Electron Localization Function (ELF) to predict oxidation states and perform population analysis of electrides. It uses Bader segmentation of the ELF to calculate the charge on electride electrons and Voronoi segmentation of the ELF to calculate charge on atoms. Since the original BadELF paper was published, additional functionality has been added to handle systems with covalent/metallic features and for handling the up/down spin ELF and charge density separately.</p> <p>An additional tool, the ElfAnalyzerToolkit has also been developed to assist in analyzing features in the ELF. This tool is designed for in-depth ELF topological analysis, and can also perform a simple charge analysis using traditional zero-flux surfaces.</p> <p>Note</p> <p>BadELF currently only works with VASP, but we are interested in expanding its use to other ab initio software. If you are interested in this, let us know, as that will help to make this a higher priority.</p>"},{"location":"apps/badelf/quick_start/#installation","title":"Installation","text":"<p>Follow the instructions for installing simmate. Then BadELF can be set up with the following instructions.</p> <ol> <li> <p>This app uses <code>pybader</code> and <code>networkx</code> under the hood. Install this with: <pre><code>conda install -n my_env -c conda-forge pybader networkx\n</code></pre></p> </li> <li> <p>Add <code>badelf</code> (and it's dependencies) to the list of installed Simmate apps with: <pre><code>simmate config add badelf\n</code></pre></p> </li> <li> <p>Update your database to include custom tables from the <code>badelf</code> app: <pre><code>simmate database update\n</code></pre></p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test badelf\n</code></pre></p> </li> </ol>"},{"location":"apps/badelf/quick_start/#basic-use","title":"Basic Use","text":"<p>BadELF requires outputs from VASP calculations (e.g. the CHGCAR, ELFCAR, etc.). You can either (1) generate these on your own or (2) run a simmate workflow that does it for you. </p>"},{"location":"apps/badelf/quick_start/#1-from-vasp-outputs","title":"(1) from VASP outputs","text":"<p>The BadELF algorithm can be run in a folder with VASP results. Please ensure your VASP settings generate a CHGCAR and ELFCAR with matching grid sizes. </p> <p>Create a yaml file: <pre><code># inside input.yaml\nworkflow_name: bad-elf.badelf.badelf\ndirectory: /path/to/folder\n\n# all parameters below are optional\nfind_electrides: true # Whether or not to use ElfAnalyzerToolkit to automatically find electrides\nlabeled_structure_up: null # If find_electrides is false, a labeled structure with dummy atoms (see ElfAnalyzerToolkit docs)\nlabeled_structure_down: null # Same as above, but for spin down system\nelf_analyzer_kwargs: # Settings for the ElfAnalyzerToolkit. See ElfAnalyzerToolkit docs for more info\n    resolution: 0.01\n    include_lone_pairs: false\n    include_shared_features: true\n    metal_depth_cutoff: 0.1\n    min_covalent_angle: 135\n    min_covalent_bond_ratio: 0.35\n    shell_depth: 0.05\n    electride_elf_min: 0.5\n    electride_depth_min: 0.2\n    electride_charge_min: 0.5\n    electride_volume_min: 10\n    electride_radius_min: 0.3\n    radius_refine_method: linear\n    write_results: true\nalgorithm: badelf # The algorithm for separating atoms and electride sites\nseparate_spin: true # Whether to treat spin-up and spin-down systems separately\nshared_feature_algorithm: zero-flux # The algorithm for separating covalent/metallic features\nshared_feature_separation_method: pauling # The method used to assigne covalent/metallic charge to atoms\nignore_low_pseudopotentials: false # Forces algorithm to ignore errors related to PPs with few electrons\ndownscale_resolution: 1200 # The resolution in voxels/A^3 to downscale grids to in ElfAnalysisToolkit\nwrite_electride_files: false # Writes the bare electron volume ELF and charge\nwrite_ion_radii: true # Writes the ionic radius calculated from the ELF for each atom\nwrite_labeled_structure: true # Writes a cif file with dummy atoms for each non-atomic ELF feature\n</code></pre></p> <p>And run the workflow: <pre><code>simmate workflows run input.yaml\n</code></pre></p> <p>Alternatively, the BadELF workflow can be run from the command line without a yaml file: <pre><code>simmate workflows run-quick bad-elf.badelf.badelf --directory /path/to/folder\n</code></pre></p> <p>If you plan to run many BadELF calculations or need to manipulate the results in post, it may be more convenient to run the workflow using python. See the full guides for more details. For a complete list of parameters and their usage, see our parameters page</p>"},{"location":"apps/badelf/quick_start/#2-from-structure","title":"(2) from structure","text":"<p>If you would prefer to have Simmate handle the VASP calculation, workflows are available that will first run the required DFT and then BadELF. </p> <p>These workflows are stored in the <code>Warren Lab</code> app, which contains our lab's preferred VASP settings. Refer to the <code>Warren Lab</code> app for more details and to view the available workflows.</p>"},{"location":"apps/badelf/quick_start/#viewing-results","title":"Viewing Results","text":"<p>Running BadELF as described above uses Simmate's Workflow system. The results of these workflows can be viewed in a couple of ways.</p>"},{"location":"apps/badelf/quick_start/#1-the-database","title":"(1) The Database","text":"<p>When setting up simmate, you created a local or cloud database. Results from any workflow run through simmate will be stored here, allowing for the automation of high-throughput calculations. Basic usage of the database can be found in our getting started docs. The BadELF results table can be accessed through python as a pandas dataframe:</p> <pre><code>from simmate.database import connect\nfrom simmate.apps.badelf.models import BadElf\n\nbadelf_results = BadElf.objects.all()\nbadelf_df = badelf_results.to_dataframe()\n</code></pre> <p>Explanations for each of the columns in the results can be viewed by calling</p> <p><pre><code>BadElf.get_column_docs()\n</code></pre> which will return a dict object with column names as keys and doc information as values.</p>"},{"location":"apps/badelf/quick_start/#2-local-files","title":"(2) Local Files","text":"<p>If you are only interested in a small number of BadELF calculations, it may be more convenient to use the results written to local files. These can be found in the <code>badelf_summary.csv</code> file or the <code>simmate_summary.yaml</code> files. Additionally, a cif file will be written containing the labeled structure with \"dummy\" atoms representing electride electrons and other non-atomic features (See ElfAnalyzerToolkit page for more info).</p>"},{"location":"apps/badelf/quick_start/#covalent-and-metallic-systems","title":"Covalent and Metallic Systems","text":"<p>Covalent and metallic features in the ELF conflict with the original BadELF algorithm (see Background). The current version of BadELF offers several ways to handle these features:</p>"},{"location":"apps/badelf/quick_start/#1-split-them-with-planes","title":"(1) Split Them with Planes","text":"<p>Similar to placing planes at minima in the ELF in ionic systems, one can place planes at maxima in covalent/metallic systems. This results in the features being divided and their charge assigned to nearby atoms. To handle covalent/metallic bonds this way use the follow <code>shared_feature_separation_method</code>:</p> <pre><code>shared_feature_separation_method: plane\n</code></pre> <p>Warning</p> <p>Metallic features are not always along bonds. If this is the case, this method may not split them effectively. Additionally, no information will be returned about each shared feature.</p>"},{"location":"apps/badelf/quick_start/#2-treat-them-separately","title":"(2) Treat them Separately","text":"<p>Alternatively, one can treat covalent and metallic bonds as their own entities, similar to the treatment of bare electrons in electrides. In these cases, one needs to decide how to separate these features from the nearby atoms. The options available are with a zero-flux surface or a voronoi like plane and can be set with the <code>shared_feature_algorithm</code> parameter. Additionally, one must decide how to assign the charge from these 'shared features' to the nearby atoms. We currently offer two methods for doing this: splitting them equally, and splitting by pauling electronegativity. Splitting equally divides the features equally to each neighboring atom. Splitting by pauling EN gives more charge to more electronegative atoms.</p> equal splitpauling electronegativity <pre><code>shared_feature_algorithm: zero-flux # or voronoi\nshared_feature_separation_method: equal\n</code></pre> <pre><code>shared_feature_algorithm: zero-flux # or voronoi\nshared_feature_separation_method: pauling\n</code></pre> <p>Note</p> <p>In systems where atoms are always surrounded by covalent/metallic bonds, there will be very little difference in results between using planes ore zero-flux surfaces to separate atoms from one another. However, the zero-flux surface separation is much faster. If you are confident your system is heavily metallic or covalent, we suggest setting <code>algorithm: zero-flux</code>. In systems where this is not the case, this will just result in atom oxidation states tending more towards integer values.</p>"},{"location":"apps/badelf/quick_start/#accounting-for-spin","title":"Accounting for Spin","text":"<p>Electrides often have differing ELF and charge density for the spin-up and spin-down systems from spin-polarized calculations. Therefore, BadELF by default treats the spin-up and spin-down systems separately and combines the results where possible in post. This differs from the original algorithm which assumed a closed system where the spin-up and spin-down systems match. If a closed-system treatment is preferred set:</p> <pre><code>separate_spin: false\n</code></pre>"},{"location":"apps/badelf/finder/background/","title":"Theoretical Background","text":""},{"location":"apps/badelf/finder/background/#introduction","title":"Introduction","text":"<p>Since its conception in 1990 by Becke and Edgecomb, the Electron Localization Function (ELF) has been used by researchers as a tool for analyzing the bonding nature of molecules and solids. This is in large part due to the fact that the ELF tends to conveniently display many of the features familiar to chemists such as atomic orbital shells, covalent bonds, metallic interactions, and lone-pairs. </p> <p></p> <p>Integration of charge in the ELF regions associated with these features gives charges close to the expected values. For example, the regions associated with atomic shells contain electron counts that closely match  what is expected from the periodic table. The use of the ELF to analyze useful chemical features is made even more convenient by the fact that the ELF is fairly consistent with respect to the level of theory used to calculate it (see Savin et. al.).</p> <p>The ability of the ELF to consicely represent complex chemical features led researchers to develop methods for categorizing regions of the ELF, largely using ideas similar to those put forth in Bader's Quantum Theory of Atoms in Molecules. These methods have been discussed extensively by many researchers, but we will summarize them here.</p>"},{"location":"apps/badelf/finder/background/#basins-attractors-and-bifurcation-plots","title":"Basins, Attractors, and Bifurcation Plots","text":"<p>Note</p> <p>This discussion, and our method for assigning ELF features, is largely based on this review by Carlo Gatti: Chemical bonding in crystals: new directions. We highly recommend exploring this work if ELF topology analysis is of interest to you.</p> <p>Similar to Bader analysis, the ELF of a system can be divided into regions separated by zero-flux surfaces. Doing so results in distinct regions of space known as basins, with each basin having a single maximum called an attractor.</p> <p>Each basin represents a distinct chemical feature including atom core shells, lone-pairs, covalent bonds, metallic bonds, and bare electrons. The type of feature can be determined by characterizing features of the ELF around it. A particularly helpful method for assisting with this process is the construction of a type of tree diagram known as a bifurcation plot.</p> <p>In this method, the regions bounded by an isosurface of the ELF are viewed at different values, f. These regions are called f-localized domains, and correspond to regions where the ELF is greater than or equal to the value f. Any f-domain contains at least one attractor. Domains containing more than one attractor are called reducible while those containing only one are called irreducible. As f is increased, reducible domains split into smaller topologically distinct domains with fewer attractors. The critical f values at which these splits occur are called bifurcations. The final irreducible domains represent the exact same attractors as those described above. Each attractor/basin has characteristics such as a maximum ELF value, volume, position, and \"depth\". In this context, \"depth\" refers to the difference in a basin's ELF maximum from the value at which it bifurcates from it's parent reducible domain. Using these characteristics, we can categorize our various domains. Next, we will walk through the process our algorithm uses to determine the types of each attractor, and provide example of bifurcation plots for these attractors.</p>"},{"location":"apps/badelf/finder/background/#types-of-attractors","title":"Types of Attractors","text":"<p>Starting at an f value of 0, our entire system is one continuous domain. As we increase the f value, smaller domains begin to split off. Many of these child domains will completely surround exactly one atom. These can be further reduced into one of three main types of features. </p> <ol> <li> <p>Atomic Core/Shell. Core electrons fully surround the atom's nucleus and are nearly spherical. In traditional ELF topology analysis, any basin that is not part of the core of the atom is considered a valence basin, mimicking well known atomic models such as those of Lewis.</p> <p></p> <p></p> </li> <li> <p>Lone-Pairs. Lone-pairs split off from the core/shell domains at relatively low (~0.2) ELF values and have high ELF values. They don't fully surround the atom and are not along an atomic bond.</p> <p></p> <p></p> </li> <li> <p>Heterogenous Covalent Bonds. In some cases, covalent bonds form a reducible domain that fully surrounds the more electronegative atom, similar to atomic shells. However, at higher f values, this domain further splits into smaller domains that do not surround the atom. These attractors have a large depth and are distinct from lone-pairs in that they are always along an atomic bond.</p> <p></p> <p></p> </li> </ol> <p>Once the domains surrounding single atoms have split from the ELF, anything left is part of one large valence domain. Again, these features can be one of several types:</p> <ol> <li> <p>Homogenous Covalent Bonds. In covalent bonds involving the same atom, the bonds will sit exactly between the two atoms. At low f values they will form a network throughout the system surrounding multiple atoms. At higher f values, this network will split into individual covalent bonds. Just like heterogenous covalent bonds, these are characterized by high depth and their location along an atomic bond.</p> <p></p> <p></p> </li> <li> <p>Metallic Character. In most metals, there will be a metallic domain similar to that of a homogenous covalent bond that forms a network throughout the system. However, the metallic domains making up this network have incredibly low depths (~0.02), low volumes and charges, and are typically not located along atomic bonds.</p> <p></p> <p></p> </li> <li> <p>Bare Electrons/Electrides. Finally, anything else that splits from the valence domain has a large depth and doesn't sit directly along an atomic bond. These attractors tend to have a larger volume, ELF value, depth, and distance to nearby atoms. This type of feature is found in both electrides and metals, and how to distinguishing them is still up for debate. In our implementation they are separated by a series of user controlled cutoffs.</p> <p></p> <p></p> </li> </ol> <p>Note</p> <p>There may be other types of attractors that are not found with the current algorithm (e.g. the unique features commonly displayed by hydrogen). If you run into an issue with these features and would like us to add support for them, please let our team know on our github issues page.</p>"},{"location":"apps/badelf/finder/elf_analyzer/","title":"The ElfAnalyzerToolkit Class","text":""},{"location":"apps/badelf/finder/elf_analyzer/#about","title":"About","text":"<p>The first step of the BadELF algorithm is to determine whether there are bare electrons in the system and, if so, where they are located. In the original paper this was done by using relatively simple distance and ELF value cutoffs. Since then, the <code>ElfAnalyzerToolkit</code> method has evolved to be more rigorous. Using exclusively the ELF, charge density, and crystal structure, the <code>ElfAnalyzerToolkit</code> class now automatically detects not only bare electrons, but atom cores, atom shells, covalent bonds, metallic features, and lone-pairs.</p> <p>While it was originally conceived to support the BadELF algorithm, the current ElfAnalyzerToolkit class can be used as a general tool for analyzing the ELF, providing considerably more information on each ELF feature than the BadElfToolkit class.</p> <p>Explanations for each parameter can be found as a subsection of the <code>elf_analyzer_kwargs</code> section on our parameters page</p>"},{"location":"apps/badelf/finder/elf_analyzer/#initializing-the-class","title":"Initializing the Class","text":"<p>The <code>ElfAnalyzerToolkit</code> class can be initialized from files or by providing the ELF and charge density grids as Grid class objects. The Grid class inherits from pymatgen's VolumetricData class, and in principle allows for the use of codes other than VASP.</p> from filefrom grid class <pre><code>from simmate.apps.badelf.core import ElfAnalyzerToolkit\n\nfinder = ElfAnalyzerToolkit.from_files(\n    directory=\"/path/to/folder\", # This is the directory where the files are located\n    # The parameters below are optional\n    elf_file=\"partitioning_filename\", # default ELFCAR\n    charge_file=\"charge_filename\", # default CHGCAR\n    separate_spin = True, # Treats spin-up and spin-down separately\n    ignore_low_pseudopotentials = False, # ignores issues with missing core electrons\n    downscale_resolution: int = 1200, # Downscales the ELF and charge density unless set to None\n)\n</code></pre> <pre><code>from simmate.apps.badelf.core import ElfAnalyzerToolkit\nfrom simmate.apps.bader.toolkit import Grid\nfrom pathlib import Path\n\ndirectory = Path(\"path/to/folder\") # indicates the path to the folder where BadELF should run\nelf_grid = Grid.from_file(\"path/to/partitioning_file\")\ncharge_grid = Grid.from_file(\"path/to/partitioning_file\")\n\nfinder = ElfAnalyzerToolkit(\n    directory=directory,\n    elf_grid=partitioning_grid,\n    charge_grid=charge_grid,\n    # The parameters below are optional\n    separate_spin = True, # treats spin-up and spin-down separately\n    ignore_low_pseudopotentials = False, # ignores issues with missing core electrons        \n    downscale_resolution: int = 1200, # Downscales the ELF and charge density unless set to None\n)\n</code></pre>"},{"location":"apps/badelf/finder/elf_analyzer/#getting-results","title":"Getting Results","text":"<p>Once the class is initialized, all of the results can be obtained:</p> <pre><code>results = finder.get_full_analysis(\n    resolution=0.01,\n    include_lone_pairs=False,\n    metal_depth_cutoff=0.1,\n    min_covalent_angle=135,\n    min_covalent_bond_ratio=0.4,\n    shell_depth=0.05,\n    electride_elf_min=0.5,\n    electride_depth_min=0.2,\n    electride_charge_min=0.5,\n    electride_volume_min=10,\n    electride_radius_min=0.3,\n    radius_refine_method=\"linear\",\n    write_results=True,\n)\n</code></pre> <p>This will return a dictionary with keys for a bifurcation graph, bifurcation plot, and a labeled structure. If the <code>separate_spin=True</code> tag was used, there will be two of each of these for the up and down cases. Descriptions for each of these are below.</p>"},{"location":"apps/badelf/finder/elf_analyzer/#bifurcation-graphs","title":"Bifurcation Graphs","text":"<p>The BifurcationGraph class is a custom network class built off of networkx. The graphs are constructed first during the process, and contain all of the most important information. Each node represents a unique topological domain at various ELF values. Reducible features are connected to their child irreducible features by the edges. The graphs can be obtain as follows:</p> spin polarizednot polarized <pre><code>graph_up = results[\"graph_up\"]\ngraph_down = results[\"graph_down\"]\n</code></pre> <pre><code>graph = results[\"graph\"]\n</code></pre>"},{"location":"apps/badelf/finder/elf_analyzer/#bifurcation-plots","title":"Bifurcation Plots","text":"<p>The bifurcation plots are Plotly <code>graph_objects</code> constructed directly from the <code>BifurcationGraph</code>s above. They can be obtained as follows:</p> spin polarizednot polarized <pre><code>    plot_up = results[\"plot_up\"]\n    plot_down = results[\"plot_down\"]\n</code></pre> <pre><code>    plot = results[\"plot\"]\n</code></pre> <p>If <code>write_results=True</code>, the plots will be written to a .html file which can be directly viewed in your browser. Alternatively, many python IDEs will also allow you to view the plot directly with</p> <pre><code>plot.show()\n</code></pre> <p>This should generate a plot similar to those on the background page.</p> <p>These plots are the easiest way to visualize the ELF features in your system. The Y-axis represents the ELF value at which each domain first separates from its parent domain. Hovering over each node in the graph will provide additional information about the domain it represents. For reducible domains, this includes information like the number of atoms it surrounds, and their structure index. For irreducible domains it includes things such as charge, volume, ELF maximum, depth, distance to nearest atom, and more. We recommend loading your ELF into a program such as VESTA or OVITO and different ELF values with the plot to help get used to what it represents. </p> <p>Note</p> <p>The charge provided by this method is identical to running the <code>BadElfToolkit</code> with the <code>zero-flux</code> algorithm. This matches a more traditional ELF topology analysis, rather than separating atoms with planes.</p>"},{"location":"apps/badelf/finder/elf_analyzer/#labeled-structures","title":"Labeled Structures","text":"<p>The labeled structures are pymatgen <code>Structure</code> objects with 'dummy' atoms representing different types of ELF features. This is primarily used by the <code>BadElfToolkit</code> for BadELF analysis, but is also useful for visualization.</p> <p>To get the labeled structures:</p> spin polarizednot polarized <pre><code>    labeled_structure_up = results[\"structure_up\"]\n    labeled_structure_down = results[\"structure_down\"]\n</code></pre> <pre><code>    labeled_structure = results[\"structure\"]\n</code></pre> <p>If the structure has any non-atomic features, they will be labeled with Dummy atoms. The following labels are used:</p> Feature Label Covalent Bond \"Z\" Lone-Pair \"Lp\" Metal \"M\" Electride \"E\" Other Bare Electron \"Le\" <p>Note</p> <p>Admittedly, some of these labels are not intuitive. This is due to pymatgen's Structure object limiting dummy atom labels to symbols that don't start with letters shared by an element (e.g. \"Cov\" isn't available because of C and Co)</p> <p>The labeled structures can then be written to files for visualization in software such as VESTA or OVITO.</p> spin polarizednot polarized <pre><code>    labeled_structure_up.to(\"my_structure_up.cif\", \"cif\")\n    labeled_structure_down.to(\"my_structure_down.cif\", \"cif\")\n</code></pre> <pre><code>    labeled_structure.to(\"my_structure.cif\", \"cif\")\n</code></pre>"},{"location":"apps/vasp/installation/","title":"VASP App Installation","text":""},{"location":"apps/vasp/installation/#installation","title":"Installation","text":"<ol> <li> <p>Add <code>vasp</code> (and it's dependencies) to the list of installed Simmate apps with: <pre><code>simmate config add vasp\n</code></pre></p> </li> <li> <p>Make sure you have the <code>vasp_std</code> command installed using one of two options:</p> <ul> <li> <p>(for beginners) Install Docker-Desktop. Then run the following commands:       <pre><code>simmate config update \"vasp.docker.enable=True\"\nsimmate config update \"vasp.docker.image=example.com:vasp/latest\"\n</code></pre></p> <p>Danger</p> <p>VASP is a commercial software, so we cannot provide Docker images for it. This is why you must provide a private image via <code>image=example.com:vasp/latest</code>.</p> </li> <li> <p>(for experts) Install VASP using offical guides and make sure <code>vasp_std</code> is in the path</p> </li> </ul> </li> <li> <p>Configure VASP POTCAR files. You can either extract these from the VASP installation files located at <code>vasp/5.x.x/dist/Potentials</code> or request a copy of these files from a team member or your IT department. Unpack the <code>tar.gz</code> files and place them in <code>~/simmate/vasp/Potentials</code>, maintaining their original folder and file names. Once you've completed these steps, your folder should look like this: <pre><code># Located at /home/my_username (~)\nsimmate/\n\u2514\u2500\u2500 vasp\n    \u2514\u2500\u2500 Potentials\n        \u251c\u2500\u2500 LDA\n        \u2502   \u251c\u2500\u2500 potpaw_LDA\n        \u2502   \u251c\u2500\u2500 potpaw_LDA.52\n        \u2502   \u251c\u2500\u2500 potpaw_LDA.54\n        \u2502   \u2514\u2500\u2500 potUSPP_LDA\n        \u251c\u2500\u2500 PBE\n        \u2502   \u251c\u2500\u2500 potpaw_PBE\n        \u2502   \u251c\u2500\u2500 potpaw_PBE.52\n        \u2502   \u2514\u2500\u2500 potpaw_PBE.54\n        \u2514\u2500\u2500 PW91\n            \u251c\u2500\u2500 potpaw_GGA\n            \u2514\u2500\u2500 potUSPP_GGA\n</code></pre></p> <p>Note</p> <p>If the folder is not set up correctly, subsequent commands may fail, resulting in an error like this:</p> <pre><code>FileNotFoundError: [Errno 2] No such file or directory: '/home/jacksund/simmate/vasp/Potentials/PBE/potpaw_PBE.54/Na/POTCAR'\n</code></pre> <p>If you encounter this error, revisit your folder setup.</p> <p>Danger</p> <p>Our team only has access to VASP v5.4.4. If your folder structure differs for newer versions of VASP, please inform us by opening an issue.</p> </li> <li> <p>Ensure everything is configured correctly: <pre><code>simmate config test vasp\n</code></pre></p> </li> </ol>"},{"location":"apps/vasp/overview/","title":"VASP Application","text":"<p>Warning</p> <p>A license is required to use the VASP software. If you are looking for a free alternative, try Quantum Espresso.</p> <p>The Vienna Ab initio Simulation Package (VASP) is a proprietary software designed for atomic scale materials modelling based on first principles.</p> <p>It can be considered an alternative to popular DFT softwares such as Quantum Espresso, CASTEP, and ABINIT.</p> <p>Meanwhile, Simmate's VASP app builds workflows and utilities on top of the VASP code. Typically, other workflows oversee the execution of the workflows registered in this app. For example, many VASP workflows are available in the <code>materials_project</code> and <code>warren_lab</code> apps.</p>"},{"location":"apps/vasp/overview/#useful-resources","title":"Useful Resources","text":"<ul> <li>Official Website</li> <li>User Manual</li> <li>Tutorials</li> </ul>"},{"location":"apps/vasp/workflows/","title":"Workflows","text":""},{"location":"apps/vasp/workflows/#vasp-workflows","title":"VASP Workflows","text":"<p>Warning</p> <p>This page is a work-in-progress, as we are still developing guides for defining custom VASP workflows. </p>"},{"location":"apps/vasp/workflows/#available-workflows","title":"Available Workflows","text":"<p>Note</p> <p>This app is meant more so for building VASP workflows, rather the providing presets. Therefore, many more VASP workflows are available in the <code>materials_project</code> and <code>warren_lab</code> apps.</p> <pre><code>relaxation.vasp.quality00\nrelaxation.vasp.quality01\nrelaxation.vasp.quality02\nrelaxation.vasp.quality03\nrelaxation.vasp.quality04\nrelaxation.vasp.staged\nstatic-energy.vasp.quality04\n</code></pre>"},{"location":"apps/vasp/workflows/#making-new-workflows","title":"Making New Workflows","text":""},{"location":"apps/vasp/workflows/#vaspworkflow-base-class","title":"<code>VaspWorkflow</code> base class","text":"<p>The <code>VaspWorkflow</code> class, which includes many built-in features:</p> basic VASP examplefull-feature VASP exampleCustom INCAR modifier <pre><code>from simmate.apps.vasp.workflows.base import VaspWorkflow\n\nclass Relaxation__Vasp__MyExample1(VaspWorkflow):\n\n    functional = \"PBE\"\n    potcar_mappings = {\"Y\": \"Y_sv\", \"C\": \"C\"}\n\n    _incar = dict(\n        PREC=\"Normal\",\n        EDIFF=1e-4,\n        ENCUT=450,\n        NSW=100,\n        KSPACING=0.4,\n    )\n</code></pre> <pre><code>from simmate.apps.vasp.workflows.base import VaspWorkflow\nfrom simmate.apps.vasp.inputs import PBE_POTCAR_MAPPINGS\nfrom simmate.apps.vasp.error_handlers import (\n    Frozen,\n    NonConverging,\n    Unconverged,\n    Walltime,\n)\n\n\nclass Relaxation__Vasp__MyExample2(VaspWorkflow):\n\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS  # (1)\n\n    _incar = dict(\n        PREC=\"Normal\",  # (2)\n        EDIFF__per_atom=1e-5,  # (3)\n        ENCUT=450,\n        ISIF=3,\n        NSW=100,\n        IBRION=1,\n        POTIM=0.02,\n        LCHARG=False,\n        LWAVE=False,\n        KSPACING=0.4,\n        multiple_keywords__smart_ismear={  # (4)\n            \"metal\": dict(\n                ISMEAR=1,\n                SIGMA=0.06,\n            ),\n            \"non-metal\": dict(\n                ISMEAR=0,\n                SIGMA=0.05,\n            ),\n        },\n        # WARNING --&gt; see \"Custom Modifier\"\" tab for this to work\n        EXAMPLE__multiply_nsites=8,  # (5)\n    )\n\n    error_handlers = [  # (6)\n        Unconverged(),\n        NonConverging(),\n        Frozen(),\n        Walltime(),\n    ]\n</code></pre> <ol> <li>You can use pre-set mapping for all elements rather than define them yourself</li> <li>Settings that match the normal VASP input are the same for all structures regardless of composition.</li> <li>Settings can also be set based on the input structure using built-in tags like <code>__per_atom</code>. Note the two underscores (<code>__</code>) signals that we are using a input modifier.</li> <li>The type of smearing we use depends on if we have a metal, semiconductor, or insulator. So we need to decide this using a built-in keyword modifier named <code>smart_ismear</code>. Because this handles the setting of multiple INCAR values, the input begins with <code>multiple_keywords</code> instead of a parameter name.</li> <li>If you want to create your own logic for an input parameter, you can do that as well. Here we are showing a new modifier named <code>multiply_nsites</code>. This would set the incar value of EXAMPLE=16 for structure with 2 sites (2*8=16). Note, we define how this modifer works and register it in the \"Custom INCAR modifier\" tab. Make sure you include this code as well.</li> <li>These are some default error handlers to use, and there are many more error handlers available than what's shown. Note, the order of the handlers matters here. Only the first error handler triggered in this list will be used before restarting the job</li> </ol> <p>If you need to add advanced logic for one of your INCAR tags, you can register a keyword_modifier to the INCAR class like so: <pre><code># STEP 1: define the logic of your modifier as a function\n# Note that the function name must begin with \"keyword_modifier_\"\ndef keyword_modifier_multiply_nsites(structure, example_mod_input):\n    # add your advanced logic to determine the keyword value.\n    return structure.num_sites * example_mod_input\n\n# STEP 2: register modifier with the Incar class\nfrom simmate.apps.vasp.inputs import Incar\nIncar.add_keyword_modifier(keyword_modifier_multiply_nsites)\n\n# STEP 3: use your new modifier with any parameter you'd like\n_incar = dict(\n    \"NSW__multiply_nsites\": 2,\n    \"EXAMPLE__multiply_nsites\": 123,\n)\n</code></pre></p> <p>Danger</p> <p>Make sure this code is ran BEFORE you run the workflow. Registration is  reset every time a new python session starts. Therefore, we recommend  keeping your modifer in the same file that you define your workflow in.</p> <p>You can also use Python inheritance to borrow utilities and settings from an existing workflow:</p> <pre><code>from simmate.workflows.utilities import get_workflow\n\noriginal_workflow = get_workflow(\"static-energy.vasp.matproj\")\n\n\nclass StaticEnergy__Vasp__MyCustomPreset(original_workflow):\n\n    version = \"2022.07.04\"\n\n    _incar_updates = dict(\n        NPAR=1,\n        ENCUT=-1,\n    )\n</code></pre>"},{"location":"apps/vasp/_todo/error_handlers/","title":"Error handlers","text":""},{"location":"apps/vasp/_todo/error_handlers/#vasp-error-handlers","title":"VASP Error Handlers","text":"<p>This module provides error handlers designed to resolve issues that may arise during VASP workflow executions. It is a refactored version of error handlers originally used by Custodian, serving as a direct alternative to the <code>custodian.vasp.handlers</code> module. A significant distinction is that our error handlers are divided into smaller units, enhancing visibility of the error and its corresponding solution.</p>"},{"location":"apps/vasp/_todo/inputs/","title":"Inputs","text":""},{"location":"apps/vasp/_todo/inputs/#vasp-input-files","title":"VASP Input Files","text":"<p>This module assists in generating and interpreting VASP input files. It is a derivative and restructured version of classes utilized by PyMatGen. Specifically, it serves as a direct substitute for the <code>pymatgen.io.vasp.inputs</code> module.</p>"},{"location":"apps/vasp/_todo/neb/","title":"Nudged Elastic Band (NEB)","text":"<p>NEB is a technique used to determine the energy barrier of a specific migration pathway, such as atomic diffusion.</p>"},{"location":"apps/vasp/_todo/neb/#components-of-nudged-elastic-band","title":"Components of Nudged Elastic Band","text":"<p>** Note: Steps 3-5 are executed for each individual pathway **</p> <ol> <li> <p>Relax the initial bulk structure</p> </li> <li> <p>Identify all symmetrically unique pathways</p> </li> <li> <p>Relax the start/end supercell images      (or only one if they are equivalent)</p> </li> <li> <p>Interpolate the start/end supercell images and relax these     using IDPP.</p> </li> <li> <p>Relax all images using NEB</p> </li> </ol>"},{"location":"apps/vasp/_todo/neb/#potential-inputs","title":"Potential Inputs","text":"<p>Depending on the workflow, a user may wish to begin at a different step. For instance, they might have a specific start/end structure they want to use instead of automatically detecting unique pathways. Hence, we divide this workflow into several smaller ones. We need to consider the following input scenarios:</p> <ol> <li> <p><code>all_paths</code>: A bulk crystal and diffusing species are provided, and a full analysis of all paths is requested.</p> </li> <li> <p><code>single_path</code>: A bulk crystal, diffusing species, and pathway index are provided. The index specifies the particular pathway to be extracted from DistinctPathFinder. For instance, if DistinctPathFinder finds 5 unique paths, you can specify \"I want to run the 4th pathway in this list (i.e., the 4th shortest pathway).\"</p> </li> <li> <p><code>from_startend_sites</code>: A bulk crystal and start/end sites for the diffusing ion are provided, and that specific pathway should be analyzed. This would allow for a diffusion pathway that goes from a site at (0,0,0) to (1,1,1), for example.</p> </li> <li> <p><code>from_endpoints</code>: Two endpoint supercell structures are provided, and the specific pathway (from interpolated structures) should be analyzed.</p> </li> <li> <p><code>from_images</code>: A series of images are provided and analyzed.</p> </li> </ol> <p>In addition to these five scenarios, we also consider...</p> <ul> <li>Vacancy vs. interstitial diffusion</li> <li>Plugins for CI-NEB (currently not implemented)</li> </ul>"},{"location":"apps/vasp/_todo/neb/#useful-links","title":"Useful Links","text":"<ul> <li>Atomate NEB yaml</li> <li>Atomate NEB py</li> <li>pymatgen-diffusion neb</li> <li>pymatgen-diffusion pathfinder </li> <li>VASP's guide for NEB</li> <li>Plug-in guide for CI-NEB</li> </ul>"},{"location":"apps/vasp/_todo/outputs/","title":"Outputs","text":""},{"location":"apps/vasp/_todo/outputs/#vasp-output-files","title":"VASP Output Files","text":"<p>This module assists in generating and interpreting VASP output files. It is a derivative and restructured version of classes utilized by PyMatGen. Specifically, it serves as a direct substitute for the <code>pymatgen.io.vasp.outputs</code> module.</p>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/","title":"Modifying Workflow Settings","text":"<p>Danger</p> <p>The techniques outlined in this section are generally not recommended, but they can be useful for initial setup. Following this, we will discuss the optimal method for modifying settings and creating new workflows.</p>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/#why-isnt-there-a-custom_settings-option","title":"Why isn't there a <code>custom_settings</code> option?","text":"<p>We deliberately do not use <code>workflow.run(custom_settings=...)</code>. This will NOT work. Simmate takes this approach because we want to avoid storing results from custom settings in the same results table. This would (a) complicate the analysis of multiple structures/systems and (b) make navigating results extremely challenging for beginners. </p> <p>For instance, altering the <code>ENCUT</code> or changing the dispersion correction of a VASP calculation would prevent energy comparisons between all materials in the table, rendering features like calculated hull energies inaccurate.</p> <p>Instead, Simmate promotes the creation of new workflows and result tables for custom settings. This emphasizes Simmate's focus on \"scaling up\" workflows (i.e., running a fixed workflow on thousands of materials) rather than \"scaling out\" workflows (i.e., a flexible workflow that changes on a structure-by-structure basis).</p>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/#modifying-settings-for-an-existing-workflow","title":"Modifying settings for an existing workflow","text":"<p>For quick testing, it can be useful to adjust a workflow's settings without creating a new workflow. There are two methods to edit your settings:</p>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/#option-1","title":"OPTION 1","text":"<p>Write input files and manually submit a separate program</p> <pre><code># This simply writes input files\nsimmate workflows setup-only static-energy.vasp.mit --structure POSCAR\n\n# access your files in the new directory\ncd static-energy.vasp.mit.SETUP-ONLY\n\n# Customize input files as you see fit.\n# For example, you may want to edit INCAR settings\nnano INCAR\n\n# You can then submit VASP manually. Note, this will not use\n# simmate at all! So there is no error handling and no results\n# will be saved to your database.\nvasp_std &gt; vasp.out\n</code></pre>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/#option-2","title":"OPTION 2","text":"<p>Use the \"customized\" workflow for an app (e.g., <code>customized.vasp.user-config</code>)</p> <pre><code># In a file named \"my_example.yaml\".\n\n# Indicates we want to change the settings, using a specific workflow as a starting-point\nworkflow_name: customized.vasp.user-config\nworkflow_base: static-energy.vasp.mit\n\n# \"Updated settings\" indicated that we are updating some class attribute. \n# These fundamentally change the settings of a workflow. \n# Currently, only updating dictionary-based attributes are supported\nupdated_settings:\n    incar: \n        ENCUT: 600\n        KPOINTS: 0.25\n    potcar_mappings:\n        Y: Y_sv\n\n# Then the remaining inputs are the same as the base workflow\ninput_parameters:\n    structure: POSCAR\n    command: mpirun -n 5 vasp_std &gt; vasp.out\n</code></pre> <pre><code># Now run our workflow from the settings file above.\n# Results will be stored in a separate table from the\n# base workflow's results.\nsimmate workflows run-yaml my_example.yaml\n</code></pre> <p>Warning</p> <p>These methods are only applicable to single-calculation workflows (i.e., \"nested\" workflows that call several workflows within them are not supported)</p>"},{"location":"apps/vasp/_todo/update_an_existing_workflow/#avoid-these-methods-if-possible","title":"Avoid these methods if possible!","text":"<p>Both options above are only suitable for customizing settings for a few calculations, and you lose some key Simmate features. If you are submitting many calculations (&gt;20) and these methods do not meet your needs, continue reading!</p>"},{"location":"full_guides/overview/","title":"Full Guides","text":"<p>Note</p> <p>Before using the full guides, ensure you have either completed our introductory tutorials or have a good understanding of Python.</p>"},{"location":"full_guides/overview/#organization-overview","title":"Organization Overview","text":"<p>The structure of our guides and code may not always match. We've found that separating the two helps newcomers navigate Simmate without having to grasp all its components at once.</p>"},{"location":"full_guides/overview/#documentation","title":"Documentation","text":"<p>Our guides are arranged in order to mirror the typical user journey with Simmate. Users generally start with high-level features (the website interface) and progressively delve into lower-level features (the toolkit and Python objects). The documentation mirrors this progression.</p> <pre><code>graph LR\n  A[Website] --&gt; B[Workflows];\n  B --&gt; C[Database];\n  C --&gt; D[Toolkit];\n  D --&gt; E[Extras];</code></pre>"},{"location":"full_guides/overview/#source-code","title":"Source Code","text":"<p>For our python modules, <code>simmate</code> is the base module, housing all the code that our package operates on. Each subfolder (or Python \"module\") provides detailed information about its contents.</p> <p>These modules include:</p> <ul> <li><code>apps</code>: Runs specific analyses or third-party programs (e.g., VASP, which performs DFT calculations)</li> <li><code>command_line</code>: Provides common functions as terminal commands</li> <li><code>configuration</code>: Contains default Simmate settings and methods for modifying them</li> <li><code>database</code>: Sets up data table structures and methods for accessing these tables</li> <li><code>engine</code>: Offers tools for running calculations and managing errors</li> <li><code>file_converters</code>: Includes methods for converting between file types (e.g., POSCAR to CIF)</li> <li><code>toolkit</code>: Houses core methods and classes for Simmate (e.g., the <code>Structure</code> class)</li> <li><code>utilities</code>: Contains simple functions used across other modules</li> <li><code>visualization</code>: Provides methods for visualizing structures and data</li> <li><code>website</code>: Powers the simmate.org website</li> <li><code>workflows</code>: Contains tools defining each calculation type (e.g., a structure optimization)</li> </ul> <p>Additionally, there's one extra file:</p> <ul> <li><code>conftest</code>: Runs Simmate tests and is intended solely for contributing developers</li> </ul>"},{"location":"full_guides/apps/basic_use/","title":"Basic App Use","text":""},{"location":"full_guides/apps/basic_use/#finding-installing-apps","title":"Finding &amp; Installing Apps","text":"<p>One app at a time</p> <ol> <li>Browse the full list in the <code>Apps</code> tab above </li> <li>Follow the installation directions for each app you would like to use</li> </ol> <p>All apps at once</p> <p>Danger</p> <p>This guide is not yet available. For now, go through each app installation one at a time. We will eventually add a guide on how to install all of them at once, which will help advanced users setup production systems quickly.</p>"},{"location":"full_guides/apps/basic_use/#view-installed-apps","title":"View installed apps","text":"<p>Run the command:</p> <pre><code>simmate config show\n</code></pre> <p>And in the output, your list of installed app configs will be shown under the <code>apps</code> key:</p> <pre><code># example output\napps:\n- simmate.apps.configs.QuantumEspressoConfig\n- simmate.apps.configs.VaspConfig\n- simmate.apps.configs.BaderConfig\n- simmate.apps.configs.EvolutionConfig\n- simmate.apps.configs.MaterialsProjectConfig\n- simmate.apps.configs.AflowConfig\n- simmate.apps.configs.CodConfig\n- simmate.apps.configs.JarvisConfig\n- simmate.apps.configs.OqmdConfig\n</code></pre>"},{"location":"full_guides/apps/basic_use/#uninstall-an-app","title":"Uninstall an app","text":"<p>Warning</p> <p>Removing an app does not remove its tables from your database.</p> <p>Go to your <code>~/simmate/settings.yaml</code> file, and remove the target config(s) from the <code>apps:</code> list.</p>"},{"location":"full_guides/apps/basic_use/#accessing-tables","title":"Accessing tables","text":"<p> refer to our database guide in the sidebar for basic use.</p> <p>All of an app's tables and datasets are packaged within its <code>models</code> module, such as <code>simmate.apps.example.models</code>. This is because Simmate uses Django ORM under the hood, and following with their terminology, a <code>model</code> is effectively the definition of a single database table.</p> <p>Example</p> <p>We can then load the Materials Project structures table from <code>simmate.apps.materials_project.models</code>:</p> <pre><code>from simmate.apps.materials_project.models import MatprojStructure\n</code></pre>"},{"location":"full_guides/apps/basic_use/#accessing-workflows","title":"Accessing workflows","text":"<p> refer to our workflows guide in the sidebar for basic use.</p> <p>In addition, advanced python users may choose to import a workflow directly (rather than use the <code>get_workflow</code> utility). All of an app's workflows are packaged within its <code>workflow</code> module, such as <code>simmate.apps.example.workflows</code>.</p> <p>Example</p> <p><code>static-energy.vasp.mat-proj</code> is converted to <code>StaticEnergy__Vasp__MatProj</code> following our workflow naming conventions. We can then pull this workflow class from <code>simmate.apps.materials_project.workflows</code>:</p> <pre><code>from simmate.apps.materials_project.workflows import StaticEnergy__Vasp__MatProj\n</code></pre>"},{"location":"full_guides/apps/creating_custom_apps/","title":"Creating custom apps","text":""},{"location":"full_guides/apps/creating_custom_apps/#django-apps-vs-simmate-apps","title":"Django Apps vs. Simmate Apps","text":"<p>Simmate is built on top of the Django web framework, which is used by thousands of developers. In fact, many major software companies &amp; products were built using Django:</p> <ul> <li>Instagram</li> <li>Spotify</li> <li>Pinterest</li> <li>Dropbox</li> <li>The Washington Post</li> </ul> <p>... and many more. Simmate is a very small addition to this list. </p> <p>With this in mind, it is helpful to know that all of our Simmate apps are really just Django apps -- but with some extra features tacked on (e.g. chemistry tools &amp; workflows). In fact, any app you build with Django can be used with Simmate. Because of this, we highly recommend exploring Django's intro guides to get started.</p>"},{"location":"full_guides/apps/creating_custom_apps/#step-by-step-tutorials","title":"Step-by-Step Tutorials","text":"<ol> <li>Django's official tutorial</li> <li>Simmate's getting-start guide</li> </ol> <p>Tip</p> <p><code>django</code> is installed for you when you install <code>simmate</code>, so you can start their tutorials without any additional setup.</p>"},{"location":"full_guides/apps/creating_custom_apps/#folder-structure","title":"Folder Structure","text":"<p>All apps follow the same folder structure, where every folder is optional (and in practice, most apps only contain a few of these folders):</p> <pre><code>\u251c\u2500\u2500 example_app\n\u2502   \u251c\u2500\u2500 configuration\n\u2502   \u251c\u2500\u2500 command_line\n\u2502   \u251c\u2500\u2500 inputs\n\u2502   \u251c\u2500\u2500 outputs\n\u2502   \u251c\u2500\u2500 error_handlers\n\u2502   \u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 schedules\n\u2502   \u251c\u2500\u2500 templates\n\u2502   \u251c\u2500\u2500 urls\n\u2502   \u251c\u2500\u2500 views\n\u2502   \u2514\u2500\u2500 workflows\n</code></pre> <p>There are no restrictions on adding extra python modules to your app. In fact, some of our apps include extra functionality, such as utilities or toolkit add-ons.</p>"},{"location":"full_guides/apps/creating_custom_apps/#generate-example-app-files","title":"Generate Example App Files","text":"<ol> <li> <p>To start a new app, navigate to your desired folder for code storage and run: <pre><code>simmate create-app\n</code></pre></p> </li> <li> <p>You will then see a new folder named <code>my_new_project</code>: <pre><code>my_new_project/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 example_app\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 apps.py\n    \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 tests.py\n    \u251c\u2500\u2500 urls.py\n    \u251c\u2500\u2500 views.py\n    \u2514\u2500\u2500 workflows.py\n</code></pre></p> </li> <li> <p>Edit the files to start building out your new app</p> </li> </ol> <p>Tip</p> <p>Once you get the hang of building apps, all of the code in these files will be annoying to go through &amp; delete. There's nothing wrong with building your app out one file at a time, and ingoring the <code>simmate create-app</code> command.</p>"},{"location":"full_guides/apps/creating_custom_apps/#register-your-app","title":"Register Your App","text":"<p>Add your app's config to Simmate's list of registered apps:</p> <pre><code>simmate config add 'example_app.apps.ExampleAppConfig'\n</code></pre> <p>Note</p> <p>For Django users, all Simmate is doing here is adding your config to Simmate's internal list of Django <code>INSTALLED_APPS</code></p>"},{"location":"full_guides/apps/creating_custom_apps/#adding-tables","title":"Adding Tables","text":"<p>Add any <code>Database</code> table (or django <code>Model</code>) to the app's <code>models.py</code> file. If you make a models folder instead (<code>my_app/models</code>), make sure your final tables are imported within <code>my_app/models/__init__.py</code>.</p> <pre><code># in `my_app/models/__init__.py`\nfrom .structures import MyStructureTable\nfrom .test_results import MyTestResults\n</code></pre> <p>Note</p> <p>Simmate uses Django to detect and maintain models, so all the same rules apply.</p> <p>Tip</p> <p>Read more about custom tables in our Database guides</p>"},{"location":"full_guides/apps/creating_custom_apps/#adding-workflows","title":"Adding Workflows","text":"<p>Add any <code>Workflow</code> to the app's <code>workflows.py</code> file AND list them in the <code>__all__</code> global variable.: <pre><code># in workflows.py\n__all__ = [\n    \"MyExample__Workflow__Test123\",\n    \"MyExample__Workflow__Test321\",\n]\n\n# (then the workflows are defined below)\n</code></pre></p> <p>If you make <code>my_app/workflows</code> a folder, make sure your final tables are imported within <code>my_app/workflows/__init__.py</code> <pre><code># in `my_app/workflows/__init__.py`\nfrom .flow_abc import MyExample__Workflow__TestABC\nfrom .flow_def import MyExample__Workflow__TestDEF\n</code></pre></p> <p>Tip</p> <p>Read more about custom tables in our Workflow guides</p>"},{"location":"full_guides/apps/creating_custom_apps/#adding-web-ui-urlsviews","title":"Adding Web UI (urls/views)","text":"<p>Build your <code>urls.py</code>, <code>views.py</code>, and <code>templates/*.html</code> files following official Django docs. Everything in your <code>urls.py</code> will be mapped to a namespace matching your app's name.</p> <p>For example, if you app was called <code>example_app</code> and this was your <code>urls.py</code>:</p> <pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('', views.index, name='index'),\n    path('my-custom-view/', views.my_custom_view, name='custom'),\n]\n</code></pre> <p>You could view them in the Simmate website at:</p> <ul> <li><code>http://127.0.0.1:8000/apps/example_app/</code></li> <li><code>http://127.0.0.1:8000/apps/example_app/my-custom-view/</code></li> </ul> <p>Tip</p> <p>Read more about custom tables in our Workflow guides</p>"},{"location":"full_guides/contributing/creating_and_submitting_changes/","title":"Changes Submission Guide","text":"<ol> <li> <p>Prior to making any changes, please inform our team to discuss your proposed updates using a github issue. This ensures everyone is informed about ongoing work and allows for constructive feedback. You can submit feature requests, bug reports, and other issues on our Issues page. For general ideas and queries, please use our Discussions page.</p> </li> <li> <p>Ensure your fork is up-to-date with our main code at <code>jacksund/simmate</code>. This is essential if it's been a while since your last update.</p> </li> <li> <p>Open the file you wish to edit in Spyder and make your changes.</p> </li> <li> <p>Don't forget to save all file changes in Spyder.</p> </li> <li> <p>Simmate enforces clean, readable code. We utilize the <code>black</code> formatter and isort for managing imports. Execute these commands in the <code>~/Documents/github/simmate</code> directory once you are done making changes: <pre><code>isort .\nblack .\n</code></pre></p> </li> <li> <p>Simmate uses pytest to ensure new changes don't interfere with existing features. Run these tests to validate your changes. Execute this command in the <code>~/Documents/github/simmate</code> directory: <pre><code># you can optionally run tests in parallel \n# with a command such as \"pytest -n 4\"\npytest\n</code></pre></p> </li> <li> <p>If all tests are successful, your changes are ready for submission to Simmate!</p> </li> <li> <p>Use GitKraken to review your changes. If the changes are satisfactory, <code>stage</code> and <code>commit</code> them to the new branch of your repo (<code>yourname/simmate</code>).</p> </li> <li> <p>Open a pull-request to merge your changes into our main code (<code>jacksund/simmate</code>). We'll review your changes and merge them if they meet our standards. You can add an emoji to your pull request title to show you've read the tutorial.</p> </li> </ol> <p>Tip</p> <p>You can also format files while coding with Spyder. Go to <code>Tools</code> -&gt; <code>Preferences</code> -&gt; <code>Completion and Linting</code> -&gt; <code>Code Style and Formatting</code> &gt; select <code>black</code> from the code formatting dropdown. To format an open file in Spyder, use the <code>Ctrl+Shift+I</code> shortcut.</p> <p>Note</p> <p>Currently, Spyder does not have a plugin for pytest. For now they only support a Unittest plugin.</p>"},{"location":"full_guides/contributing/extra/","title":"Additional Guidelines and Suggestions","text":""},{"location":"full_guides/contributing/extra/#source-code-search","title":"Source Code Search","text":"<p>When you've made significant changes to a method, you might need to find all its instances in Simmate. You can use Spyder's <code>Find</code> window for this. Here's how to set it up:</p> <ol> <li>In Spyder, go to the <code>View</code> tab (at the top of the window) &gt; <code>Panes</code> &gt; select <code>Find</code>.</li> <li>The <code>Find</code> option should now appear in the top-right window of Spyder, alongside your <code>Help</code> window and <code>Variable Explorer</code>.</li> <li>In the <code>Find</code> window, set <code>Exclude</code> to the following to prevent these files from being searched: <pre><code>*.csv, *.dat, *.log, *.tmp, *.bak, *.orig, *.egg-info, *.svg, *.xml, OUTCAR, *.js, *.html\n</code></pre></li> <li>Set <code>Search in</code> to the <code>src/simmate</code> directory to limit the search to source code.</li> </ol>"},{"location":"full_guides/contributing/extra/#command-line-git","title":"Command-Line Git","text":"<p>While we suggest using GitKraken, there might be times when you need to use the git command-line. Github offers detailed guides for this, but we've summarized the essentials here.</p> <p>To set up 2-factor-auth, follow these steps (according to these instructions):</p> <pre><code>1. Go to Profile &gt;&gt; Settings &gt;&gt; Account Security\n2. Click on \"Enable two-factor\" authentication\n3. Follow the prompts to finish setup (I used SMS and saved my codes to BitWarden)\n</code></pre> <p>To create your API token, follow these steps (according to these instructions):</p> <pre><code>1. Go to Profile &gt;&gt; Settings &gt;&gt; Developer Settings &gt;&gt; Personal Access tokens\n2. Generate a new token for 90 days with the \"repo\" scope and \"read:org\"\n3. Use this token as your password when running git commands\n</code></pre> <p>To set up permissions with git on the command-line, follow these steps (using this guide):</p> <pre><code>1. Make sure the GitHub CLI is installed (`conda install -c conda-forge gh`)\n2. Run `gh auth login` and follow the prompts to enter your personal token from above\n</code></pre> <p>Here are some frequently used commands... <pre><code># To clone a remote directory to your local disk\ngit clone &lt;GITHUB-URL&gt;\n\n# To pull a specific branch (main here) while in a git directory\ngit pull origin main\n\n# To discard all changes and reset your branch\ngit restore .\n</code></pre></p>"},{"location":"full_guides/contributing/first_time_setup/","title":"Getting Started","text":"<p>Tip</p> <p>We recommend students and teachers to use their Github accounts with Github's free Student/Teacher packages. This includes Github Pro and other beneficial software. However, this is not mandatory.</p> <ol> <li> <p>Fork the Simmate repository to your Github profile (e.g., <code>yourname/simmate</code>). The button to fork is at the top right of Simmate's home github page, near the \"star repo\" button.</p> </li> <li> <p>Clone <code>yourname/simmate</code> to your local desktop. We recommend using GitKraken and cloning to a folder named <code>~/Documents/github/</code>. GitKraken is free for public repositories (including Simmate), but is also part of Github's free Student/Teacher packages. Their 6-minute beginner video provides a quick start guide.</p> </li> <li> <p>Navigate to the cloned Simmate repository: <pre><code>cd ~/Documents/github/simmate\n</code></pre></p> </li> <li> <p>Create your conda environment using our conda file. This will install Spyder and name your new environment <code>simmate_dev</code>. We highly recommend using Spyder as your IDE for consistency with the rest of the team. <pre><code>conda env update -f envs/conda/dev.yaml\nconda install -n simmate_dev -c conda-forge spyder -y\nconda activate simmate_dev\n</code></pre></p> </li> <li> <p>Install Simmate in development mode to your <code>simmate_dev</code> environment. <pre><code>pip install -e .\n</code></pre></p> </li> <li> <p>When resetting your database, refrain from using the prebuilt database. It is best practice to have an empty database when developing. <pre><code>simmate database reset --confirm-delete --no-use-prebuilt\n</code></pre></p> </li> <li> <p>Confirm everything is functioning correctly by running our tests <pre><code># you can optionally run tests in parallel \n# with a command such as \"pytest -n 4\"\npytest\n</code></pre></p> </li> <li> <p>In GitKraken, you will start with <code>main</code> branch of your repository (<code>yourname/simmate</code>) checked out. Create a new branch and name it according to the changes you will make (e.g. <code>fix-example-app</code>).</p> </li> <li> <p>In Spyder, navigate to <code>Projects</code> &gt; <code>New Project...</code>. Select <code>existing directory</code>, choose your <code>~/Documents/github/simmate</code> directory, and then <code>create</code> your Project!</p> </li> <li> <p>You're now set to explore the source code and modify or add files! Continue to the next section for guidance on formatting, testing, and submitting your changes to our team.</p> </li> </ol>"},{"location":"full_guides/contributing/maintainer_notes/","title":"Maintainer Guidelines","text":""},{"location":"full_guides/contributing/maintainer_notes/#release-procedure","title":"Release Procedure","text":"<p>To generate a new release, adhere to these steps:</p> <ol> <li> <p>Modify the Simmate version number in <code>pyproject.toml</code> (link)</p> </li> <li> <p>Update the changelog with the new release and its release date.</p> </li> <li> <p>Confirm all tests pass using the pre-built database. If they don't, generate a new one using the commands below, rename your db file (e.g., <code>prebuild-2022-07-05.sqlite3</code>), compress the db file into a zip file, upload it to the Simmate CDN, and modify the <code>archive_filename</code> in <code>simmate.database.utilites.load_default_sqlite3_build</code>. <pre><code>simmate database reset --confirm-delete --no-use-prebuilt\nsimmate database load-remote-archives\n</code></pre></p> </li> <li> <p>Generate a release on Github, which will automatically release to pypi.</p> </li> <li> <p>Wait for the autotick bot to initiate a pull request for the simmate feedstock. Check the status here (under \"Queued\").</p> </li> <li> <p>Review the autotick bot's changes before merging. If there were substantial changes, use grayskull to modify the version number, sha256, and dependencies.</p> </li> <li> <p>After merging, wait for the conda-forge channels to update their indexes (about 30 minutes). Then, test the conda install with: <pre><code># for a normal release\nconda create -n my_env -c conda-forge simmate -y\n\n# additionally, ensure spyder can also be installed in the same environment\nconda install -n my_env -c conda-forge spyder -y\n</code></pre></p> </li> </ol>"},{"location":"full_guides/contributing/maintainer_notes/#full-test-suite","title":"Full Test Suite","text":"<p>Unit tests that require third-party programs (like VASP) are disabled by default. However, it's advisable to run a full test before new releases. To execute all unit tests that call programs like VASP:</p> <ol> <li> <p>Ensure you have the following prerequisites:</p> <ul> <li>A Linux environment with VASP &amp; Bader installed</li> <li>Dev version of Simmate installed</li> <li>The <code>main</code> branch of the official repo checked out</li> <li><code>simmate_dev</code> environment is active</li> <li>The base Simmate directory as the current working directory</li> <li>Clear any custom <code>~/simmate</code> configs (i.e., ensure default settings)</li> </ul> </li> <li> <p>Confirm the default test suite works: <pre><code>pytest\n</code></pre></p> </li> <li> <p>Reset your database, switch to the pre-built, and update it. This simulates the database of a new user: <pre><code>simmate database reset --confirm-delete --use-prebuilt\nsimmate database update\n</code></pre></p> </li> <li> <p>Open <code>pyproject.toml</code> and modify the following line to run the VASP tests: <pre><code># original line\naddopts = \"--no-migrations --durations=15 -m 'not blender and not vasp'\"\n\n# updated line\naddopts = \"--no-migrations --durations=15 -m 'not blender'\"\n</code></pre></p> </li> <li> <p>(Optional) By default, all VASP tests run using <code>mpirun -n 12 vasp_std &gt; vasp.out</code>. Modify this in <code>src/simmate/workflows/tests/test_all_workflow_runs.py</code> if needed.</p> </li> <li> <p>Run <code>pytest</code> again to pick up these tests. It's advisable to run specific tests and enable logging (<code>-s</code>) for monitoring: <pre><code># option 1\npytest\n\n# option 2(recommended)\npytest src/simmate/workflows/test/test_all_workflow_runs.py -s\n</code></pre></p> </li> <li> <p>If all tests pass, proceed with the new release. Discard your changes afterwards.</p> </li> </ol>"},{"location":"full_guides/contributing/maintainer_notes/#website-css","title":"Website CSS","text":"<p>The Hyper theme, as outlined in our main docs here, must be built and hosted separately from any Simmate server due to licensing. To build/host the assets, adhere to these steps: </p> <ol> <li>Download the Hyper theme (private access): e.g., <code>Hyper_v4.6.0.zip</code></li> <li>Unpack the zip file and navigate to this directory: <pre><code>cd Hyper_v4.6.0/Bootstrap_5x/Hyper/\n</code></pre></li> <li>Install prerequisites into a new conda environment and activate it: <pre><code>conda create -n hyper -c conda-forge nodejs yarn git\nconda activate hyper\n</code></pre></li> <li>Install gulp using npm (conda install of gulp doesn't work): <pre><code>npm install gulp -g\n</code></pre></li> <li>In the main directory, install all Hyper dependencies using the <code>yarn.lock</code> file: <pre><code>yarn install\n</code></pre></li> <li>Edit themes/colors in the following files (e.g., change primary to <code>#0072ce</code>): <pre><code>/src/assests/scss/config/saas/\n&gt;&gt; go into each folder's _variables.scss\n</code></pre></li> <li>Build the assets: <pre><code>gulp build\n</code></pre></li> <li>Upload assets (in <code>dist</code> folder) to your CDN for serving.</li> </ol>"},{"location":"full_guides/database/basic_use/","title":"Basic Database Access","text":""},{"location":"full_guides/database/basic_use/#overview","title":"Overview","text":"<p>The process of accessing and analyzing data typically involves these steps:</p> <ol> <li>Establish a connection to your database</li> <li>Load a specific database table</li> <li>Apply filters to the data</li> <li>Convert the data to a desired format</li> <li>Modify the data using <code>simmate.toolkit</code> or pandas.Dataframe</li> </ol> <p>The following sections will guide you through each of these steps. Here's an example of what your final script might look like:</p> <pre><code># Connect to your database\nfrom simmate.database import connect\n\n# Load a specific database table\nfrom simmate.apps.materials_project.models import MatprojStructure\n\n# Filter data\nresults = MatprojStructure.objects.filter(\n    nsites=3,\n    is_gap_direct=False,\n    spacegroup=166,\n).all()\n\n# Convert data to a desired format\nstructures = results.to_toolkit()\ndataframe = results.to_dataframe()\n\n# Modify data\nfor structure in structures:\n    # run your analysis/modifications here!\n</code></pre>"},{"location":"full_guides/database/basic_use/#connecting-to-your-database","title":"Connecting to Your Database","text":"<p>Before importing any submodules, you must configure Django settings for interactive use. Here's how to do it:</p> <pre><code># connect to the database\nfrom simmate.database import connect\n\n# now you can import tables in this module\nfrom simmate.database.workflow_results import MITStaticEnergy\n</code></pre> <p>If you forget the <code>connect</code> step, you'll encounter this error:</p> <pre><code>ImproperlyConfigured: Requested setting INSTALLED_APPS, but settings are not\nconfigured. You must either define the environment variable DJANGO_SETTINGS_MODULE \nor call settings.configure() before accessing settings.\n</code></pre>"},{"location":"full_guides/database/basic_use/#loading-your-database-table","title":"Loading Your Database Table","text":"<p>The name of your table depends on the source you're accessing. To see the available sources (Materials Project, OQMD, Jarvis, COD), explore the contents of the database/third_parties module.</p> <p>For example, to load a table from the Materials Project, use: <pre><code>from simmate.apps.materials_project.models import MatprojStructure\n</code></pre></p> <p>If you're accessing data from a specific workflow, you can access the table in two ways. Besides loading from the <code>workflow_results</code> module, most workflows have a <code>database_table</code> attribute that allows you to access the table:</p> <pre><code>########## METHOD 1 ########\n\nfrom simmate.workflows.static_energy import mit_workflow\n\ntable = mit_workflow.database_table\n\n\n######## METHOD 2 ########\n\nfrom simmate.database import connect\nfrom simmate.database.workflow_results import MITStaticEnergy\n\n# The line below shows that these tables are the same! Therefore, use\n# whichever method you prefer.\nassert table == MITStaticEnergy\n</code></pre>"},{"location":"full_guides/database/basic_use/#querying-and-filtering-data","title":"Querying and Filtering Data","text":"<p>Simmate uses Django's methods for querying a table, leveraging its Object-Relational Mapper (ORM) to make complex queries to our database. Below are some common queries. For a full list of query methods, refer to Django's query page.</p> <p>Access all rows of the database table via the <code>objects</code> attribute: <pre><code>MITStaticEnergy.objects.all()\n</code></pre></p> <p>Print all columns of the database table using the <code>show_columns</code> methods: <pre><code>MITStaticEnergy.show_columns()\n</code></pre></p> <p>Filter rows with exact-value matches in a column: <pre><code>MITStaticEnergy.objects.filter(\n    nsites=3,\n    is_gap_direct=False,\n    spacegroup=166,\n).all()\n</code></pre></p> <p>Filter rows based on conditions by chaining the column name with two underscores. Supported conditions are listed here, but the most commonly used ones are:</p> <ul> <li><code>contains</code> = contains text, case-sensitive query</li> <li><code>icontains</code>= contains text, case-insensitive query</li> <li><code>gt</code> = greater than</li> <li><code>gte</code> =  greater than or equal to</li> <li><code>lt</code> = less than</li> <li><code>lte</code> = less than or equal to</li> <li><code>range</code> = provides upper and lower bound of values</li> <li><code>isnull</code> = returns <code>True</code> if the entry does not exist</li> </ul> <p>Here's an example query with conditional filters: <pre><code>MITStaticEnergy.objects.filter(\n    nsites__gte=3,  # greater or equal to 3 sites\n    energy__isnull=False,  # the structure DOES have an energy\n    density__range=(1,5),  # density is between 1 and 5\n    elements__icontains='\"C\"',  # the structure includes the element Carbon\n    spacegroup__number=167,  # the spacegroup number is 167\n).all()\n</code></pre></p> <p>Note: For the filtering condition <code>elements__icontains</code>, we used quotations when querying for carbon: <code>'\"C\"'</code>. This is to avoid accidentally grabbing Ca, Cs, Ce, Cl, etc. This is necessary when using SQLite (the default database backend). If you're using Postgres, you can use the cleaner version <code>elements__contains=\"C\"</code>.</p>"},{"location":"full_guides/database/basic_use/#converting-data-to-desired-format","title":"Converting Data to Desired Format","text":"<p>By default, Django returns your query results as a <code>queryset</code> (or <code>SearchResults</code> in simmate), which is a list of database objects. It's often more useful to convert them to a pandas dataframe or to toolkit objects. <pre><code># Gives a pandas dataframe.\ndf = MITStaticEnergy.objects.filter(...).to_dataframe()\n\n# Gives a list of toolkit Structure objects\ndf = MITStaticEnergy.objects.filter(...).to_toolkit()\n\n# '...' are the set of filters selected from above.\n</code></pre></p>"},{"location":"full_guides/database/basic_use/#modifying-data","title":"Modifying Data","text":"<p>For information on how to modify and analyze data, refer to the pandas and <code>simmate.toolkit</code> documentation.</p>"},{"location":"full_guides/database/contributing_data/","title":"Contributing data","text":""},{"location":"full_guides/database/contributing_data/#contributing-your-data-with-simmate","title":"Contributing Your Data with Simmate","text":"<p>Warning</p> <p>This module is intended for the Simmate development team or third-party contributors who wish to integrate their own data. Users should use the <code>load_remote_archive</code> method to access data. For more information, refer to the database documentation.</p> <p>This module enables the import of data from various databases into Simmate using third-party codes. This data can then be used to build archives that users can access.</p>"},{"location":"full_guides/database/contributing_data/#benefits-of-integrating-your-data-with-simmate","title":"Benefits of Integrating Your Data with Simmate","text":"<p>When deciding whether to contribute your database to Simmate, consider the following:</p> <ol> <li>Will you benefit from converting data into a Simmate format?</li> <li>Will you benefit from distributing an archive? (private or public)</li> </ol> <p>The following sections will provide answers to these questions.</p>"},{"location":"full_guides/database/contributing_data/#converting-data-into-a-simmate-format","title":"Converting Data into a Simmate Format","text":"<p>Whether your data is open-source or proprietary, the benefits of using Simmate's <code>database</code> module remain the same. It...</p> <ul> <li>automatically constructs an API and ORM for your data</li> <li>significantly reduces the file size of your archives</li> </ul> <p>By providing raw data (such as a structure or energy), Simmate will automatically expand your data into the most useful columns, and you can then use our ORM to quickly query data. For example, Simmate can use an <code>energy</code> column/field to create columns for <code>energy_above_hull</code>, <code>formation_energy</code>, <code>decomposes_to</code>, and more -- then you can filter through your data using these new columns. Refer to the \"Querying Data\" section in the <code>simmate.database</code> module for examples of this query language.</p> <p>Simmate can efficiently compress your data to a small format by using the concepts of \"raw data\" vs \"secondary columns\" (columns that can be quickly recalculated using the raw data). To see just how compact, check out the file sizes for archives of current providers:</p> Provider Number of Structures Av. Sites per Structure Archive Size JARVIS 55,712 ~10 8.0 MB Materials Project 137,885 ~30 45.2 MB COD 471,664 ~248 1.16 GB OQMD 1,013,521 ~7 79.2 MB AFLOW n/a n/a n/a <p>(Note, COD experiences poor compression because Simmate has not yet optimized storage for disordered structures.)</p> <p>These small file sizes will make it much easier for downloading and sharing your data. This can have major savings on your database server as well.</p>"},{"location":"full_guides/database/contributing_data/#hosting-distributing-the-archive","title":"Hosting &amp; Distributing the Archive","text":"<p>Here is where being a private vs. open-source provider becomes important. Simmate allows you to decide how others access your data.</p> <p>If your data can only be accessible to your own team members or subscribers, then you can manage the distribution of the data (via a CDN, dropbox, etc.). Simmate does not require that you distribute your data freely, although we do encourage open-source data. Either way, you can benefit from...</p> <ul> <li>reducing the load on your own web APIs</li> </ul> <p>Server load can be reduced because, in Simmate, users download your archive once and then have the data stored locally for as long as they'd like. New users often want to download a large portion of a database (or all of it), and also do so repeatedly as they learn about APIs. Therefore, using Simmate archives upfront can save your team from these large and often-repeated queries.</p> <p>If you are fine with making your data freely available, you can further benefit by...</p> <ul> <li>avoiding the setup of your own server and instead use Simmate's for free</li> <li>exposing your data to the Simmate user base</li> </ul> <p>Providers that permit redistribution are welcome to use our CDN for their archives. This only requires contacting our team and making this request. Further, once your archive is configured, all Simmate users will be able to easily access your data.</p>"},{"location":"full_guides/database/contributing_data/#how-to-integrate-your-data-or-a-new-provider","title":"How to Integrate Your Data or a New Provider","text":"<p>Tip</p> <p>If you want to avoid this guide, you can just contact our team! Open a github issue to get our attention. In most cases, we only need a CSV or JSON file of your data (in any data format you'd like), and we can handle the rest for you. If you'd like to contribute the data on your own, keep reading.</p> <p>The end goal for each provider is to allow a user do the following: <pre><code>from simmate.database import connect\nfrom simmate.apps.example.models import ExampleProviderData\n\nExampleProviderData.load_remote_archive()\n\nsearch_results = ExampleProviderData.objects.filter(...).all()\n# plus all to_dataframe / to_toolkit features discussed elsewhere\n</code></pre></p> <p>The key part that providers must understand is the <code>load_remote_archive</code> method. This method...</p> <ol> <li>loads an archive of available data (as a <code>zip</code> file from a CDN)</li> <li>unpacks the data into the Simmate format</li> <li>saves everything to the user's database (by default this is <code>~/simmate/database.sqlite3</code>).</li> </ol> <p>This guide serves to make the first step work! Specifically, providers must make the archive that <code>load_remote_archive</code> will load in step 1 and make it downloadable by a CDN or API endpoint. It is up to the provider whether they personally distribute the archive or allow Simmate to distribute it for them.</p>"},{"location":"full_guides/database/contributing_data/#outline-of-steps","title":"Outline of Steps","text":"<p>To illustrate how this is done, we will walk through the required steps:</p> <ol> <li>Define a Simmate table</li> <li>Download data into the Simmate format (i.e. populate the Simmate table)</li> <li>Compress the data to archive file</li> <li>Make the archive available via a CDN</li> <li>Link the CDN to the Simmate table</li> </ol> <p>Tip</p> <p>These steps involve contributing changes to Simmate's code, so we recommend opening a github issue before starting too. That way, our team can help you through this process. If you are new to Github and contributing, be sure to read our tutorial for contributors too.</p>"},{"location":"full_guides/database/contributing_data/#step-1-define-a-simmate-table","title":"Step 1: Define a Simmate Table","text":"<p>To host data, Simmate must first know what kind of data you are going to host. We do this by adding a new file to the <code>simmate.database.third_party</code> module. You can view this folder on github here.</p> <p>Start by defining a <code>DatabaseTable</code> with any custom columns / database mix-ins. You can scroll through the other providers to see how tables are made. Good examples to view are for JARVIS and Materials Project.</p> <p>Here is a template with useful comments to get you started:</p> <pre><code># Start by deciding which base data types you can include. Here, we include a\n# crystal structure and an energy, so we use the Structure and Thermodynamics\n# mix-ins.\nfrom simmate.database.base_data_types import (\n    table_column, \n    Structure, \n    Thermodynamics,\n)\n\nclass ExampleProviderData(Structure, Thermodynamics):\n\n    # ----- Table columns + Required settings -----\n\n    # This Meta class tells Simmate where to store the table within our database.\n    # All providers with have the exact same thing here. \n    class Meta:\n        app_label = \"data_explorer\"\n\n    # By default, the ID column is an IntegerField, but if your data uses a string\n    # like \"mp-1234\" to denote structures, you can update this column to\n    # accept a string instead.\n    id = table_column.CharField(max_length=25, primary_key=True)\n\n    # Write the name of your team here!\n    source = \"The Example Provider Project\"\n\n    # We have many alerts to let users know they should cite you. Add the DOI\n    # that you'd like them to cite here.\n    source_doi = \"https://doi.org/...\"\n\n    # If you have any custom fields that you'd like to add, list them off here.\n    # All data types supported by Django are also supported by Simmate. You can\n    # view those options here:\n    #   https://docs.djangoproject.com/en/4.0/ref/models/fields/\n    custom_column_01 = table_column.FloatField(blank=True, null=True)\n    custom_column_02 = table_column.BooleanField(blank=True, null=True)\n\n    # Leave this as None for now. We will update this attribute in a later step.\n    remote_archive_link = None\n\n\n    # ----- Extra optionalfeatures -----\n\n    # (OPTIONAL) Define the \"raw data\" for your table. This is required if \n    # you'd like to use the `to_archive` method. Fields from the mix-in \n    # will automatically be added.\n    archive_fields = [\n        \"custom_column_01\",\n        \"custom_column_02\",\n    ]\n\n    # (OPTIONAL) Define how you would like data to be accessible in the REST \n    # API from the website server.\n    api_filters = {\n        \"custom_column_01\": [\"range\"],\n        \"custom_column_02\": [\"range\"],\n    }\n\n    # (OPTIONAL) if you host your data on a separate website, you can specify \n    # how to access that structure here. This is important if you want users\n    # to switch to your site for aquiring additional data. \n    @property\n    def external_link(self) -&gt; str:\n        return f\"https://www.exampleprovider.com/structure/{self.id}\"\n</code></pre> <p>Before moving on, make sure your table was configured properly by doing the following:</p> <pre><code># in the command line\nsimmate database reset\n</code></pre> <pre><code># in python\n\nfrom simmate.database import connect\nfrom simmate.apps.example.models import ExampleProviderData\n\n# This will show you all the columns for your table\nExampleProviderData.show_columns()\n\n# this will show you exactly what the table looks like\nmy_table = ExampleProviderData.objects.to_dataframe()\n</code></pre>"},{"location":"full_guides/database/contributing_data/#step-2-download-data-into-the-simmate-format","title":"Step 2: Download Data into the Simmate Format","text":"<p>Now that Simmate knows what to expect, we can load your data into the database. This can be done in several ways. It is entirely up to you which method to use, but here are our recommended options:</p> <ol> <li> <p>JSON or CSV file. If all of your data can be provided via a dump file, then we can use that! This is typically the easiest for a provider's server. For an example of this, see the COD implementation, which uses a download of CIF files.</p> </li> <li> <p>A custom python package. Feel free to add an optional dependency if your team has already put a lot of work into loading data using a python package. A great example of this is the MPRester class in pymatgen, which we use to pull Material Project data. (JARVIS, AFLOW, OQMD currently use this option too).</p> </li> <li> <p>REST API or GraphQL. If you have a web API, we can easily pull data using the python <code>requests</code> package. Note, in many cases, a REST API is an inefficient way to pull data - as it involves querying a database thousands of times (once for each page of structures) -- potentially crashing the server. In cases like that, we actually prefer a download file (option 1, shown above).</p> </li> <li> <p>OPTIMADE endpoint. This is a standardized REST API endpoint that many databases are using now. The huge upside here is that each database will have a matching API -- so once your team has an OPTIMADE endpoint, we can pull data into Simmate with ease. There's no need to build a 2nd implementation. The downside is the same as option 3: OPTIMADE doesn't have a good way to pull data in bulk. Their team is currently working on this though.</p> </li> <li> <p>Web scraping. As an absolute last resort, we can use <code>requests</code> to scrape webpages for data (or <code>selenium</code> in even more extreme cases.). This requires the most work from our team and is also the least efficient way to grab data. Therefore, scraping should always be avoided if possible.</p> </li> </ol> <p>With your data in hand, you will now add a file that saves data to the local simmate database on your computer. This file can be added to the <code>for_providers</code> module (here). However, if you want your data and its access to remain private, you can also keep this file out of Simmate's source-code. It's up to you, but we encourage providers to host their file in the Simmate repo -- so we can give feedback and so future providers can use it as an example/guide. </p> <p>Either way, here is a template of how that file will look like:</p> <pre><code>from django.db import transaction\nfrom rich.progress import track\n\nfrom simmate.toolkit import Structure\nfrom simmate.apps.example.models import ExampleProviderData\n\n# If you want to use a custom package to load your data, be sure to let our team\n# know how to install it.\ntry:\n    from my_package.db import get_my_data\nexcept:\n    raise ModuleNotFoundError(\n        \"You must install my_package with `conda install -c conda-forge my_package`\"\n    )\n\n\n# We make this an \"atomic transaction\", which means if any error is encountered\n# while saving results to the database, then the database will be reset to its\n# original state. Adding this decorator is optional\n@transaction.atomic\ndef load_all_structures():\n\n    # Use whichever method you chose above to load all of your data!\n    # Here' we are pretending to use a function that loads all data into a \n    # python dictionary, but this can vary.\n    data = get_my_data()\n\n    # Now iterate through all the data -- which is a list of dictionaries.\n    # We use rich.progress.track to monitor progress.\n    for entry in track(data):\n\n        # The structure is in the atoms field as a dictionary. We pull this data\n        # out and convert it to a toolkit Structure object. Note, this class\n        # is currently a subclass of pymatgen.Structure, so it supports reading\n        # from different file formats (like CIF or POSCAR) as well.\n        structure = Structure(\n            lattice=entry[\"atoms\"][\"lattice_mat\"],\n            species=entry[\"atoms\"][\"elements\"],\n            coords=entry[\"atoms\"][\"coords\"],\n            coords_are_cartesian=entry[\"atoms\"][\"cartesian\"],\n        )\n\n        # Now that we have a structure object, we can feed that and all\n        # other data to the from_toolkit() method. This will create a database\n        # object in the Simmate format. Note the data we pass here is based on\n        # the ExampleProviderData we defined in the other file.\n        structure_db = ExampleProviderData.from_toolkit(\n            id=entry[\"my_id\"],\n            structure=structure,  # required by Structure mix-in\n            energy=entry[\"my_final_energy\"],  # required by Thermodynamics mix-in\n            custom_column_01=entry[\"my_custom_column_01\"],\n            # The get method is useful if not all entries have a given field.\n            custom_column_02=entry.get(\"my_custom_column_02\"),\n        )\n\n        # and save it to our database!\n        structure_db.save()\n</code></pre> <p>Try running this on your dataset (or a subset of data if you want to quickly test things). When it finishes, you can ensure data was loaded properly by running:</p> <pre><code># in python\n\nfrom simmate.database import connect\nfrom simmate.apps.example.models import ExampleProviderData\n\n# Check that the number of rows matches your source data.\ntotal_entries = ExampleProviderData.objects.count()\n\n# View the data! (limited to your first 100 results)\nmy_table = ExampleProviderData.objects.to_dataframe(limit=100)\n</code></pre> <p>And that's it for writing new code! All that's left is making your data available for others.</p>"},{"location":"full_guides/database/contributing_data/#step-3-compress-the-data-to-archive-file","title":"Step 3: Compress the Data to Archive File","text":"<p>This will be the easiest step yet. We need to make a <code>zip</code> file for users to download, which can be done in one line:</p> <pre><code>ExampleProviderData.objects.to_archive()\n</code></pre> <p>You'll find a file named <code>ExampleProviderData-2022-01-25.zip</code> (but with the current date) in your working directory. The date is for timestamp and versioning your archives. Because archives are a snapshot of databases that may be dynamically changing/going, this timestamp helps users know which version they are on. You can practice reloading this data into your database too:</p> <ol> <li>Make a copy of your database file in <code>~/simmate/</code> so you don't lose your work</li> <li>In the terminal, reset your database with <code>simmate database reset</code></li> <li>In python, try reloading your data with <code>ExampleProviderData.load_archive()</code></li> <li>Try viewing your data again with <code>ExampleProviderData.objects.to_dataframe()</code></li> </ol>"},{"location":"full_guides/database/contributing_data/#step-4-make-the-archive-available-via-a-cdn","title":"Step 4: Make the Archive Available via a CDN","text":"<p>Users will now need the archive file you made to access your data. So you must decide: how should this <code>zip</code> file be downloaded by users? </p> <p>If you give Simmate approval, we can host your archive file on our own servers. Otherwise you must host your own. The only requirement for your host server is that the <code>zip</code> file can be downloaded from a URL.</p> <p>While we encourage open-source databases, if you consider your dataset private or commercial, Simmate does not require any payment or involvement for how this CDN is hosted and maintained. Thus, you can manage access to this URL via a subscription or any other method. However, Simmate's CDNs are reserved for archives that are freely distributed.</p> <p>Note: when uploading new versions of your archive, you should keep the outdated archive either available via its previous URL or, at a minimum, available upon request from users.</p>"},{"location":"full_guides/database/contributing_data/#step-5-link-the-cdn-to-the-simmate-table","title":"Step 5: Link the CDN to the Simmate Table","text":"<p>In Step 1, we left one attribute as None in our code: <code>remote_archive_link</code>. As a final step, you need to take the URL that you're host your <code>zip</code> file at and paste it here. For example, that line will become:</p> <pre><code>remote_archive_link = \"https://archives.simmate.org/ExampleProviderData-2022-01-25.zip\"\n</code></pre> <p>That's it! Let's test out everything again. Note, we are now using <code>load_remote_archive</code> in this process -- which will load your <code>zip</code> file from the URL.</p> <ol> <li>Make a copy of your database file in <code>~/simmate/</code> so you don't lose your work</li> <li>In the terminal, reset your database with <code>simmate database reset</code></li> <li>In python, try reloading your data with <code>ExampleProviderData.load_remote_archive()</code></li> <li>Try viewing your data again with <code>ExampleProviderData.objects.to_dataframe()</code></li> </ol> <p>If you've made it this far, thank you for contributing!!! Your data is now easily accessible to all Simmate users, which we hope facilitates its use and even lessen the load on your own servers. Congrats!</p>"},{"location":"full_guides/database/custom_tables/","title":"Custom Database Tables Creation","text":"<p>This module offers key components for data storage. When creating new and custom tables, these classes should be inherited.</p>"},{"location":"full_guides/database/custom_tables/#table-types","title":"Table Types","text":"<p>Data storage tables range from low-level to high-level. High-level tables inherit basic functionality from low-level tables and the data types stored in them, resulting in tables with enhanced functionality.  </p> <p>At the lowest level...</p> <ul> <li><code>base.DatabaseTable</code> : All tables inherit from this base type, which defines common functionality (like the <code>show_columns</code> method)</li> </ul> <p>At a higher level, tables inherit the <code>base.DatabaseTable</code> to create more specialized tables. These tables contain additional columns specific to the data stored in each. The new columns in each table are created using a feature called a mixin.  These mixins create the following tables:</p> <ul> <li><code>calculation</code> : Stores information about a specific calculation run (corrections, timestamps, etc.)</li> <li><code>structure</code> : Stores a periodic crystal structure</li> <li><code>symmetry</code> : NOT a mixin. Defines symmetry relationships for <code>structure</code> to reference</li> <li><code>forces</code> : Stores site forces and lattice stresses</li> <li><code>thermodynamics</code> : Stores energy and stability information</li> <li><code>density_of_states</code>: Stores results of a density of states calculation</li> <li><code>band_structure</code>: Stores results of a band structure calculation</li> </ul> <p>At the highest level, several lower-level tables can be combined via their mixins. This allows for the creation of tables that can store complex calculations:</p> <ul> <li><code>static_energy</code> : Stores results of single point energy calculation</li> <li><code>relaxation</code> : Stores all steps of a structure geometry optimization</li> <li><code>nudged_elastic_band</code> : Stores all results from trajectory calculations</li> <li><code>dynamics</code> : Stores all steps of a molecular dynamics simulation</li> <li><code>calculation_nested</code> : A special type of calculation that involves running a workflow made of smaller workflows</li> </ul>"},{"location":"full_guides/database/custom_tables/#custom-table-creation","title":"Custom Table Creation","text":"<p>To create a custom table, follow these steps:</p> <ol> <li>Define the lower-level tables and data types used to create your new table</li> <li>Register the new table to your database</li> <li>Save data to your new table</li> </ol> <p>All classes in this module are abstract and are primarily used as mix-ins. Each class will contain details on its specific use, but when combining multiple types, you can do the following:</p> <pre><code>from simmate.database.base_data_types import (\n    table_column,\n    Structure,\n    Thermodynamics,\n)\n\n# Inherit from all the types you'd like to store data on. All of the columns\n# defined in each of these types will be incorporated into your table.\nclass MyCustomTable(Structure, Thermodynamics):\n\n    # ----- Table columns -----\n\n    # Add any custom columns you'd like.\n    # These follow the types supported by Django.\n\n    # This custom field will be required and must be supplied at creation\n    custom_column_01 = table_column.IntegerField()\n\n    # This column we say is allowed to be empty. This is often needed if you\n    # create an entry to start a calculation and then fill in data after a\n    # it completes.\n    custom_column_02 = table_column.FloatField(null=True, blank=True)\n\n    # ----- Extra features -----\n\n    # If you are not using the `Calculation` mix-in, you'll have to specify\n    # which app this table is associated with. To determine what you set here,\n    # you should have completed the advanced simmate tutorials (08-09).\n    class Meta:\n        app_label = \"my_custom_app\"\n\n    # (OPTIONAL) Define the \"raw data\" for your table. This is required if \n    # you'd like to use the `to_archive` method. Fields from the mix-in \n    # will automatically be added.\n    archive_fields = [\n        \"custom_column_01\",\n        \"custom_column_02\",\n    ]\n\n    # (OPTIONAL) Define how you would like data to be accessible in the REST \n    # API from the website server.\n    api_filters = {\n        \"custom_column_01\": [\"range\"],\n        \"custom_column_02\": [\"range\"],\n    }\n</code></pre> <p>Warning</p> <p>Unless you are contributing to Simmate's source code, defining a new table does NOT automatically register it to your database. To do this, you must follow along with our custom workflows guides.</p>"},{"location":"full_guides/database/custom_tables/#data-loading","title":"Data Loading","text":"<p>Once your table is created and registered, you can use the <code>from_toolkit</code> method to create and save your data to the database. Note, the information you pass to this method is entirely dependent on what you inherit from and define above.</p> <pre><code>from my.example.project import MyCustomTable\n\nnew_row = MyCustomTable.from_toolkit(\n    # Because we inherited from Structure, we must provide structure\n    structure=new_structure,  // provide a ToolkitStructure here\n    # \n    # All tables can optionally include a source too.\n    source=\"made by jacksund\",\n    #\n    # Because we inherited from Thermodynamics, we must provide energy\n    energy=-5.432,\n    #\n    # Our custom fields can also be added\n    custom_column_01=1234,\n    custom_column_02=3.14159,\n)\n\nnew_row.save()\n</code></pre>"},{"location":"full_guides/database/custom_tables/#column-updating","title":"Column Updating","text":"<p>To modify a row, you can load it from your database, update the column, and then resave. Note, there are many more ways to do this, so consult the Django documentation for advanced usage.</p> <pre><code>from my.example.project import MyCustomTable\n\nmy_row = MyCustomTable.objects.get(id=1)\n\nmy_row.custom_column_01 = 4321\n\nmy_row.save()\n</code></pre>"},{"location":"full_guides/database/notes/","title":"Notes","text":"<p>&lt;&lt; _register_calc &gt;&gt; from_run_context from_toolkit</p> <p>&lt;&lt; _update_database_with_results &gt;&gt;  This function retrieves from _register_calc and includes the following methods: - update_database_from_results - update_from_results     - update_from_toolkit         - from_toolkit(as_dict=True)     - update_from_directory         - from_directory(as_dict=True)             - from_vasp_directory(as_dict=True) ---&gt; Note: Unexpected as_dict                 - from_vasp_run(as_dict=True)         - update_from_toolkit()             - from_toolkit(as_dict=True)</p> <p>&lt;&lt; load_completed_calc &gt;&gt; This function includes the following methods: - from_toolkit - from_directory     - from_vasp_directory         - from_vasp_run</p>"},{"location":"full_guides/database/overview/","title":"Simmate Database Module","text":"<p>This module provides tools for defining and managing your database.</p> <p>If you're new to this, make sure you've gone through our database tutorial.</p> <p>The module includes the following submodules:</p> <ul> <li><code>base_data_types</code> : Fundamental mix-ins for creating new tables</li> <li><code>workflow_results</code> : A set of result tables for <code>simmate.workflows</code></li> <li><code>prototypes</code> : Tables that hold prototype structures</li> <li><code>third_parties</code> : Tables derived from external sources (like Materials Project)</li> </ul> <p>In addition, this module includes an extra file:</p> <ul> <li><code>connect</code>: This file sets up the database and installed apps (in other words, it configures Django)</li> </ul>"},{"location":"full_guides/database/third_party_data/","title":"Accessing Third-party Data","text":"<p>This module simplifies the process of downloading data from external providers and storing it in your local database.</p> <p>Please be aware that this data is NOT provided by the Simmate team. The providers are separate entities and should be properly credited. All data is subject to the respective provider's terms and conditions.</p> <p>We currently support data from these providers:</p> <ul> <li> COD (Crystallography Open Database)</li> <li> JARVIS (Joint Automated Repository for Various Integrated Simulations)</li> <li> Materials Project</li> <li> OQMD (Open Quantum Materials Database)</li> </ul> <p>We have also configured the following provider, but are still awaiting permission to redistribute their data:</p> <ul> <li> AFLOW (Automatic FLOW for Materials Discovery)</li> </ul> <p>Tip</p> <p>If you're interested in making your data accessible via Simmate, please refer to the Contributing data module. We welcome contributions of any size! The <code>for_providers</code> module provides more information on the benefits of contributing and how to package your data.</p>"},{"location":"full_guides/database/third_party_data/#downloading-data","title":"Downloading Data","text":"<p>Before proceeding, make sure you've completed our introductory tutorial on downloading data from these providers. We use <code>MatprojStructure</code> as an example, but the same procedure applies to all other tables in this module.</p> <p>WARNING: The initial loading of the data archive can be time-consuming. We suggest running this process overnight. Once completed, we recommend backing up your database by duplicating your ~/simmate/my_env-database.sqlite3 file to avoid repeating this lengthy process.</p> <p>To download all data into your database:</p> <pre><code>simmate database load-remote-archives\n</code></pre> <p>Or in Python, you can download a specific table:</p> <pre><code>from simmate.apps.materials_project.models import MatprojStructure\n\n# This process can take &gt;1 hour for some providers. You can\n# add `parallel=True` to expedite this process, but exercise caution when \n# parallelizing with SQLite (the default backend). We recommend \n# avoiding the use of parallel=True, and instead running\n# this line overnight.\nMatprojStructure.load_remote_archive()\n\n# Remember to cite the provider if you use their data!\nMatprojStructure.source_doi\n</code></pre>"},{"location":"full_guides/database/third_party_data/#updating-energy-fields","title":"Updating Energy Fields","text":"<p>Some database providers offer calculated energy, which can be used to update stability information:</p> <pre><code># updates ALL chemical systems.\n# This process can take over an hour for some providers. Consider running \n# this overnight along with your call to load_remote_archive.\nMatprojStructure.update_all_stabilities()\n\n# updates ONE chemical system\n# Use this if you need to quickly update a specific system\nMatprojStructure.update_chemical_system_stabilities(\"Y-C-F\")\n</code></pre>"},{"location":"full_guides/database/third_party_data/#alternative-options","title":"Alternative Options","text":"<p>This module can be used as an alternative or in addition to the following codes:</p> <ul> <li>MPContribs</li> <li>matminer.data_retrieval</li> <li>pymatgen.ext</li> <li>OPTIMADE APIs</li> </ul> <p>Unlike alternatives that query external APIs and load data into memory, this module stores data locally for quick loading in future Python sessions. This method ensures data stability (i.e., no unexpected changes in your source data) and fast loading, which is especially useful for high-throughput studies.</p>"},{"location":"full_guides/database/workflow_data/","title":"Accessing Workflow Data","text":"<p>This module, akin to the <code>simmate.workflows</code> module, organizes all database tables related to workflows and groups them by application for convenient access.</p>"},{"location":"full_guides/database/workflow_data/#retrieving-results","title":"Retrieving Results","text":"<p>The beginner tutorials offer guidance on running workflows and fetching their results. Here's a brief summary:</p> <pre><code>from simmate.workflows.static_energy import mit_workflow\n\n# Runs the workflow and returns a status\nstatus = mit_workflow.run(structure=...)\n\n# Gives the DatabaseTable where ALL results are stored\nmit_workflow.database_table\n</code></pre> <p>You can also directly connect to a table like this...</p> <pre><code># Sets up connection to the database\nfrom simmate.database import connect\n\nfrom simmate.database.workflow_results import MITStaticEnergy\n\n# NOTE: MITStaticEnergy here is the same as database_table in the previous codeblock.\n# These are just two different ways of accessing it.\nMITStaticEnergy.objects.filter(...)\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/overview/","title":"Simmate Toolkit Overview","text":"<p>Danger</p> <p>The Simmate toolkit is still in early development and not ready for use. We therefore keep our toolkit guides hidden for the time being.</p> <p>Stick to PyMatGen and our \"PyMatgen Help\" section for now.</p>"},{"location":"full_guides/toolkit/crystal_structures/overview/#about","title":"About","text":"<p>The <code>Simmate Toolkit</code> serves as an alternative to pymatgen, ase, and other Python packages for cheminformatics.</p> <p>Our toolkit is the product of...</p> <ul> <li> Incorporating features from other toolkits (e.g., wrapping PyMatGen or MatMiner functions)</li> <li> Creating more Pythonic and user-friendly APIs</li> <li> Adding integrations with databases and workflows </li> </ul> <p>Our toolkit is \"batteries-included\", meaning it includes many features typically used in large projects. As a result, it requires a larger installation (i.e., more dependencies). However, this also means that larger projects can benefit significantly from using our toolkit instead of building features from scratch.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/","title":"Structure Featurizers","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#overview","title":"Overview","text":"<p>Featurizing structures involves generating properties and information about each structure, such as the number of elements, molar mass, and metallic character. These features are crucial for exploring and analyzing data, identifying trends, and training machine learning or artificial intelligence models. The <code>Featurizer</code> base class helps optimize this process.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#fingerprints","title":"Fingerprints","text":"<p>Fingerprints are a unique type of featurizer that generate a 1D array of numerical values for each structure. Each value represents a specific feature or property of the structure. Fingerprints are entirely numerical, making them suitable for mathematical applications without requiring additional processing.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#basic-api-vs-featurizer-api","title":"Basic API vs. Featurizer API","text":"<p>The <code>Featurizer</code> API and the single-structure API can both be used to calculate a list of properties. The choice between the two depends on your coding style preference and the scale of your project. The <code>Featurizer</code> API offers parallelization, which can be beneficial for large-scale projects.</p> <p>Single Structure (\"Basic\") API: <pre><code>my_final_props = {\n    \"num_elements\": [s.num_elements for s in input_structures],\n    \"molar_mass\": [s.molar_mass for s in input_structures],\n    \"metallic_character\": [s.metallic_character for s in input_structures],\n}\n</code></pre></p> <p><code>Featurizer</code> API: <pre><code>from simmate.toolkit.featurizers import PropertyGrabber\n\nmy_final_props = PropertyGrabber.featurize_many(\n    structures=input_structures,\n    properties=[\"num_rings\", \"num_stereocenters\", \"molecular_weight\"],\n    parallel=True,  # this is the key reason you'd want to use a Featurizer class!\n)\n</code></pre></p> <p>Tip</p> <p>Both APIs yield the same result. The main difference is that the <code>Featurizer</code> API can use Dask for parallelization when <code>parallel=True</code>. If feature generation takes more than 15 minutes for all structures, we recommend using the <code>Featurizer</code> API. This is typically the case when working with datasets of over 1 million structures.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#usage-guide","title":"Usage Guide","text":"<p>All classes that inherit from the <code>Featurizer</code> class can be used in the same way. This guide uses the <code>CrytalnnFingerprint</code> as an example, but you can substitute it with any supported featurizer.</p>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#available-featurizers","title":"Available Featurizers","text":"<p>The <code>toolkit.featurizers</code> module contains all available featurizers, including:</p> <ul> <li><code>CrytalnnFingerprint</code></li> <li><code>example....</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#serial-use","title":"Serial Use","text":"<p>You can featurize molecules one at a time using either the <code>featurize</code> or <code>featurize_many(parallel=False)</code> methods:</p> <pre><code>from simmate.toolkit.featurizers import CrytalnnFingerprint\n\n# OPTION 1\nfor structure in input_structures:\n    fingerprint = CrytalnnFingerprint.featurize(\n        structure=structure\n    )\n\n# OPTION 2\nfingerprints = CrytalnnFingerprint.featurize_many(\n    structure=input_structures,\n    parallel=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#parallel-use","title":"Parallel Use","text":"<p>Enable parallelization by using the <code>featurize_many(parallel=True)</code> method:</p> <pre><code>from simmate.toolkit.featurizers import CrytalnnFingerprint\n\nfingerprints = CrytalnnFingerprint.featurize_many(\n    structure=input_structures,\n    parallel=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/many_structures/featurizers/#adding-a-new-featurizer","title":"Adding a New Featurizer","text":"<p>To add a new featurizer, you need to:</p> <ol> <li>Inherit from the <code>Featurizer</code> base class</li> <li>Define a <code>featurize</code> method (can be a <code>@classmethod</code> or <code>@staticmethod</code>) that accepts <code>structure</code> as a kwarg.</li> </ol> <p>The <code>Featurizer</code> will then handle how <code>featurize_many</code> and other features behave.</p> <p>For example:</p> <pre><code>from simmate.toolkit import Structure\nfrom simmate.toolkit.featurizers.base import Featurizer\n\n\nclass Example(Featurizer):\n    \"\"\"\n    An example featurizer\n    \"\"\"\n\n    @staticmethod\n    def featurize(\n        molecule: Structure,\n        # feel free to add any extra kwargs you'd like\n        example_setting: float = 0.123,\n    ):\n        # use the molecule to generate your feature(s)\n        return calculation_property\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/","title":"PyMatGen Compositions","text":"<p>Important</p> <p>This page provides a concise list of available properties and methods, grouped by topic. </p> <p>Refer to Pymatgen's API docs for detailed descriptions.</p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#introduction","title":"Introduction","text":"<p>To access the <code>Composition</code> objects from a <code>Structure</code>:</p> <pre><code>comp = structure.composition\n</code></pre> <p>The <code>composition</code> property is also available for  <code>Molecule</code>, <code>Cluster</code>, <code>Interface</code>, and more.</p> <p>Warning</p> <p>a <code>Composition</code> object can come from a variety of sources. For example, a composition can be for an entire <code>Structure</code> OR just a single chemical component (such as a <code>Molecule</code>, <code>Cluster</code>, <code>Interface</code>, etc.).</p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#composition-loading","title":"Composition Loading","text":"<ul> <li><code>from_dict</code></li> <li><code>from_weight_dict</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#composition-exporting","title":"Composition Exporting","text":"<ul> <li><code>as_dict</code></li> <li><code>copy</code></li> <li><code>to_data_dict</code></li> <li><code>to_html_string</code></li> <li><code>to_json</code></li> <li><code>to_latex_string</code></li> <li><code>to_pretty_string</code></li> <li><code>to_reduced_dict</code></li> <li><code>to_unicode_string</code></li> <li><code>to_weight_dict</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#basic-properties","title":"Basic Properties","text":"<ul> <li><code>alphabetical_formula</code></li> <li><code>anonymized_formula</code></li> <li><code>average_electroneg</code></li> <li><code>chemical_system</code></li> <li><code>element_composition</code></li> <li><code>elements</code></li> <li><code>formula</code></li> <li><code>fractional_composition</code></li> <li><code>iupac_formula</code></li> <li><code>hill_formula</code></li> <li><code>reduced_composition</code></li> <li><code>reduced_formula</code></li> <li><code>special_formulas</code></li> <li><code>total_electrons</code></li> <li><code>values</code></li> <li><code>weight</code></li> <li><code>num_atoms</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#analysis-methods","title":"Analysis Methods","text":"<ul> <li><code>amount_tolerance</code></li> <li><code>almost_equals</code></li> <li><code>contains_element_type</code></li> <li><code>is_element</code></li> <li><code>valid</code></li> <li><code>get_atomic_fraction</code></li> <li><code>get_el_amt_dict</code></li> <li><code>get_integer_formula_and_factor</code></li> <li><code>get_reduced_composition_and_factor</code></li> <li><code>get_reduced_formula_and_factor</code></li> <li><code>get_wt_fraction</code></li> <li><code>oxi_prob</code></li> <li><code>oxi_state_guesses</code></li> <li><code>ranked_compositions_from_indeterminate_formula</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#dict-like-utils","title":"Dict-like Utils","text":"<ul> <li><code>get</code></li> <li><code>items</code></li> <li><code>keys</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#charge-utils","title":"Charge Utils","text":"<ul> <li><code>add_charges_from_oxi_state_guesses</code></li> <li><code>allow_negative</code></li> <li><code>remove_charges</code></li> <li><code>replace</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/composition/#json-utils","title":"JSON Utils","text":"<ul> <li><code>unsafe_hash</code></li> <li><code>validate_monty_v1</code></li> <li><code>validate_monty_v2</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/","title":"PyMatGen Lattices","text":"<p>Important</p> <p>This page provides a concise list of available properties and methods, grouped by topic. </p> <p>Refer to Pymatgen's API docs for detailed descriptions.</p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#introduction","title":"Introduction","text":"<p>To access the <code>Lattice</code> object from a <code>Structure</code>:</p> <pre><code>lattice = structure.lattice  \n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#lattice-loading","title":"Lattice Loading","text":""},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#basic","title":"basic","text":"<ul> <li><code>from_dict</code></li> <li><code>from_parameters</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#constructors","title":"constructors","text":"<ul> <li><code>cubic</code></li> <li><code>hexagonal</code></li> <li><code>monoclinic</code></li> <li><code>orthorhombic</code></li> <li><code>rhombohedral</code></li> <li><code>tetragonal</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#lattice-exporting","title":"Lattice Exporting","text":"<ul> <li><code>as_dict</code></li> <li><code>copy</code></li> <li><code>to_json</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#basic-properties","title":"Basic Properties","text":""},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#vectors","title":"vectors","text":"<ul> <li><code>a</code></li> <li><code>b</code></li> <li><code>c</code></li> <li><code>abc</code></li> <li><code>lengths</code></li> <li><code>pbc</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#angles","title":"angles","text":"<ul> <li><code>alpha</code></li> <li><code>beta</code></li> <li><code>gamma</code></li> <li><code>angles</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#full-lattice","title":"full lattice","text":"<ul> <li><code>matrix</code></li> <li><code>volume</code></li> <li><code>is_3d_periodic</code></li> <li><code>is_hexagonal</code></li> <li><code>is_orthogonal</code></li> <li><code>parameters</code></li> <li><code>reciprocal_lattice</code></li> <li><code>reciprocal_lattice_crystallographic</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#measurements","title":"Measurements","text":"<ul> <li><code>d_hkl</code></li> <li><code>dot</code></li> <li><code>norm</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#transforms","title":"Transforms","text":"<ul> <li><code>inv_matrix</code></li> <li><code>lll_inverse</code></li> <li><code>lll_mapping</code></li> <li><code>lll_matrix</code></li> <li><code>metric_tensor</code></li> <li><code>scale</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#analysis-methods","title":"Analysis Methods","text":"<ul> <li><code>get_all_distances</code></li> <li><code>get_brillouin_zone</code></li> <li><code>get_cartesian_coords</code></li> <li><code>get_distance_and_image</code></li> <li><code>get_frac_coords_from_lll</code></li> <li><code>get_fractional_coords</code></li> <li><code>get_lll_frac_coords</code></li> <li><code>get_lll_reduced_lattice</code></li> <li><code>get_miller_index_from_coords</code></li> <li><code>get_niggli_reduced_lattice</code></li> <li><code>get_points_in_sphere</code></li> <li><code>get_points_in_sphere_old</code></li> <li><code>get_points_in_sphere_py</code></li> <li><code>get_recp_symmetry_operation</code></li> <li><code>get_vector_along_lattice_directions</code></li> <li><code>get_wigner_seitz_cell</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#inter-lattice-utils","title":"Inter-lattice Utils","text":"<ul> <li><code>find_all_mappings</code></li> <li><code>find_mapping</code></li> <li><code>selling_dist</code></li> <li><code>selling_vector</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/lattice/#json-utils","title":"JSON Utils","text":"<ul> <li><code>unsafe_hash</code></li> <li><code>validate_monty_v1</code></li> <li><code>validate_monty_v2</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/","title":"PyMatGen Sites &amp; Species","text":"<p>Important</p> <p>This page provides a concise list of available properties and methods, grouped by topic. </p> <p>Refer to Pymatgen's API docs for detailed descriptions.</p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#introduction","title":"Introduction","text":"<p>Make sure you understand the difference between object classifications:</p> <ul> <li><code>Element</code>: The fundamental chemical component (e.g., Na or Cl).</li> <li><code>Species</code>: A singular chemical entity, encompassing an <code>Element</code>, <code>Ion</code>, <code>Molecule</code>, or <code>Cluster</code>. Essentially, a species can be an individual element or a set of associated elements. Additionally, it may contain extra information about the element(s), such as charge and bonding.</li> <li><code>Site</code>: A <code>Species</code> with xyz coordinates in free space (without a lattice). It includes orientation information if multiple atoms are present in the <code>Species</code>.</li> <li><code>PeriodicSite</code>: A <code>Species</code> with xyz coordinates relative to an associated lattice. This also includes orientation details if multiple atoms are part of the <code>Species</code>.</li> </ul> <p>Example</p> <p>(basic single crystals) </p> <p>If your <code>Structure</code> object represents the unit cell for NaCl, it contains two <code>PeriodicSites</code>: one for <code>Na</code> and one for <code>Cl</code>, both of type <code>Element</code>.</p> <p>Optionally, you can replace the <code>Element</code> types with <code>Ion</code> types: <code>Na+</code> and <code>Cl-</code>. </p> <p>Since these are single-atom <code>Species</code>, there's no need to worry about orientation (i.e., rotating the atom has no effect).</p> <p>Example</p> <p>(advanced molecular crystals and beyond) </p> <p>If you have a crystal structure with ethanol intercalated between graphite, your <code>Structure</code> object has several ways to define its <code>PeriodicSites</code>.</p> <ol> <li>each atom is its own <code>PeriodicSite</code>, represented by an <code>Element</code> type</li> <li>there are two <code>PeriodicSite</code> types: (i) a <code>Molecule</code> type for all ethanol molecules and (ii) an <code>Element</code> type for all carbons part of the graphite.</li> <li>... and more! Choose what makes sense for your application. NOTE: Options 1 and 2 should cover the majority of cases.</li> </ol>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#periodic-sites","title":"Periodic Sites","text":""},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#access","title":"Access","text":"<p>To access the <code>PeriodicSite</code> objects from a <code>Structure</code>:</p> <pre><code># OPTION 1\nsites = structure.sites\n\n# OPTION 2\nfor site in structure:\n    #... do something\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#loadingexporting","title":"Loading/Exporting","text":"<ul> <li><code>as_dict</code></li> <li><code>from_dict</code></li> <li><code>to_json</code></li> <li><code>to_unit_cell</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#position","title":"Position","text":"<ul> <li><code>x</code></li> <li><code>y</code></li> <li><code>z</code></li> <li><code>a</code></li> <li><code>b</code></li> <li><code>c</code></li> <li><code>coords</code></li> <li><code>frac_coords</code></li> <li><code>position_atol</code></li> <li><code>lattice</code> (matches between all sites in <code>Structure</code>)</li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#basic-properties","title":"Basic Properties","text":"<ul> <li><code>is_ordered</code></li> <li><code>is_periodic_image</code></li> <li><code>properties</code></li> <li><code>specie</code></li> <li><code>species</code></li> <li><code>species_string</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#measurements","title":"Measurements","text":"<p><code>distance</code> <code>distance_and_image</code> <code>distance_and_image_from_frac_coords</code> <code>distance_from_point</code></p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#json-utils","title":"JSON utils","text":"<p><code>unsafe_hash</code> <code>validate_monty_v1</code> <code>validate_monty_v2</code></p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/sites/#under-dev-sections","title":"(under dev sections)","text":"<ul> <li><code>Element</code></li> <li><code>Species</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/","title":"PyMatGen Structures","text":"<p>Important</p> <p>This page provides a concise list of available properties and methods, grouped by topic. </p> <p>Refer to Pymatgen's API docs for detailed descriptions.</p>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#molecole-loading","title":"Molecole Loading","text":"<ul> <li><code>from_dict</code></li> <li><code>from_file</code></li> <li><code>from_magnetic_spacegroup</code></li> <li><code>from_prototype</code></li> <li><code>from_sites</code></li> <li><code>from_spacegroup</code></li> <li><code>from_str</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#molecole-exporting","title":"Molecole Exporting","text":"<ul> <li><code>as_dataframe</code></li> <li><code>as_dict</code></li> <li><code>copy</code></li> <li><code>to</code></li> <li><code>to_json</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#key-attributes","title":"Key Attributes","text":"<ul> <li><code>composition</code></li> <li><code>lattice</code></li> <li><code>sites</code></li> <li><code>species</code></li> <li><code>species_and_occu</code></li> <li><code>types_of_specie</code></li> <li><code>types_of_species</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#basic-properties","title":"Basic Properties","text":"<ul> <li><code>site_properties</code></li> <li><code>atomic_numbers</code></li> <li><code>cart_coords</code></li> <li><code>charge</code></li> <li><code>density</code></li> <li><code>distance_matrix</code></li> <li><code>formula</code></li> <li><code>frac_coords</code></li> <li><code>is_3d_periodic</code></li> <li><code>is_ordered</code></li> <li><code>is_valid</code></li> <li><code>num_sites</code></li> <li><code>pbc</code></li> <li><code>symbol_set</code></li> <li><code>volume</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#inter-structure-utils","title":"Inter-structure Utils","text":"<ul> <li><code>interpolate</code></li> <li><code>matches</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#structure-modification","title":"Structure Modification","text":""},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#composition-transforms","title":"Composition Transforms","text":"<ul> <li><code>substitute</code></li> <li><code>replace</code></li> <li><code>replace_species</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#cell-transforms","title":"Cell Transforms","text":"<ul> <li><code>apply_operation</code></li> <li><code>scale_lattice</code></li> <li><code>apply_strain</code></li> <li><code>make_supercell</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#site-transforms","title":"Site Transforms","text":"<ul> <li><code>merge_sites</code></li> <li><code>rotate_sites</code></li> <li><code>translate_sites</code></li> <li><code>perturb</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#charges","title":"Charges","text":"<ul> <li><code>set_charge</code></li> <li><code>unset_charge</code></li> <li><code>add_oxidation_state_by_element</code></li> <li><code>add_oxidation_state_by_guess</code></li> <li><code>add_oxidation_state_by_site</code></li> <li><code>add_site_property</code></li> <li><code>add_spin_by_element</code></li> <li><code>add_spin_by_site</code></li> <li><code>remove_oxidation_states</code></li> <li><code>remove_site_property</code></li> <li><code>remove_sites</code></li> <li><code>remove_species</code></li> <li><code>remove_spin</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#list-like-api","title":"List-like API","text":"<ul> <li><code>append</code></li> <li><code>count</code></li> <li><code>extend</code></li> <li><code>index</code></li> <li><code>insert</code></li> <li><code>ntypesp</code></li> <li><code>pop</code></li> <li><code>remove</code></li> <li><code>reverse</code></li> <li><code>sort</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#other","title":"Other","text":"<ul> <li><code>relax</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#analysis-methods","title":"Analysis Methods","text":"<ul> <li><code>extract_cluster</code></li> <li><code>group_by_types</code></li> <li><code>get_all_neighbors</code></li> <li><code>get_all_neighbors_old</code></li> <li><code>get_all_neighbors_py</code></li> <li><code>get_angle</code></li> <li><code>get_dihedral</code></li> <li><code>get_distance</code></li> <li><code>get_miller_index_from_site_indexes</code></li> <li><code>get_neighbor_list</code></li> <li><code>get_neighbors</code></li> <li><code>get_neighbors_in_shell</code></li> <li><code>get_neighbors_old</code></li> <li><code>get_orderings</code></li> <li><code>get_primitive_structure</code></li> <li><code>get_reduced_structure</code></li> <li><code>get_sites_in_sphere</code></li> <li><code>get_sorted_structure</code></li> <li><code>get_space_group_info</code></li> <li><code>get_symmetric_neighbor_list</code></li> <li><code>indices_from_symbol</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/pymatgen/structure/#json-utils","title":"JSON Utils","text":"<ul> <li><code>unsafe_hash</code></li> <li><code>validate_monty_v1</code></li> <li><code>validate_monty_v2</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/analyses/","title":"Common Analyses","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p> <p>Important</p> <p>This page provides a concise list of available features, grouped by function. Detailed descriptions of each property can be found in the <code>API</code> section.</p> <p>Tip</p> <p>If you're searching for analyses such as clustering, similarity, or chemspace mapping, you'll find them in the \"many stuctures\" section. This page is dedicated to single-structure analysis.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/analyses/#overview","title":"Overview","text":"<p>Most analyses are implemented as Python methods, accepting a range of input arguments and formats.</p> <p>For instance, you can call a method like this:</p> <pre><code>...\n</code></pre> <p>It's recommended to review the documentation for each method before using it. This page serves as a quick reference to help you identify available methods.</p> <ul> <li><code>get_example1</code></li> <li><code>get_example2</code></li> </ul>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/cleaning/","title":"Structure Cleaning &amp; Preparation","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/cleaning/#duplicate-atom-removal","title":"Duplicate Atom Removal","text":""},{"location":"full_guides/toolkit/crystal_structures/single_structure/cleaning/#make-mostly-cubic-lll-reduction","title":"Make Mostly Cubic (LLL-reduction)","text":""},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/","title":"Exporting Structures","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/#introduction","title":"Introduction","text":"<p>After loading a molecule, you can convert it to a different format using a <code>to_</code> method of <code>Structure</code>. </p> <p>For instance, use <code>to_cif</code> to output a CIF, use <code>to_poscar</code> for a POSCAR output, and use <code>to_pymatgen</code> for a PyMatGen object.</p> <p>Thus, file format conversion typically involves two steps:</p> <ol> <li>Load using a <code>from_*</code> method</li> <li>Export using a <code>to_*</code> method</li> </ol> <pre><code>from simmate.toolkit import Structure\n\n# step 1: LOAD\nstructure = Structure.from_cif_file(\"example.cif\")\n\n# step 2: EXPORT\nstructure.to_poscar_file(\"POSCAR\")\n</code></pre> <p>Note</p> <p>For exporting numerous structures or handling large files, refer to our \"Many Structures\" section. </p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/#basic-exportation","title":"Basic Exportation","text":""},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/#files","title":"Files","text":"<p>File-based outputs accept a filename as a string or a <code>pathlib.Path</code> object.</p> <pre><code>structure = Structure.to_cif_file(\"example.cif\")\n</code></pre> TYPE METHOD CIF <code>to_cif_file</code> POSCAR (&amp; CONTCAR) <code>to_poscar_file</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for exporting to a string, as detailed in the section below. For instance, <code>to_cif</code> outputs a string, while <code>to_cif_file</code> writes a <code>.cif</code> file.</p> <p>Warning</p> <p>Writing numerous files (with many structures in each) can be slow using these methods. Refer to the \"many structures\" section for optimized writing of thousands or millions of structures.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/#raw-text-strings","title":"Raw Text / Strings","text":"<p>Instead of writing to a file, you can also obtain the converted format as a python variable (string) for use elsewhere.</p> <pre><code>poscar_str = structure.to_poscar()\n</code></pre> TYPE METHOD CIF <code>to_cif</code> POSCAR (&amp; CONTCAR) <code>to_poscar</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for exporting directly to a file, as detailed in the section above. For instance, <code>to_cif</code> outputs a string, while <code>to_cif_file</code> writes a <code>.cif</code> file.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/exporting/#python-objects","title":"Python Objects","text":"<p>Methods are available to convert to other popular python objects, such as those from RDKit.</p> <pre><code>molecule.to_rdkit()\n</code></pre> TYPE METHOD Python <code>dict</code> <code>to_dict</code> Pandas <code>DataFrame</code> <code>to_dataframe</code> PyMatGen <code>Structure</code> object <code>to_pymatgen</code> ASE <code>Atoms</code> object <code>to_ase</code>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/","title":"Loading Structures","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#introduction","title":"Introduction","text":"<p>To load a structure, call a <code>from_</code> method of <code>Structure</code>. </p> <p>For instance, <code>from_cif</code> for a CIF input, <code>from_poscar</code> for a POSCAR input, and <code>from_pymatgen</code> for a PyMatGen object. Choose the method that corresponds to your input type, or use the <code>from_dynamic</code> strategy if you're unsure or have a variety of input types.</p> <p>Tip</p> <p><code>from_dynamic</code> is the simplest and most convenient method, but it may not always work! If you know your structure's format, use the specific method for it.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#dynamic-loading","title":"Dynamic Loading","text":"<p>Dynamic loading examines your input and determines how to convert it into a <code>Structure</code> object. It performs checks and then calls one of the methods detailed on this page.</p> <pre><code>from simmate.toolkit import Structure\n\n# try loading from a variety of formats\ninput_01 = \"example.cif\"\ninput_02 = \"POSCAR\" \ninput_03 = {\n    \"lattice\": [\n        [3.48543651, 0.0, 2.01231771],\n        [1.16181217, 3.28610106, 2.01231771],\n        [0.0, 0.0, 4.02463542],\n    ],\n    \"species\": [\"Na\", \"Cl\"],\n    \"coords\": [\n        [0.0000, 0.0000, 0.0000],\n        [0.5000, 0.5000, 0.5000],\n    ],\n}\n\n# `from_dynamic` will determine the format and convert it\nfor new_input in [input_01, input_02, input_03]\n    structure = Structure.from_dynamic(new_input)\n</code></pre> <p>Note</p> <p><code>from_dynamic</code> also checks if we already have a <code>Structure</code> object and returns it if we do.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#basic-loading","title":"Basic Loading","text":""},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#files","title":"Files","text":"<p>File-based inputs accept a filename as a string or a <code>pathlib.Path</code> object.</p> <pre><code>from simmate.toolkit import Structure\n\nstructure = Structure.from_cif_file(\"example.sdf\")\n</code></pre> TYPE METHOD (dynamic loading) <code>from_file</code> CIF <code>from_cif_file</code> CSSR <code>from_cssr_file</code> Netcdf <code>from_cdf_file</code> POSCAR (&amp; CONTCAR) <code>from_poscar_file</code> CHGCAR <code>from_chgcar_file</code> LOCPOT <code>from_locpot_file</code> vasprun.xml <code>from_vasprun_file</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for loading this format directly from text/str, detailed in the section below. For instance, <code>from_cif</code> takes a string, while <code>from_cif_file</code> takes a <code>.cif</code> file.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#raw-text-strings","title":"Raw text / strings","text":"<p>You can read a python string variable directly. These methods are primarily used for testing and debugging.</p> <pre><code>from simmate.toolkit import Structure\n\nposcar_str = \"\"\"\nNa1 Cl1\n1.0\n3.485437 0.000000 2.012318\n1.161812 3.286101 2.012318\n0.000000 0.000000 4.024635\nNa Cl\n1 1\ndirect\n0.000000 0.000000 0.000000 Na\n0.500000 0.500000 0.500000 Cl\n\"\"\"\n\nstructure = Structure.from_poscar(poscar_str)\n</code></pre> TYPE METHOD CIF <code>from_cif</code> CSSR <code>from_cssr</code> Netcdf <code>from_cdf</code> POSCAR (&amp; CONTCAR) <code>from_poscar</code> CHGCAR <code>from_chgcar</code> LOCPOT <code>from_locpot</code> vasprun.xml <code>from_vasprun</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for loading this format directly from a file, detailed in the section above. For instance, <code>from_cif</code> takes a string, while <code>from_cif_file</code> takes a <code>.cif</code> file.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#python-objects","title":"Python Objects","text":"<p>Methods are available to convert other popular python objects, such as those from PyMatGen:</p> <pre><code>from simmate.toolkit import Structure\nfrom pymatgen import Structure as PmgStructure\n\n# CIF -&gt; PyMatGen -&gt; Simmate [[ NOT RECOMMENDED ]]\npmg_structure = PmgStructure.from_file(\"example.cif\")\nstructure = Structure.from_pymatgen(pmg_structure)\n\n# CIF -&gt; Simmate  [[ RECOMMENDED ]]\nstructure = Structure.from_file(\"example.cif\")\n</code></pre> TYPE METHOD PyMatGen <code>Structure</code> object <code>from_pymatgen</code> ASE <code>Atoms</code> object <code>from_ase</code>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#python-dictionaries","title":"Python Dictionaries","text":"<p>Warning</p> <p>Loading from python dictionaries is still in progress.</p> <p>For now, do the following:</p> <pre><code>from simmate.toolkit import Structure\n\ndata = {\n    \"lattice\": [\n        [3.48543651, 0.0, 2.01231771],\n        [1.16181217, 3.28610106, 2.01231771],\n        [0.0, 0.0, 4.02463542],\n    ],\n    \"species\": [\"Na\", \"Cl\"],\n    \"coords\": [\n        [0.0000, 0.0000, 0.0000],\n        [0.5000, 0.5000, 0.5000],\n    ],\n}\n\nstructure = Structure(**data)\n</code></pre>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/loading/#database-entries","title":"Database Entries","text":"<p>Warning</p> <p>Loading from database metadata is still in progress. Refer to our guides on Python ORM  to access datasets as <code>Structure</code> objects quickly.</p> <p>For example: <pre><code>from simmate.database import connect\nfrom simmate.apps.materials_project.models import MatprojStructure\n\nstructure_db = MatprojStructure.objects.get(id=123)\nstructure = structure_db.to_toolkit()\n</code></pre></p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/properties/","title":"Common properties","text":"<p>Danger</p> <p>The simmate toolkit is still in early development and not ready for use. Stick to the \"PyMatgen Help\" section for now.</p> <p>Important</p> <p>This page provides a concise list of available properties, grouped by function. Detailed descriptions of each property can be found in the <code>API</code> section.</p> <p>Tip</p> <p>If you're dealing with multiple structures, check out the \"Featurizers\" section for tips on enhancing speed and parallelization.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/properties/#overview","title":"Overview","text":"<p>The <code>Structure</code> class offers a wide range of accessible properties. </p> <p>You can access almost all properties like this:</p> <pre><code>n = structure.num_sites\n</code></pre> <p>Replace <code>num_sites</code> with any of the options below to explore further.</p>"},{"location":"full_guides/toolkit/crystal_structures/single_structure/properties/#todo","title":"TODO","text":""},{"location":"full_guides/toolkit/molecules/overview/","title":"Toolkit Overview","text":""},{"location":"full_guides/toolkit/molecules/overview/#about","title":"About","text":"<p>The <code>Simmate Toolkit</code> serves as an alternative to <code>RDkit</code>, <code>OpenEye-Toolkit</code>, and other Python packages for cheminformatics.</p> <p>Our toolkit is the product of...</p> <ul> <li> Incorporating features from other toolkits (e.g., wrapping an RDkit function)</li> <li> Creating more Pythonic and user-friendly APIs</li> <li> Adding optional integrations with databases and workflows </li> </ul> <p>Our toolkit is \"batteries-included\", meaning it includes many features typically used in large projects. As a result, it requires a larger installation (i.e., more dependencies). However, this also means that larger projects can benefit significantly from using our toolkit instead of building features from scratch with toolkits like RDkit.</p>"},{"location":"full_guides/toolkit/molecules/overview/#preview","title":"Preview","text":"<p>To understand how the Simmate Toolkit simplifies tasks, consider this script. The script...</p> <ol> <li>Reads an SDF file containing multiple molecules</li> <li>Removes all molecules with more than 3 stereocenters, more than 30 heavy atoms, and containing sodium (<code>Na</code>)</li> <li>Generates a list of InChI keys from the final set</li> </ol> <p>This script is less intuitive and less Pythonic for other toolkits, but it's straightforward and clean with Simmate:</p> simmate-toolkitrdkitoe-toolkit <pre><code>from simmate.toolkit import Molecule\n\n# STEP 1\nmolecules = Molecule.from_sdf_file(\"example.sdf\")\n\n# STEP 2\nmolecules_filtered = []\nfor molecule in molecules:\n    if molecule.num_stereocenters &gt; 3:\n        continue\n    if molecule.num_atoms_heavy &gt; 30:\n        continue\n    if \"Na\" in molecule.elements:\n        continue\n    molecules_filtered.append(molecule)\n\n# STEP 3\ninchi_keys = [m.to_inchi_key() for m in molecules_filtered]\n</code></pre> <pre><code>from rdkit import Chem\nfrom rdkit.Chem import FindMolChiralCenters, Descriptors\n\n# STEP 1\nmolecules = []\nwith Chem.SDMolSupplier(\"example.sdf\") as supplier:\nfor molecule in supplier:\n    if mol is None:\n        continue\n    molecules.append(molecule)\n\n# STEP 2\nmolecules_filtered = []\nfor molecule in molecules:\n\n    chiral_centers = FindMolChiralCenters(\n        molecule,\n        force=True,\n        includeUnassigned=True,\n        useLegacyImplementation=False,\n    )\n    if len(chiral_centers) &gt; 3:\n        continue\n\n    nheavy = Descriptors.HeavyAtomCount(molecule)\n    if nheavy &gt; 30:\n        continue\n\n    has_na = False  # false until proven otherwise\n    for atom in molecule.GetAtoms():\n        if atom.GetSymbol() == \"Na\":\n            has_na = True\n            break\n    if has_na:\n        continue\n\n    molecules_filtered.append(molecule)\n\n# STEP 3\ninchi_keys = [Chem.MolToInchiKey(m) for m in molecules_filtered]\n</code></pre> <pre><code>from openeye import oechem\nfrom openeye import oeiupac\n\n# STEP 1\nmolecules = []\nwith oechem.oemolistream(\"example.sdf\") as ifs:\n    for mol in ifs.GetOEMols():\n        if mol is None:\n            continue\n        molecules.append(mol)\n\n# STEP 2\nmolecules_filtered = []\nfor mol in molecules:\n\n    stereo_count = sum(1 for atom in mol.GetAtoms() if atom.IsChiral())\n    if stereo_count &gt; 3:\n        continue\n\n    heavy_atom_count = sum(\n        1 for atom in mol.GetAtoms() if atom.GetAtomicNum() &gt; 1\n    )\n    if heavy_atom_count &gt; 30:\n        continue\n\n    has_na = any(atom.GetAtomicNum() == 11 for atom in mol.GetAtoms())\n    if has_na:\n        continue\n\n    molecules_filtered.append(mol)\n\n# STEP 3\ninchi_keys = [oeiupac.OECreateInChIKey(m) for m in molecules_filtered]\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/","title":"Molecule Clustering","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#overview","title":"Overview","text":"<p>Molecule clustering is a three-step process:</p> <ol> <li>Generate a fingerprint for each molecule OR start with a pre-existing list of fingerprints</li> <li>Create a similarity matrix using these fingerprints</li> <li>Group molecules based on the similarity matrix</li> </ol> <p>The <code>ClusteringEngine</code> class manages these steps.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#basic-use-from_preset","title":"Basic Use (<code>from_preset</code>)","text":"<p>For most applications, you can use the \"recommended\" settings for clustering. These are stored in the <code>ClusteringEngine.from_preset</code> method.</p> <p>Presets are named using the format <code>[clustering method]-[similarity method]-[fingerprint method]</code>. Currently, we offer the following preset:</p> <ul> <li><code>butina-tanimoto-morgan</code></li> </ul> <p>Here's an example of clustering using default settings:</p> <pre><code>from simmate.toolkit.clustering import ClusteringEngine\n\nclusters = ClusteringEngine.from_preset(\n    molecules=[...],  // should be a list of Molecule objects\n    preset=\"butina-tanimoto-morgan\",\n)\n</code></pre> <p>Tip</p> <p>If you wish to customize parameters for clustering/similarity/fingerprint, consider using the \"advanced\" API below.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#advanced-use","title":"Advanced Use","text":"<p>For full control over molecule clustering, you need to select your methods &amp; parameters. This process uses the same base classes as the preset <code>butina-tanimoto-morgan</code>.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#1-choose-fingerprint-method","title":"1. Choose fingerprint method","text":"<p>Select any fingerprint method from the <code>simmate.toolkit.featurizers</code> module. You can also select any kwargs that the featurizer's <code>featurize_many</code> method accepts. Refer to the Featurizers section for all available featurizers and their kwarg options.</p> <p>Example: <pre><code>from simmate.toolkit.featurizers import MorganFingerprint\n\nfeaturizer_kwargs = dict(\n    radius=4,\n    nbits=2048,\n    parallel=True,\n)\n</code></pre></p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#2-choose-similarity-metric","title":"2. Choose similarity metric","text":"<p>Select any similarity metric from the <code>simmate.toolkit.similarity</code> module. You can also select any kwargs that the similarity's <code>get_similarity_matrix</code> method accepts. Refer to the Fingerprint Similarities/Distances section for all available similarity metrics and their kwarg options.</p> <p>Example: <pre><code>from simmate.toolkit.similarity import Tanimoto\n\nsimilarity_engine_kwargs = dict(\n    parallel=True,\n)\n</code></pre></p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#3-choose-clustering-method","title":"3. Choose clustering method","text":"<p>Select any clustering method from the <code>simmate.toolkit.clustering</code> module. You can also select any kwargs that <code>cluster_fingerprints</code> method accepts. Currently, we support the following clustering method:</p> <ul> <li><code>Butina</code></li> </ul> <p>Example: <pre><code>from simmate.toolkit.featurizers import Butina\n\nclustering_kwargs = dict(\n    similarity_cutoff=0.50,\n    reorder_after_new_cluster=True,\n    progress_bar=True,\n    flat_output=True,\n)\n</code></pre></p> <p>Note</p> <p>All clustering methods have a <code>cluster_molecules</code> and a <code>cluster_fingerprints</code> method. These methods are what we will be calling in our final scripts (below).</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#4-final-script","title":"4. Final script","text":"<p>Now that we have everything selected, let's put it together:</p> <pre><code>from simmate.toolkit.clustering import Butina\nfrom simmate.toolkit.featurizers import MorganFingerprint\nfrom simmate.toolkit.similarity import Tanimoto\n\nclusters = Butina.cluster_molecules(\n    molecules=[...],  // should be a list of Molecule objects\n    featurizer=MorganFingerprint,\n    featurizer_kwargs = dict(\n        radius=4,\n        nbits=2048,\n        parallel=True,\n    ),\n    similarity_engine=Tanimoto,\n    similarity_engine_kwargs = dict(\n        parallel=True,\n    ),\n    similarity_cutoff=0.50,\n    reorder_after_new_cluster=True,\n    progress_bar=True,\n    flat_output=True,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#extra-starting-from-fingerprints","title":"EXTRA: Starting from fingerprints","text":"<p>If you already have fingerprints and want to use those instead of <code>Molecule</code> objects, you can skip STEP 1 and replace <code>cluster_molecules</code> with the <code>cluster_fingerprints</code> method:</p> <pre><code>from simmate.toolkit.clustering import Butina\nfrom simmate.toolkit.featurizers import MorganFingerprint\nfrom simmate.toolkit.similarity import Tanimoto\n\nclusters = Butina.cluster_molecules(\n    fingerprints=[...],  // should be a list of fingerprints (1D array of floats)\n    similarity_engine=Tanimoto,\n    similarity_engine_kwargs = dict(\n        parallel=True,\n    ),\n    similarity_cutoff=0.50,\n    reorder_after_new_cluster=True,\n    progress_bar=True,\n    flat_output=True,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#adding-a-new-clustering-method","title":"Adding a New Clustering Method","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#standard-method","title":"Standard Method","text":"<p>All clustering methods must:</p> <ol> <li>Inherit from the <code>ClusteringEngine</code> base class</li> <li>Define a <code>cluster_similarity_matrix</code> method (can be a <code>@classmethod</code> or <code>@staticmethod</code>) that accepts the <code>similarity_matrix</code> as a kwarg.</li> </ol> <p>The <code>ClusteringEngine</code> will then manage how <code>cluster_molecules</code>, <code>cluster_fingerprints</code>, and other features behave.</p> <p>Example:</p> <pre><code>from simmate.toolkit.clustering.base import ClusteringEngine\nfrom simmate.toolkit.similarity.base import SimilarityEngine\n\n\nclass Example(ClusteringEngine):\n    \"\"\"\n    An example clustering algo\n    \"\"\"\n\n    @classmethod\n    def cluster_similarity_matrix(\n        cls,\n        similarity_matrix: list[list[float]],\n        example_setting: float = 0.123,\n    ):\n        // add your clustering algo\n        return clusters\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/clustering/#memory-optimized-method","title":"Memory-Optimized Method","text":"<p>When working with &gt;200k molecules, creating a similarity matrix becomes a memory issue because a &gt;200k x &gt;200k matrix will crash on something like a laptop with 16GB of RAM. In such cases, a method like <code>cluster_similarity_matrix</code> becomes problematic and sometimes unusable.</p> <p>To address this, some clustering algorithms can be rearranged to \"lazily\" generate similarity series. For these clustering methods, you should define a <code>cluster_fingerprints</code> method instead of a <code>cluster_similarity_matrix</code> method.</p> <p>So here we need to:</p> <ol> <li>Inherit from the <code>ClusteringEngine</code> base class</li> <li>Define a <code>cluster_fingerprints</code> method (can be a <code>@classmethod</code> or <code>@staticmethod</code>) that accepts the following kwargs: <code>fingerprints</code>, <code>similarity_engine</code>, and <code>similarity_engine_kwargs</code>.</li> </ol> <p>The <code>ClusteringEngine</code> will then manage how <code>cluster_molecules</code> and other features behave.</p> <p>Example:</p> <pre><code>from simmate.toolkit.clustering.base import ClusteringEngine\nfrom simmate.toolkit.similarity.base import SimilarityEngine\n\n\nclass Example(ClusteringEngine):\n    \"\"\"\n    An example clustering algo\n    \"\"\"\n\n    @classmethod\n    def cluster_fingerprints(\n        cls,\n        fingerprints: list,\n        similarity_engine: SimilarityEngine,\n        similarity_engine_kwargs: dict = {},\n        example_setting: float = 0.123,\n    ):\n        // add your clustering algo\n        return clusters\n</code></pre> <p>Tip</p> <p>For an example of this approach, see the <code>Butina</code> clustering method's source code here</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/","title":"Molecule Featurizers","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#overview","title":"Overview","text":"<p>Featurizing molecules involves generating properties and information about each molecule, such as the number of rings, molecular weight, and number of stereocenters. These features are crucial for exploring and analyzing data, identifying trends, and training machine learning or artificial intelligence models. The <code>Featurizer</code> base class helps optimize this process.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#fingerprints","title":"Fingerprints","text":"<p>Fingerprints are a unique type of featurizer that generate a 1D array of numerical values for each molecule. Each value represents a specific feature or property of the molecule. Fingerprints are entirely numerical, making them suitable for mathematical applications without requiring additional processing.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#basic-api-vs-featurizer-api","title":"Basic API vs. Featurizer API","text":"<p>The <code>Featurizer</code> API and the single-molecule API can both be used to calculate a list of properties. The choice between the two depends on your coding style preference and the scale of your project. The <code>Featurizer</code> API offers parallelization, which can be beneficial for large-scale projects.</p> <p>Single Molecule (\"Basic\") API: <pre><code>my_final_props = {\n    \"num_rings\": [m.num_rings for m in input_molecules],\n    \"num_stereocenters\": [m.num_stereocenters for m in input_molecules],\n    \"molecular_weight\": [m.molecular_weight for m in input_molecules],\n}\n</code></pre></p> <p><code>Featurizer</code> API: <pre><code>from simmate.toolkit.featurizers import PropertyGrabber\n\nmy_final_props = PropertyGrabber.featurize_many(\n    molecules=input_molecules,\n    properties=[\"num_rings\", \"num_stereocenters\", \"molecular_weight\"],\n    parallel=True,  # this is the key reason you'd want to use a Featurizer class!\n)\n</code></pre></p> <p>Bug</p> <p><code>parallel=True</code> has not yet been implemented</p> <p>Tip</p> <p>Both APIs yield the same result. The main difference is that the <code>Featurizer</code> API can use Dask for parallelization when <code>parallel=True</code>. If feature generation takes more than 15 minutes for all molecules, we recommend using the <code>Featurizer</code> API. This is typically the case when working with datasets of over 1 million molecules.</p> <p>Warning</p> <p>Our API is still in the early stages of development and may undergo changes to improve usability.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#usage-guide","title":"Usage Guide","text":"<p>All classes that inherit from the <code>Featurizer</code> class can be used in the same way. This guide uses the <code>MorganFingerprint</code> as an example, but you can substitute it with any supported featurizer.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#available-featurizers","title":"Available Featurizers","text":"<p>The <code>toolkit.featurizers</code> module contains all available featurizers, including:</p> <ul> <li><code>PropertyGrabber</code></li> <li><code>MorganFingerprint</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#serial-use","title":"Serial Use","text":"<p>You can featurize molecules one at a time using either the <code>featurize</code> or <code>featurize_many(parallel=False)</code> methods:</p> <pre><code>from simmate.toolkit.featurizers import MorganFingerprint\n\n# OPTION 1\nfor molecule in input_molecules:\n    fingerprint = MorganFingerprint.featurize(\n        molecule=molecule\n    )\n\n# OPTION 2\nfingerprints = MorganFingerprint.featurize_many(\n    molecules=input_molecules,\n    parallel=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#parallel-use","title":"Parallel Use","text":"<p>Enable parallelization by using the <code>featurize_many(parallel=True)</code> method:</p> <pre><code>from simmate.toolkit.featurizers import MorganFingerprint\n\nfingerprints = MorganFingerprint.featurize_many(\n    molecules=input_molecules,\n    parallel=True,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/featurizers/#adding-a-new-featurizer","title":"Adding a New Featurizer","text":"<p>To add a new featurizer, you need to:</p> <ol> <li>Inherit from the <code>Featurizer</code> base class</li> <li>Define a <code>featurize</code> method (can be a <code>@classmethod</code> or <code>@staticmethod</code>) that accepts a <code>molecule</code> as a kwarg.</li> </ol> <p>The <code>Featurizer</code> will then handle how <code>featurize_many</code> and other features behave.</p> <p>For example:</p> <pre><code>from simmate.toolkit import Molecule\nfrom simmate.toolkit.featurizers.base import Featurizer\n\n\nclass Example(Featurizer):\n    \"\"\"\n    An example featurizer\n    \"\"\"\n\n    @staticmethod\n    def featurize(\n        molecule: Molecule,\n        # feel free to add any extra kwargs you'd like\n        example_setting: float = 0.123,\n    ):\n        # use the molecule to generate your feature(s)\n        return calculation_property\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/filters/","title":"Advanced Molecule Filtering","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/","title":"ChemSpace Mapping","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#overview","title":"Overview","text":"<p>ChemSpace mapping refers to the process of plotting molecules in a 2D or 3D coordinate system, enabling the visualization of molecule similarities. Each data point in the plot represents a unique molecule, with closer points indicating more similar molecules.</p> <p></p> <p>The process typically involves three steps:</p> <ol> <li>Generating a fingerprint for each molecule or starting with a list of fingerprints.</li> <li>Converting the multi-value fingerprints into condensed fingerprints with 2-3 coordinates.</li> <li>Plotting the 2D or 3D coordinates to visualize molecule similarities.</li> </ol> <p>The <code>ChemSpaceMapper</code> class manages these steps.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#basic-use-from_preset","title":"Basic Use (<code>from_preset</code>)","text":"<p>In most cases, you can use the recommended settings for clustering, which are stored in the <code>ChemSpaceMapper.from_preset</code> method. Presets are named using the format <code>[mapping method]-[fingerprint method]</code>. Currently, we provide the <code>umap-morgan</code> preset.</p> <p>Here's an example of chemspace mapping using default settings:</p> <pre><code>from simmate.toolkit.mapping import ChemSpaceMapper\n\nx,y = ChemSpaceMapper.from_preset(\n    molecules=[...],  # This should be a list of Molecule objects\n    preset=\"umap-morgan\",\n    n_outputs=2,  # For a 2D (XY) plot\n)\n</code></pre> <p>Tip</p> <p>If you want to customize parameters for mapping/fingerprints, consider using the advanced API below.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#advanced-use","title":"Advanced Use","text":"<p>For complete control over your chemspace mapping, you can manually select your methods and parameters. </p>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#1-choose-fingerprint-method","title":"1. Choose Fingerprint Method","text":"<p>Select a fingerprint method from the <code>simmate.toolkit.featurizers</code> module. You can also select any kwargs that the featurizer's <code>featurize_many</code> method accepts. Refer to the Featurizers section for all available featurizers and their kwarg options.</p> <p>Example: <pre><code>from simmate.toolkit.featurizers import MorganFingerprint\n\nfeaturizer_kwargs = dict(\n    radius=4,\n    nbits=2048,\n    parallel=True,\n)\n</code></pre></p>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#2-choose-mapping-method","title":"2. Choose Mapping Method","text":"<p>Select a mapping method from the <code>simmate.toolkit.clustering</code> module. You can also select any kwargs that the <code>map_fingerprints</code> method accepts. We currently support <code>Pca</code>, <code>Tsne</code>, and <code>Umap</code> methods.</p> <p>Example: <pre><code>from simmate.toolkit.mapping import Umap\n\nmapping_kwargs = dict(\n    metric=\"jaccard\",  # aka Tanimoto\n    n_neighbors=25,\n    min_dist=0.25,\n    low_memory=False,\n)\n</code></pre></p> <p>Note</p> <p>All mapping methods have a <code>map_molecules</code> and a <code>map_fingerprints</code> method. These methods will be called in the final scripts.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#3-final-script","title":"3. Final Script","text":"<p>Once you've selected your methods and parameters, you can put them together:</p> <pre><code>from simmate.toolkit.clustering import Butina\nfrom simmate.toolkit.mapping import Umap\n\nx, y = Umap.map_molecules(\n    molecules=[...],  # This should be a list of Molecule objects\n    featurizer=MorganFingerprint,\n    featurizer_kwargs = dict(\n        radius=4,\n        nbits=2048,\n        parallel=True,\n    ),\n    metric=\"jaccard\",\n    n_neighbors=25,\n    min_dist=0.25,\n    low_memory=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#extra-starting-from-fingerprints","title":"EXTRA: Starting from Fingerprints","text":"<p>If you already have fingerprints and want to use those instead of <code>Molecule</code> objects, you can skip the first step and replace <code>map_molecules</code> with the <code>map_fingerprints</code> method:</p> <pre><code>from simmate.toolkit.clustering import Butina\nfrom simmate.toolkit.mapping import Umap\n\nclusters = Umap.map_molecules(\n    fingerprints=[...],  # This should be a list of fingerprints (1D array of floats)\n    metric=\"jaccard\",\n    n_neighbors=25,\n    min_dist=0.25,\n    low_memory=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/mapping/#adding-a-new-mapping-method","title":"Adding a New Mapping Method","text":"<p>To add a new mapping method, you need to:</p> <ol> <li>Inherit from the <code>ChemSpaceMapper</code> base class.</li> <li>Define a <code>map_fingerprints</code> method (can be a <code>@classmethod</code> or <code>@staticmethod</code>) that accepts <code>fingerprints</code> and <code>n_outputs</code> as kwargs.</li> </ol> <p>The <code>ChemSpaceMapper</code> will then manage how <code>map_molecules</code>, <code>map_fingerprints</code>, and other features behave.</p> <p>For example:</p> <pre><code>from simmate.toolkit.mapping.base import ChemSpaceMapper\n\n\nclass Example(ChemSpaceMapper):\n    \"\"\"\n    An example mapping algo\n    \"\"\"\n\n    @classmethod\n    def map_fingerprints(\n        cls, \n        fingerprints: list, \n        n_outputs: int = 2,\n        example_setting: float = 0.123,\n    ):\n        # add your mapping algo\n        if n_outputs == 2:\n            # ....\n            return fit_x, fit_y\n        elif n_outputs == 3:\n            # ....\n            return fit_x, fit_y, fit_z\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/","title":"Molecular Similarity &amp; Distance","text":""},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#overview","title":"Overview","text":"<p>\"Similarity\" and \"distance\" are mathematical measures used to quantify the likeness or difference between molecules. </p> <p>To compare molecules, we first need a \"description\" of each molecule, which is obtained from features or fingerprints (refer to the <code>Featurizers</code> section). We then apply a mathematical operator to determine the \"distance\" between these fingerprints.</p> <p>The process of comparing molecules typically involves:</p> <ol> <li>Generating a fingerprint for each molecule OR starting with a pre-existing list of fingerprints</li> <li>Applying a distance formula to quantify the proximity of two fingerprints</li> </ol> <p>The <code>SimilarityEngine</code> class manages these steps.</p> <p>Example</p> <p>Suppose we want to compare two molecules based on three features:</p> <ul> <li>Fraction of sp3 carbons</li> <li>Number of hydrogen donors</li> <li>Number of hydrogen acceptors</li> </ul> <p>We measure these values for each molecule, resulting in a \"fingerprint\" of <code>[x,y,z]</code>:</p> <ul> <li>Molecule 1: <code>[0.345, 5, 6]</code></li> <li>Molecule 2: <code>[0.543, 2, 1]</code></li> </ul> <p>To determine the similarity, we can \"plot\" these fingerprints in 3D space and calculate the \"distance\" between these points. If we're interested in similarity rather than distance, we can consider them as inverses of each other:</p> <ul> <li><code>distance^2 = (x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2</code></li> <li><code>similarity = 1 / distance</code></li> </ul> <p>Using these rules, the \"similarity\" of these two molecules is scored as <code>0.17</code>.</p> <p>In this example, we used a basic fingerprint (3 features) and the <code>Euclidean</code> formula for distance. However, there are numerous ways to generate fingerprints (some with &gt;1000 features!) and calculate distance. The same process and concepts apply to each.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#basic-use","title":"Basic Use","text":"<p>We'll use <code>Tanimoto</code> as an example here, but all methods behave similarly.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#1-select-a-fingerprint-method","title":"1. Select a fingerprint method","text":"<p>Choose any fingerprint method from the <code>simmate.toolkit.featurizers</code> module. Refer to the Featurizers section for all options. For this example, we'll use <code>MorganFingerprint</code>:</p> <pre><code>from simmate.toolkit.featurizers import MorganFingerprint\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#2-select-a-similarity-metric","title":"2. Select a similarity metric","text":"<p>Choose an appropriate metric for similarity based on the selected fingerprint. The following types of similarity/distance measurements are supported:</p> CLASS <code>Cosine</code> <code>Dice</code> <code>Euclidean</code> <code>Tanimoto</code> <pre><code>from simmate.toolkit.similarity import Tanimoto\n</code></pre> <p>Warning</p> <p>For many fingerprints, there is a \"logical &amp; correct\" choice for the metric to use. If you're unsure, don't guess! Seek help &amp; advice </p> <p>For instance, the <code>MorganFingerprint</code> that we selected in step 1 is most effective when used with <code>Tanimoto</code>.</p>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#2-select-a-similarity-method","title":"2. Select a similarity method","text":"<p>All <code>SimilarityEngine</code> subclasses support the following methods:</p> CLASS <code>get_similarity(fingerprint1, fingerprint2)</code> <code>get_similarity_series(fingerprint1, [fingerprint2, fingerprint3, fingerprint4, ...])</code> <code>get_similarity_matrix([fingerprint1, fingerprint2, fingerprint3, ...])</code> <code>get_distance(fingerprint1, fingerprint2)</code> <code>get_distance_series(fingerprint1, [fingerprint2, fingerprint3, fingerprint4, ...])</code> <code>get_distance_matrix([fingerprint1, fingerprint2, fingerprint3, ...])</code> <p>Suppose we have a single molecule that we want to compare to a set of 1,000 molecules. For this, we'll use <code>get_similarity_series</code>:</p> <pre><code>Tanimoto.get_similarity_series\n</code></pre>"},{"location":"full_guides/toolkit/molecules/many_molecules/similarity/#3-construct-the-final-script","title":"3. Construct the final script","text":"<p>Now, let's combine everything for our final script.</p> <pre><code>from simmate.toolkit import Molecule\nfrom simmate.toolkit.featurizers import MorganFingerprint\nfrom simmate.toolkit.similarity import Tanimoto\n\n# Load query molecule\nquery_molecule = Molecule.from_smiles(\".....\")\n\n# Load other molecules\nsmiles_strs = [......] \nmolecules = [Molecule.from_smiles(s) for s in smiles_strs]\n\n# Generate fingerprints\nquery_fingerprint = MorganFingerprint.featurize(query_molecule)\nfingerprints = MorganFingerprint.featurize_many(molecules)\n\n# Generate the similarity scores\nsimilarities = Tanimoto.get_similarity_series(\n    query_fingerprint,\n    fingerprints,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/single_molecule/cleaning_and_prep/","title":"Molecule Cleaning &amp; Method Preparation","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/cleaning_and_prep/#hydrogens-implicit-vs-explicit","title":"Hydrogens (Implicit vs. Explicit)","text":"<p>The <code>add_hydrogens</code> and <code>remove_hydrogens</code> methods are used to add and remove Hydrogens. These methods are applicable only to Hydrogens that can be inferred from the base structure:</p> Add HydrogensRemove Hydrogens <pre><code>molecule.add_hydrogens()\n</code></pre> <pre><code>molecule.remove_hydrogens()\n</code></pre> <p>Tip</p> <p>Hydrogens are typically not present but \"implied\" in 2D molecules (e.g. SMILES). However, certain analyses and methods require explicit Hydrogens for accuracy, such as 3D conformer generation.</p> <p>Many methods and workflows automatically add Hydrogens when necessary. This is particularly useful when optimizing scripts for large molecule sets (&gt;10k).</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/cleaning_and_prep/#fragments-mixtures","title":"Fragments / Mixtures","text":"<p>Several methods are available to parse a \"molecule\" that is actually a mixture (i.e., contains more than one molecule or species).</p> <pre><code>mixture = Molecule.from_sdf(\"example.sdf\")\n\nfor molecule in mixture.get_fragments():\n    print(molecule.to_smiles())\n</code></pre> METHOD <code>get_largest_fragment</code> <code>split_fragments</code> (UNDER DEV) <code>num_fragments</code> (UNDER DEV) <code>get_fragments</code> (UNDER DEV) <p>Warning</p> <p>These methods may be removed as conformers should be separate <code>Molecule</code> objects.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/cleaning_and_prep/#stereochemistry","title":"Stereochemistry","text":"<p>Warning</p> <p>Stereochemistry cleanup is currently under development. In the meantime, consider using tools like \"Flipper\" to iterate stereochemistry.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/cleaning_and_prep/#2d-to-3d-conversion","title":"2D to 3D Conversion","text":"<p>Molecules are often provided as 2D representations, which are human-readable and can be drawn on paper (as a Lewis structure). However, simulations usually require 3D representations to accurately depict the molecule's real-life shape.</p> <p>The <code>convert_to_3d</code> method is a simple strategy to generate \"reasonable\" 3D coordinates for a molecule:</p> <pre><code>molecule.convert_to_3d()\n</code></pre> <p>Danger</p> <p>The generation of 3D conformers is a complex topic with various strategies. The method shown here is the simplest and quickest approach. We plan to expand this section in the future to discuss different workflows and their respective advantages and disadvantages.</p> <p>We may also update the <code>convert_to_3d</code> method to accept different workflow names (e.g., using either surflex or omega apps).</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_analyses/","title":"Common Analyses","text":"<p>Important</p> <p>This page provides a concise list of available features, grouped by function. Detailed descriptions of each property can be found in the <code>API</code> section.</p> <p>Tip</p> <p>If you're searching for analyses such as clustering, similarity, or chemspace mapping, you'll find them in the \"many molecule\" analyses section. This page is dedicated to single-molecule analysis.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_analyses/#overview","title":"Overview","text":"<p>Most analyses are implemented as Python methods, accepting a range of input arguments and formats.</p> <p>For instance, you can call a method like this:</p> <pre><code>query = \"[CX2]#[CX2]\"\nis_alkyne = molecule.is_smarts_match(query)\n</code></pre> <p>It's recommended to review the documentation for each method before using it. This page serves as a quick reference to help you identify available methods.</p> <p>Danger</p> <p>The methods are not yet grouped, so they are listed in no particular order for the time being.</p> <ul> <li><code>get_r_groups</code></li> <li><code>get_fragments</code></li> <li><code>is_smarts_match</code></li> <li><code>num_smarts_match</code></li> <li><code>num_substructure_matches</code></li> <li><code>get_num_atoms_of_atomic_number</code></li> <li><code>get_num_atoms_of_atomic_symbols</code></li> <li><code>get_stereocenters</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/","title":"Common properties","text":"<p>Important</p> <p>This page provides a concise list of available properties, grouped by function. Detailed descriptions of each property can be found in the <code>API</code> section.</p> <p>Tip</p> <p>If you're dealing with multiple molecules, check out the \"Featurizers\" section for tips on enhancing speed and parallelization.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#overview","title":"Overview","text":"<p>The <code>Molecule</code> class offers a wide range of accessible properties. </p> <p>You can access almost all properties like this:</p> <pre><code>n = molecule.num_atoms\n</code></pre> <p>Replace <code>num_atoms</code> with any of the options below to explore further.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#metadata-content","title":"Metadata &amp; Content","text":"<ul> <li><code>name</code></li> <li><code>metadata</code></li> <li><code>comment</code></li> </ul> <p>Note</p> <p>These are only accessible when Molecules are loaded from an SDF str/file.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#composition","title":"Composition","text":"<ul> <li><code>formula</code></li> <li><code>elements</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#molecular-weight","title":"Molecular Weight","text":"<ul> <li><code>molecular_weight</code></li> <li><code>molecular_weight_exact</code></li> <li><code>molecular_weight_heavy_atoms</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#stereochemistry","title":"Stereochemistry","text":"<ul> <li><code>num_stereocenters</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#conformers","title":"Conformers","text":"<ul> <li><code>num_conformers</code></li> </ul> <p>Warning</p> <p>This may be removed as conformers should be separate <code>Molecule</code> objects.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#bonding","title":"Bonding","text":"<ul> <li><code>num_bonds</code></li> <li><code>num_bonds_rotatable</code></li> <li><code>frac_c_sp3</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#atom-counting","title":"Atom counting","text":"<ul> <li><code>num_atoms</code></li> <li><code>num_atoms_heavy</code></li> <li><code>num_h_acceptors</code></li> <li><code>num_h_donors</code></li> <li><code>num_heteroatoms</code></li> <li><code>num_c_atoms</code></li> <li><code>num_halogen_atoms</code></li> <li><code>get_num_atoms_of_atomic_number()</code>  (method)</li> <li><code>get_num_atoms_of_atomic_symbols()</code>  (method)</li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#electron-counting","title":"Electron counting","text":"<ul> <li><code>num_electrons_valence</code></li> <li><code>num_electrons_radical</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#rings-aromaticity","title":"Rings &amp; Aromaticity","text":"<ul> <li><code>num_rings</code></li> <li><code>num_rings_aromatic</code></li> <li><code>num_ring_families</code></li> <li><code>rings</code></li> <li><code>ring_sizes</code></li> <li><code>ring_size_min</code></li> <li><code>ring_size_max</code></li> <li><code>num_aliphatic_carbocycles</code></li> <li><code>num_aliphatic_heterocycles</code></li> <li><code>num_aromatic_heterocycles</code></li> <li><code>num_saturated_carbocycles</code></li> <li><code>num_saturated_heterocycles</code></li> <li><code>num_rings_saturated</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#energy-states","title":"Energy States","text":"<ul> <li><code>max_abs_e_state_index</code></li> <li><code>max_e_statate_index</code></li> <li><code>min_abs_e_state_index</code></li> <li><code>min_e_state_index</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#partial-charges","title":"Partial Charges","text":"<ul> <li><code>max_abs_partial_charge</code></li> <li><code>max_partial_charge</code></li> <li><code>min_abs_partial_charge</code></li> <li><code>min_partial_charge</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#predicted-properties","title":"Predicted Properties","text":"<ul> <li><code>log_p_rdkit</code></li> <li><code>tpsa_rdkit</code></li> <li><code>molar_refractivity_rdkit</code></li> <li><code>ipc</code></li> <li><code>synthetic_accessibility</code></li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/common_properties/#substructure-components","title":"Substructure Components","text":"<p>(still under development) Methods that map to the <code>smarts_sets</code> module will be added.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/","title":"Molecule Exportation","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/#introduction","title":"Introduction","text":"<p>After loading a molecule, you can convert it to a different format using a <code>to_</code> method of <code>Molecule</code>. </p> <p>For instance, use <code>to_smiles</code> to output a SMILES, use <code>to_mol2</code> for a MOL2 output, and use <code>to_rdkit</code> for an RDKit object.</p> <p>Thus, file format conversion typically involves two steps:</p> <ol> <li>Load using a <code>from_*</code> method</li> <li>Export using a <code>to_*</code> method</li> </ol> <pre><code>from simmate.toolkit import Molecule\n\n# step 1: LOAD\nmolecule = Molecule.from_sdf_file(\"example.sdf\")\n\n# step 2: EXPORT\nmolecule.to_png_file(\"output.png\")\n</code></pre> <p>Note</p> <p>For exporting numerous molecules or handling large files, refer to our \"Many Molecules\" section. </p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/#basic-exportation","title":"Basic Exportation","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/#files","title":"Files","text":"<p>File-based outputs accept a filename as a string or a <code>pathlib.Path</code> object.</p> <pre><code>molecule = Molecule.to_sdf_file(\"example.sdf\")\n</code></pre> TYPE METHOD Image <code>to_png_file</code> SDF (aka CTAB) <code>to_sdf_file</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for exporting to a string, as detailed in the section below. For instance, <code>to_sdf</code> outputs a string, while <code>to_sdf_file</code> writes a <code>.sdf</code> file.</p> <p>Warning</p> <p>Writing numerous files (with many molecules in each) can be slow using these methods. Refer to the \"many molecules\" section for optimized writing of thousands or millions of molecules.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/#raw-text-strings","title":"Raw Text / Strings","text":"<p>Instead of writing to a file, you can also obtain the converted format as a python variable (string) for use elsewhere.</p> <pre><code>my_smiles = molecule.to_smiles()\n</code></pre> TYPE METHOD INCHI <code>to_inchi</code> INCHI Key <code>to_inchi_key</code> SMILES <code>to_smiles</code> SMILES (kekulized) <code>to_smiles(kekulize=True)</code> SMILES (CX-extended) <code>to_cx_smiles</code> SDF (aka CTAB) <code>to_sdf</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for exporting directly to a file, as detailed in the section above. For instance, <code>to_sdf</code> outputs a string, while <code>to_sdf_file</code> writes a <code>.sdf</code> file.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_exporting/#python-objects","title":"Python Objects","text":"<p>Methods are available to convert to other popular python objects, such as those from RDKit.</p> <pre><code>molecule.to_rdkit()\n</code></pre> TYPE METHOD RDKit Mol object <code>to_rdkit</code> RDKit Mol object written as binary <code>to_binary</code>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/","title":"Loading a Molecule","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#introduction","title":"Introduction","text":"<p>To load a molecule, call a <code>from_</code> method of <code>Molecule</code>. </p> <p>For instance, <code>from_smiles</code> for a SMILES input, <code>from_mol2</code> for a MOL2 input, and <code>from_rdkit</code> for an RDKit object. Choose the method that corresponds to your input type, or use the <code>from_dynamic</code> strategy if you're unsure or have a variety of input types.</p> <p>Tip</p> <p><code>from_dynamic</code> is the simplest and most convenient method, but it may not always work! If you know your molecule's format, use the specific method for it.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#dynamic-loading","title":"Dynamic Loading","text":"<p>Dynamic loading examines your input and determines how to convert it into a <code>Molecule</code> object. It performs checks and then calls one of the methods detailed on this page.</p> <pre><code>from simmate.toolkit import Molecule\n\n# try this with a filename, a smiles string, SDF string, rdkit object, ...\ninput_01 = \"example_molecule.sdf\"\ninput_02 = \"example_molecule.csv\" \ninput_03 = \"C1=CC(=C(C=C1CCN)O)O\"\n\n# The from_dynamic method will determine the format and convert it\nfor new_input in [input_01, input_02, input_03]\n    molecule = Molecule.from_dynamic(new_input)\n</code></pre> <p>Note</p> <p><code>from_dynamic</code> also checks if we already have a <code>Molecule</code> object and returns it if we do.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#basic-loading","title":"Basic Loading","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#files","title":"Files","text":"<p>File-based inputs accept a filename as a string or a <code>pathlib.Path</code> object.</p> <pre><code>from simmate.toolkit import Molecule\n\nmolecule = Molecule.from_sdf_file(\"example.sdf\")\n</code></pre> TYPE METHOD (dynamic loading) <code>from_file</code> CSV <code>from_csv_file</code> SMILES (any type) <code>from_smiles_file</code> SDF (aka CTAB) <code>from_sdf_file</code> MOL2 <code>from_mol2_file</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for loading this format directly from text/str, detailed in the section below. For instance, <code>from_smiles</code> takes a string, while <code>from_smiles_file</code> takes a <code>.smi</code> file.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#raw-text-strings","title":"Raw text / strings","text":"<p>You can read a python string variable directly. These methods are primarily used for testing and debugging.</p> <pre><code>from simmate.toolkit import Molecule\n\nmolecule = Molecule.from_smiles(\"C1=CC(=C(C=C1CCN)O)O\")\n</code></pre> TYPE METHOD INCHI <code>from_inchi</code> SMILES <code>from_smiles</code> SMARTS <code>from_smarts</code> SDF (aka CTAB) <code>from_sdf</code> MOL2 <code>from_mol2</code> <p>Tip</p> <p>Each of these methods has a corresponding submethod for loading this format directly from a file, detailed in the section above. For instance, <code>from_smiles</code> takes a string, while <code>from_smiles_file</code> takes a <code>.smi</code> file.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#python-objects","title":"Python Objects","text":"<p>Methods are available to convert other popular python objects, such as those from RDKit</p> <pre><code>from simmate.toolkit import Molecule\nfrom rdkit import Chem\n\n# Smiles -&gt; RDKit -&gt; Simmate\nrdkit_mol = Chem.MolFromSmiles(\"Cc1ccccc1\")\nmolecule = Molecule.from_rdkit(rdkit_mol)\n# !!! NOT RECOMMENDED !!!\n\n# Smiles -&gt; Simmate \nmolecule = Molecule.from_smiles(\"Cc1ccccc1\")\n# !!! RECOMMENDED !!!\n</code></pre> TYPE METHOD RDKit Mol object <code>from_rdkit</code> RDKit Mol object written as binary <code>from_binary</code> Simmate (aka nothing needs to be done) <code>from_dynamic</code> <code>pathlib.Path</code> see <code>from_file</code> section above"},{"location":"full_guides/toolkit/molecules/single_molecule/molecule_loading/#database-entries","title":"Database Entries","text":"<p>Warning</p> <p>Loading from database metadata is still in progress. Refer to our guides on Python ORM  to access datasets as <code>Molecule</code> objects quickly.</p> <p>For example: <pre><code>from simmate.database import connect\nfrom simmate.apps.chembl import ChemblMolecule\n\nmolecule_db = ChemblMolecule.objects.get(id=123)\nmolecule = molecule_db.to_toolkit()\n</code></pre></p>"},{"location":"full_guides/toolkit/molecules/single_molecule/quick_start/","title":"Single-Molecule Quick Start","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/quick_start/#summary-of-steps","title":"Summary of Steps","text":"<p>A typical workflow for a single molecule usually involves the following steps:</p> <ol> <li>Importing a molecule into Python</li> <li>Cleaning up the molecule's structure</li> <li>Analyzing the molecule's properties and features</li> <li>Exporting the molecule in a different format</li> </ol> <p>While only the first step is mandatory, the rest are optional and can be customized according to your needs. Use the guides in this section to explore the various options available for each step. You can combine these options to create a unique script or workflow that can be shared with others!</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/quick_start/#basic-example","title":"Basic Example","text":"<p>Here's a simple example that covers each of the steps mentioned above:</p> <pre><code>from simmate.toolkit import Molecule\n\n# 1: Import\nmolecule = Molecule.from_smiles(\"C1=CC(=C(C=C1CCN)O)O\")\n\n# 2: Clean / Format\nmolecule.convert_to_3d(keep_hydrogen=True)\n\n# 3a: Analyze Functional Groups\nprint(\"Functional groups identified:\")\nprint(molecule.get_fragments())\n\n# 3b: Analyze Stereochemistry\nif molecule.num_stereocenters &gt; 0:\n    print(\"Stereocenters detected!\")\n\n# 4: Export\nmolecule.to_sdf_file(filename=\"my_3d_mol.sdf\")\n</code></pre> <p>Additionally, if you're using Spyder or Jupyter Notebooks as your Python IDE, you can visualize your molecule with the following command:</p> <pre><code>molecule.image\n</code></pre>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/","title":"SMARTS Sets","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#overview","title":"Overview","text":"<p>SMARTS queries are used for substructure searches and identifying functional groups. This module offers \"sets\" of common substructures and functional groups, which can be used to label molecules.</p> <p>The <code>SmartsSet</code> class manages the search and labeling process for input molecules.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#available-sets","title":"Available Sets","text":"<p>Two default SMARTS sets are available:</p> <ul> <li><code>ChemblAlerts</code> (csv)</li> <li><code>CdkFunctionalGroups</code> (csv)</li> </ul> <p>The <code>ChemblAlerts</code> set includes several popular subsets:</p> <ul> <li>Glaxo</li> <li>Dundee</li> <li>BMS</li> <li>PAINS</li> <li>MLSMR</li> </ul>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#basic-usage","title":"Basic Usage","text":""},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#accessing-a-sets-data","title":"Accessing a Set's Data","text":"<p>You can access the original raw data (from a CSV file) and a column for SMARTS <code>Molecule</code> objects using the <code>smarts_data</code> and <code>smarts_dict</code> class properties.</p> <p>For instance, using <code>ChemblAlerts</code>:</p> <pre><code>from simmate.toolkit.smarts_sets import ChemblAlerts\n\n# option 1 (as pandas.DataFrame)\ndata = ChemblAlerts.smarts_data\n\n# option 2 (as dict)\ndata = ChemblAlerts.smarts_dict\n</code></pre>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#counting-matches","title":"Counting Matches","text":"<p>To obtain the exact count of each functional group, use <code>get_counts</code>:</p> <pre><code>from simmate.toolkit.smarts_sets import ChemblAlerts\n\nmatches = ChemblAlerts.get_counts(\n    molecule,\n    include_misses=False,\n)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#listing-matches","title":"Listing Matches","text":"<p>If you only need a list of the SMARTS that matched, rather than exact counts, use <code>get_matches</code>:</p> <pre><code>from simmate.toolkit.smarts_sets import ChemblAlerts\n\nmatches = ChemblAlerts.get_matches(molecule)\n</code></pre>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#parallelization","title":"Parallelization","text":"<p>Warning</p> <p>The parallelization method for this class is not yet available. Please contact us if you require this feature.</p>"},{"location":"full_guides/toolkit/molecules/single_molecule/smarts_sets/#adding-a-new-set","title":"Adding a New Set","text":"<p>To add a new SMARTS set, you need to:</p> <ol> <li>Create a csv file with <code>name</code> and <code>smarts_str</code> columns (you can add more columns if needed)</li> <li>Inherit from the <code>SmartsSet</code> base class</li> <li>Specify the location of the CSV file with the <code>source_file</code> attribute</li> </ol> <p>The <code>SmartsSet</code> will then manage the behavior of <code>get_counts</code> and other features.</p> <p>For example:</p> <pre><code>from simmate.toolkit.smarts_sets.base import SmartsSet\n\n\nclass CustomAlerts(SmartsSet):\n    source_file = \"path/to/custom_alerts.csv\"\n</code></pre>"},{"location":"full_guides/website/creating_views/","title":"Creating views","text":""},{"location":"full_guides/website/creating_views/#django-vs-simmate","title":"Django vs. Simmate","text":"<p>Simmate does not do anything special with views -- we just use the Django web framework. So you can follow Django's official guides on how to create web views, urls, and templates.</p>"},{"location":"full_guides/website/creating_views/#basic-example","title":"Basic Example","text":"<p>In your app, you can set up the following: <pre><code>\u251c\u2500\u2500 example_app\n\u2502   \u251c\u2500\u2500 templates\n\u2502   \u2502   \u2514\u2500\u2500 my_homepage.html\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 views.py\n</code></pre></p> <p>And for each file &amp; it's contents:</p> urls.pyviews.pymy_homepage.html <pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.home, name='home'),\n]\n</code></pre> <pre><code>from django.shortcuts import render\n\ndef home(request):\n    context = {\"name\": \"Jane Doe\"}\n    return render(request, \"my_homepage.html\", context)\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Home Page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, {{ name }}! This is the home page rendered from a template.&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>To view this in the website:</p> <ol> <li>Make sure your app is registered with Simmate.</li> <li>Navigate to the <code>Apps</code> tab in the website and you should see your app listed</li> <li>Select your <code>Apps</code> and it will open the <code>\"\"</code> path (homepage) in your app's <code>urls.py</code></li> </ol> <p>Example</p> <p>If your app was called <code>example_app</code> and this was your <code>urls.py</code>:</p> <pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('', views.index, name='index'),\n    path('my-custom-view/', views.my_custom_view, name='custom'),\n]\n</code></pre> <p>You could view them in the Simmate website at:</p> <ul> <li><code>http://127.0.0.1:8000/apps/example_app/</code></li> <li><code>http://127.0.0.1:8000/apps/example_app/my-custom-view/</code></li> </ul>"},{"location":"full_guides/website/creating_views/#how-views-are-registered","title":"How views are registered","text":"<p>Normally in Django, you have a main <code>urls.py</code> and you register apps to it like so:</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    # ...\n    path(\"example/\", include(\"example_app.urls\")),\n    # ...\n]\n</code></pre> <p>In Simmate, we have our own <code>urls.py</code> file, and we automatically add your app to it. Everything in your <code>urls.py</code> will be mapped to a namespace matching your app's name using:</p> <pre><code>path(\n    route=f\"apps/{APP_NAME}/\",\n    view=include((path_to_urls_file, APP_NAME), namespace=APP_NAME),\n    name=APP_NAME,\n),\n</code></pre>"},{"location":"full_guides/website/rest_api/","title":"Simmate REST API","text":"<p>Warning</p> <p>This section is only for experts! If you're aiming to extract data from Simmate, we suggest using our Python client, as outlined in the database guides. The REST API is mainly for teams that cannot use Simmate's python package but still need to extract data. Be aware that data extraction via our REST API is heavily throttled, making it unsuitable for large data retrievals.</p>"},{"location":"full_guides/website/rest_api/#about","title":"About","text":"<p>\"REST API\" stands for \"Representational State Transfer (REST) Application Programming Interfaces (API)\". In simpler terms, it's a way to access databases through a website URL.</p>"},{"location":"full_guides/website/rest_api/#example-endpoint","title":"Example Endpoint","text":"<p>To better understand our API, we'll use the Materials Project data as an example. You can view this data at <code>/data/MatprojStructure/</code>. Keep in mind, nearly every URL within Simmate's <code>Data</code> tab has REST API functionality and behaves the same as this dataset.</p>"},{"location":"full_guides/website/rest_api/#api-usage","title":"API Usage","text":"<p>Consider a typical URL and webpage: <pre><code>http://simmate.org/data/MatprojStructure/\n</code></pre></p> <p>This link takes you to a webpage where you can browse all Materials Project structures. However, this URL also serves as a REST API. To access it, simply add <code>?format=api</code> to the URL. Try this link: <pre><code>http://simmate.org/data/MatprojStructure/?format=api\n</code></pre></p> <p>Likewise, adding <code>?format=json</code> will return data in a JSON dictionary: <pre><code>http://simmate.org/data/MatprojStructure/?format=json\n</code></pre></p> <p>This also applies to individual entries. For example, to access all data for the structure with id <code>mp-1</code>, use... <pre><code>http://simmate.org/data/MatprojStructure/mp-1/?format=api\nhttp://simmate.org/data/MatprojStructure/mp-1/?format=json\n</code></pre></p> <p>The output should look like... <pre><code>{\n    \"id\": \"mp-1\",\n    \"structure\": \"...(hidden for clarity)\",\n    \"nsites\": 1,\n    \"nelements\": 1,\n    \"elements\": [\"Cs\"],\n    \"chemical_system\": \"Cs\",\n    \"density\": 1.9350390306525629,\n    \"density_atomic\": 0.00876794537479071,\n    \"volume\": 114.05180544066401,\n    \"volume_molar\": 68.68360262958124,\n    \"formula_full\": \"Cs1\",\n    \"formula_reduced\": \"Cs\",\n    \"formula_anonymous\": \"A\",\n    \"energy\": -0.85663276,\n    \"energy_per_atom\": -0.85663276,\n    \"energy_above_hull\": null,\n    \"is_stable\": null,\n    \"decomposes_to\": null,\n    \"formation_energy\": null,\n    \"formation_energy_per_atom\": null,\n    \"spacegroup\": 229,\n}\n</code></pre></p>"},{"location":"full_guides/website/rest_api/#filtering-results","title":"Filtering Results","text":"<p>Our URLs also support advanced filtering. For instance, to search for all structures with the spacegroup 229 in the Cr-N chemical system, the URL becomes... <pre><code>http://simmate.org/data/MatprojStructure/?chemical_system=Cr-N&amp;spacegroup__number=229\n</code></pre></p> <p>Conditions are specified by adding a question mark (<code>?</code>) to the URL, followed by <code>example_key=desired_value</code>. Additional conditions are separated by <code>&amp;</code>, resulting in <code>key1=value1&amp;key2=value2&amp;key3=value3</code>, etc. You can also add <code>format=api</code> to this.</p> <p>However, for complex or advanced cases, we recommend using the <code>simmate.database</code> module, as it provides more robust filtering capabilities.</p>"},{"location":"full_guides/website/rest_api/#pagination-of-results","title":"Pagination of Results","text":"<p>To avoid server overload, Simmate currently returns a maximum of 12 results at a time. Pagination is automatically managed using the <code>page=...</code> keyword in the URL. In the HTML, API, and JSON views, links to the next page of results are always provided. For instance, in the JSON view, the returned data includes <code>next</code> and <code>previous</code> URLs.</p>"},{"location":"full_guides/website/rest_api/#ordering-results","title":"Ordering Results","text":"<p>You can set the order of returned data by adding <code>ordering=example_column</code> to your URL. To reverse the order, use <code>ordering=-example_column</code> (note the \"<code>-</code>\" before the column name). For example:</p> <pre><code>http://simmate.org/data/MatprojStructure/?ordering=density_atomic\n</code></pre>"},{"location":"full_guides/website/rest_api/#programmer-access-api-keys","title":"Programmer access &amp; API Keys","text":""},{"location":"full_guides/website/rest_api/#public-website","title":"Public Website","text":"<p>The public Simmate website does not require you to be authenticated to access our API endpoints. You can therefore call API endpoints anonymously:</p> python requestscurl <pre><code>import requests\n\nurl = 'http://simmate.org/data/MatprojStructure/?format=json'\nresponse = requests.get(url)\n\nprint(response.text)\n</code></pre> <pre><code>curl -X GET http://localhost/data/ChemblMolecule/?format=api\n</code></pre>"},{"location":"full_guides/website/rest_api/#private-servers","title":"Private Servers","text":"<p>Some private servers, do require authenticated users to ensure data security. For these, you can access endpoints by providing an API key.</p> <ol> <li> <p>find your API key in the <code>Profile</code> page of the website and select the <code>View API Key</code> at the bottom of the page. The key will be something like... <pre><code>59ced7225bb41d51b7bc78c1e269542eaa99c72f\n</code></pre></p> </li> <li> <p>make sure you provide the API as a header in your requests:</p> python requestscurl <pre><code>import requests\n\nurl = 'http://simmate.org/data/MatprojStructure/?format=json'\nheaders = {'Authorization': 'Token 59ced7225bb41d51b7bc78c1e269542eaa99c72f'}\n\nresponse = requests.get(url, headers=headers)\n\nprint(response.text)\n</code></pre> <pre><code>curl -X GET http://simmate.org/data/MatprojStructure/?format=json -H 'Authorization: Token 59ced7225bb41d51b7bc78c1e269542eaa99c72f'\n</code></pre> </li> </ol>"},{"location":"full_guides/website/setup_and_config/","title":"Simmate Website Module","text":""},{"location":"full_guides/website/setup_and_config/#local-server-setup","title":"Local Server Setup","text":"<p>To set up Simmate on your local computer, use the following command:</p> command line <pre><code>simmate run-server\n</code></pre> <p>While this command is running, open your preferred browser (Chrome, Firefox, etc.) and navigate to http://127.0.0.1:8000/.</p>"},{"location":"full_guides/website/setup_and_config/#production-server-setup","title":"Production Server Setup","text":"<p>To set up a production-ready server for your team, you have three options:</p> <ol> <li>Collaborate with the Simmate team and join our server</li> <li>Request our team to manage a server for you</li> <li>Set up and manage your own server</li> </ol> <p>For options 1 and 2, contact us at <code>simmate.team@gmail.com</code>.</p> <p>For option 3, follow our guide for setting up a server on DigitalOcean. Ensure you've completed the base Simmate tutorials, particularly the ones on setting up a cloud database and setting up computational resources.</p> <p>Warning</p> <p>We are in the process of building setups via docker-compose/swarm as well as a kubernetes/helm chart to simplify server setup. Therefore, our guides for production setup may change significantly in future releases.</p>"},{"location":"full_guides/website/setup_and_config/#third-party-sign-ins","title":"Third-Party Sign-Ins","text":"<p>Simmate supports sign-ins via third-party accounts such as Google and Github, thanks to the <code>django-allauth</code> package.</p> <p>By default, servers won't display these sign-in buttons. If you wish to enable third-party account logins, you'll need to configure this manually. Although <code>django-allauth</code> supports many account types (see their full list), Simmate currently only supports Github and Google. Guides for setting these up are provided below.</p>"},{"location":"full_guides/website/setup_and_config/#github-oauth","title":"Github OAuth","text":"<ol> <li>Create a new OAuth application here using the following information (replace <code>http://127.0.0.1:8000</code> with your cloud server link if applicable):</li> </ol> <pre><code>application name = My New Simmate Server (edit as desired)\nhomepage url = http://127.0.0.1:8000\nauthorization callback url = http://127.0.0.1:8000/accounts/github/login/callback/\n</code></pre> <ol> <li> <p>On the next page, select \"Generate a new client secret\" and copy this value.</p> </li> <li> <p>Set the environment variables on your local computer or production-ready server: <pre><code>GITHUB_SECRET = examplekey1234 (value from step 2)\nGITHUB_CLIENT_ID = exampleid1234 (value listed on Github as \"Client ID\")\n</code></pre></p> </li> </ol>"},{"location":"full_guides/website/setup_and_config/#google-oauth","title":"Google OAuth","text":"<ol> <li>Follow the django-allauth steps here to configure the Google API application.</li> <li>Set the environment variables on your local computer or production-ready server: <pre><code>GOOGLE_SECRET = examplekey1234\nGOOGLE_CLIENT_ID = exampleid1234\n</code></pre></li> </ol>"},{"location":"full_guides/website/setup_and_config/#css-and-js-assets","title":"CSS and JS Assets","text":"<p>Simmate doesn't distribute most source CSS and JavaScript files due to licensing restrictions on our third-party vendor assets. We use the Hyper theme from the CoderThemes team. You can contribute to Simmate's website using their Modern Dashboard template without needing to access any of the assets. Our templates load assets from a Simmate CDN:</p> <pre><code>&lt;!-- Normal asset loading with source code distribution --&gt;\n&lt;link href=\"assets/css/vendor/fullcalendar.min.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;\n\n&lt;!-- Simmate's CDN-based asset loading --&gt;\n&lt;link href=\"https://archives.simmate.org/assets/fullcalendar.min.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;\n</code></pre> <p>If you need to modify the CSS or JS, please contact our team to discuss the best approach.</p>"},{"location":"full_guides/website/creating_components/backend_mixins/","title":"Backend Mix-ins","text":""},{"location":"full_guides/website/creating_components/backend_mixins/#what-are-web-components","title":"What are web components?","text":"<p>Components let you build interactive web pages using Python and HTML, without needing JavaScript (we handle that part for you). So components work like mini Django views that automatically update when users interact with them.</p> <p>We need components because Django views are static HTML by default. In other words, once your view+template is loaded, it does not change until you (i) open a new link or (ii) refresh your page. So components come into play when you want to click a button and have the web page altered in some way -- such as checking a box and then having extra form options show up. For this, our HTML needs to include some JavaScript that updates the page for us -- all without refreshing the web page. Simmate web components integrate this JavaScript+AJAX calls, so that you can build things out in Python instead. This enables real-time interactivity in our web pages.</p>"},{"location":"full_guides/website/creating_components/backend_mixins/#do-i-need-components","title":"Do I need components?","text":"<p>Avoid overcomplicating things if you can. You can achieve quite a bit just with static HTML that ships with Django, and the only time you need components are when you have...</p> <ul> <li>a dynamic submission form (e.g., one that changes as a user fills it out)</li> <li>a need for real-time data analytics (e.g., manually refreshing your webpage isn't cutting it)</li> </ul> <p>Even if this applies to you, make sure you are already comfortable with HTML and <code>Django Templates</code> before messing with components.</p> <p>Tip</p> <p>A beginner-friendly alternative for building dynamic web pages is Streamlit. You can then make the app available within your Simmate app using an <code>iframe</code>: <pre><code>&lt;iframe src=\"{{ dashboard_url }}?embed=true\"\n        style=\"height:150vh;\n               width:100%;\n               border:none\"&gt;\n&lt;/iframe&gt;\n</code></pre></p>"},{"location":"full_guides/website/creating_components/backend_mixins/#django-unicorn-vs-simmate","title":"Django-Unicorn vs. Simmate","text":"<p>Simmate originally used Django-Unicorn to build out interactive pages. However, in order to address some of our use cases and loose bugs, we eventually forked &amp; refactored their codebase -- and now maintain our own internal copy. Still, nearly all features from Django-Unicorn's examples and documentation are still available.</p>"},{"location":"full_guides/website/creating_components/backend_mixins/#basic-example","title":"Basic Example","text":"<p>In your app, you can set up the following: <pre><code>\u251c\u2500\u2500 example_app\n\u2502   \u251c\u2500\u2500 components\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 todo.py\n\u2502   \u251c\u2500\u2500 templates\n\u2502   \u2502   \u251c\u2500\u2500 unicorn\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 todo.html\n\u2502   \u2502   \u2514\u2500\u2500 my_homepage.html\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 views.py\n</code></pre></p> <p>And for each file &amp; it's contents:</p> urls.pyviews.pytodo.pymy_homepage.htmltodo.html <pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.home, name='home'),\n]\n</code></pre> <pre><code>from django.shortcuts import render\n\ndef home(request):\n    context = {\"name\": \"Jane Doe\"}\n    return render(request, \"my_homepage.html\", context)\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\n\nclass TodoView(UnicornView):\n    task = \"\"\n    tasks = []\n\n    def add(self):\n        self.tasks.append(self.task)\n        self.task = \"\"\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Home Page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, {{ name }}! This is the home page rendered from a template.&lt;/h1&gt;\n        &lt;div&gt;\n            {% load unicorn %}\n            {% unicorn 'todo' %}\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;div&gt;\n    &lt;form unicorn:submit.prevent=\"add\"&gt;\n        &lt;input type=\"text\" unicorn:model.lazy=\"task\" placeholder=\"New task\" id=\"task\"&gt;&lt;/input&gt;\n    &lt;/form&gt;\n    &lt;button unicorn:click=\"add\"&gt;Add&lt;/button&gt;\n    &lt;p&gt;\n        {% if tasks %}\n            &lt;ul&gt;\n                {% for task in tasks %}\n                    &lt;li&gt;{{ task }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n            &lt;button unicorn:click=\"$reset\"&gt;Clear all tasks&lt;/button&gt;\n        {% else %}\n            No tasks!\n        {% endif %}\n    &lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#page-elements","title":"Page Elements","text":"<ul> <li><code>frontend</code> --&gt; <code>html (+js)</code></li> <li><code>backend</code> --&gt; <code>python</code></li> </ul>"},{"location":"full_guides/website/creating_components/backend_mixins/#text_input","title":"text_input","text":"frontendbackend <pre><code>{% text_input name=\"example\" %}\n</code></pre> <pre><code>example = \"some default text\"\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#text_area","title":"text_area","text":"frontendbackend <pre><code>{% text_area name=\"example\" %}\n</code></pre> <pre><code>example = \"some default text\"\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#number_input","title":"number_input","text":"frontendbackend <pre><code>{% number_input name=\"example\" %}\n</code></pre> <pre><code>example = 123\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#checkbox","title":"checkbox","text":"frontendbackend <pre><code>{% checkbox name=\"example\" %}\n</code></pre> <pre><code>example = True\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#button","title":"button","text":"frontendbackend <pre><code>{% button name=\"example\" %}\n</code></pre> <pre><code>def example(self):\n    # ... any python code \n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#selectbox","title":"selectbox","text":"frontendbackend <pre><code>{% selectbox name=\"example\" %}\n</code></pre> <pre><code>example = None\nexample_options = [\n    (\"label 1\", \"value 1\"),\n    (\"label 2\", \"value 2\"),\n    (\"label 3\", \"value 3\"),\n    # ...\n]\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#radio","title":"radio","text":"frontendbackend <pre><code>{% radio name=\"example\" %}\n</code></pre> <pre><code>example = None\nexample_options = [\n    (\"label 1\", \"value 1\"),\n    (\"label 2\", \"value 2\"),\n    (\"label 3\", \"value 3\"),\n    # ...\n]\n</code></pre>"},{"location":"full_guides/website/creating_components/backend_mixins/#molecule_input","title":"molecule_input","text":"frontendbackend <pre><code>{% molecule_input %}\n</code></pre> <pre><code>from simmate.website.core_components.components import (\n    DynamicFormComponent,\n    MoleculeInput,\n)\n\n\nclass TargetFormView(DynamicFormComponent, MoleculeInput):\n\n    class Meta:\n        javascript_exclude = (\n            # ...\n            *DynamicFormComponent.Meta.javascript_exclude,\n            *MoleculeInput.Meta.javascript_exclude,\n        )\n</code></pre> <p>search_box alert draw_molecule canvas</p>"},{"location":"full_guides/website/creating_components/backend_mixins/#backend-mix-ins","title":"Backend Mix-ins","text":""},{"location":"full_guides/website/creating_components/backend_mixins/#test-1","title":"test 1","text":""},{"location":"full_guides/website/creating_components/backend_mixins/#test-2","title":"test 2","text":""},{"location":"full_guides/website/creating_components/overview/","title":"Overview","text":""},{"location":"full_guides/website/creating_components/overview/#what-are-web-components","title":"What are web components?","text":"<p>Components let you build interactive web pages using Python and HTML, without needing JavaScript (we handle that part for you). So components work like mini Django views that automatically update when users interact with them.</p> <p>We need components because Django views are static HTML by default. In other words, once your view+template is loaded, it does not change until you (i) open a new link or (ii) refresh your page. So components come into play when you want to click a button and have the web page altered in some way -- such as checking a box and then having extra form options show up. For this, our HTML needs to include some JavaScript that updates the page for us -- all without refreshing the web page. Simmate web components integrate this JavaScript+AJAX calls, so that you can build things out in Python instead. This enables real-time interactivity in our web pages.</p>"},{"location":"full_guides/website/creating_components/overview/#do-i-need-components","title":"Do I need components?","text":"<p>Avoid overcomplicating things if you can. You can achieve quite a bit just with static HTML that ships with Django, and the only time you need components are when you have...</p> <ul> <li>a dynamic submission form (e.g., one that changes as a user fills it out)</li> <li>a need for real-time data analytics (e.g., manually refreshing your webpage isn't cutting it)</li> </ul> <p>Even if this applies to you, make sure you are already comfortable with HTML and <code>Django Templates</code> before messing with components.</p> <p>Tip</p> <p>A beginner-friendly alternative for building dynamic web pages is Streamlit. You can then make the app available within your Simmate app using an <code>iframe</code>: <pre><code>&lt;iframe src=\"{{ dashboard_url }}?embed=true\"\n        style=\"height:150vh;\n               width:100%;\n               border:none\"&gt;\n&lt;/iframe&gt;\n</code></pre></p>"},{"location":"full_guides/website/creating_components/overview/#django-unicorn-vs-simmate","title":"Django-Unicorn vs. Simmate","text":"<p>Simmate originally used Django-Unicorn to build out interactive pages. However, in order to address some of our use cases and loose bugs, we eventually forked &amp; refactored their codebase -- and now maintain our own internal copy. Still, nearly all features from Django-Unicorn's examples and documentation are still available.</p>"},{"location":"full_guides/website/creating_components/overview/#basic-example","title":"Basic Example","text":"<p>In your app, you can set up the following: <pre><code>\u251c\u2500\u2500 example_app\n\u2502   \u251c\u2500\u2500 components\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 todo.py\n\u2502   \u251c\u2500\u2500 templates\n\u2502   \u2502   \u251c\u2500\u2500 unicorn\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 todo.html\n\u2502   \u2502   \u2514\u2500\u2500 my_homepage.html\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 views.py\n</code></pre></p> <p>And for each file &amp; it's contents:</p> urls.pyviews.pytodo.pymy_homepage.htmltodo.html <pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.home, name='home'),\n]\n</code></pre> <pre><code>from django.shortcuts import render\n\ndef home(request):\n    context = {\"name\": \"Jane Doe\"}\n    return render(request, \"my_homepage.html\", context)\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\n\nclass TodoView(DynamicFormComponent):\n    task = \"\"\n    tasks = []\n\n    def add(self):\n        self.tasks.append(self.task)\n        self.task = \"\"\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Home Page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello, {{ name }}! This is the home page rendered from a template.&lt;/h1&gt;\n        &lt;div&gt;\n            {% load unicorn %}\n            {% unicorn 'todo' %}\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;div&gt;\n    &lt;form unicorn:submit.prevent=\"add\"&gt;\n        &lt;input type=\"text\" unicorn:model.lazy=\"task\" placeholder=\"New task\" id=\"task\"&gt;&lt;/input&gt;\n    &lt;/form&gt;\n    &lt;button unicorn:click=\"add\"&gt;Add&lt;/button&gt;\n    &lt;p&gt;\n        {% if tasks %}\n            &lt;ul&gt;\n                {% for task in tasks %}\n                    &lt;li&gt;{{ task }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n            &lt;button unicorn:click=\"$reset\"&gt;Clear all tasks&lt;/button&gt;\n        {% else %}\n            No tasks!\n        {% endif %}\n    &lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/button/","title":"button","text":"<p>Displays a button in the frontend that when clicked calls a python method in the backend.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/button/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% button name=\"my_method\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n\n    def my_method(self):\n        # ...\n        # run any python code\n        # ...\n        return  # nothing is done w. return values\n</code></pre> <p>Tip</p> <p>You methods can access and even update other attributes. </p> <p>For example, a <code>text_input</code> named <code>my_input</code> can be updated via: <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    my_input = \"some default value\"\n\n    def my_method(self):\n        self.my_input = \"the button has been clicked!\"\n</code></pre></p>"},{"location":"full_guides/website/creating_components/frontend_elements/button/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The name of the method to call in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>theme</code> CSS theme to use for coloring the button. Options are <code>primary</code>, <code>secondary</code>, <code>success</code>, <code>info</code>, <code>warning</code>, <code>danger</code>, and <code>dark</code>.Type: <code>str</code>, Default: <code>primary</code> <code>icon</code> Name of the icon to place in the button. Choose from the mdi catalog.Type: <code>str</code>, Default: <code>None</code> <code>small</code> The maximum number of characters allowed in the input field.Type: <code>int</code>, Default: <code>None</code>"},{"location":"full_guides/website/creating_components/frontend_elements/checkbox/","title":"checkbox","text":"<p>Displays a checkbox input widget and maps its value to the backend as a boolean.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/checkbox/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% checkbox name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    my_input = \"some default value\"\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/checkbox/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text to be shown alongside the input field.Type: <code>str</code>, Default: <code>None</code> <code>side_text</code> Text displayed to the right of the checkbox.Type: <code>str</code>, Default: <code>Yes/True</code> <code>defer</code> Whether to defer processing or submission of the input value.Type: <code>bool</code>, Default: <code>True</code>"},{"location":"full_guides/website/creating_components/frontend_elements/molecule_input/","title":"molecule_input","text":"<p>Displays a molecule sketcher widget and maps its value to the backend as a string + <code>toolkit.Molecule</code> object.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/molecule_input/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% molecule_input %}\n</code></pre> <pre><code>from simmate.website.core_components.components import (\n    DynamicFormComponent,\n    MoleculeInput,\n)\n\n\nclass TargetFormView(DynamicFormComponent, MoleculeInput):\n\n    class Meta:\n        javascript_exclude = (\n            *DynamicFormComponent.Meta.javascript_exclude,\n            *MoleculeInput.Meta.javascript_exclude,\n        )\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/molecule_input/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text to be shown alongside the input field.Type: <code>str</code>, Default: <code>None</code> <code>load_button</code> Whether to display a button that loads the molecule from the sketcher and the replaces the sketcher with the molecule image.Type: <code>str</code>, Default: <code>None</code> <code>set_molecule_method</code> Name of the method that parses the molecule and sets the python class attribute.Type: <code>str</code>, Default: <code>None</code> <code>many_molecules</code> Whether to allow input of multiple molecules (e.g., as a list or batch input).Type: <code>bool</code>, Default: <code>False</code> <p>For the molecule sketcher:</p> Parameter Description <code>allow_sketcher_input</code> Whether to allow molecule input via a sketcher widget.Type: <code>bool</code>, Default: <code>True</code> <code>sketcher_input_label</code> The label to display above the sketcher input.Type: <code>str</code>, Default: <code>\"Draw Molecule\"</code> <p>For the text input area:</p> Parameter Description <code>allow_text_input</code> Whether to allow molecule input via a text area (e.g., SMILES, mol block).Type: <code>bool</code>, Default: <code>False</code> <code>text_input_name</code> The unique name or identifier for the text input field. If not provided, defaults to <code>name</code> + <code>_text</code>.Type: <code>str</code>, Default: <code>None</code> <code>text_input_label</code> The label to display above the text input area.Type: <code>str</code>, Default: <code>\"Paste Molecule Text\"</code> <p>For the \"custom input\" area (e.g., IDs from other table):</p> Parameter Description <code>allow_custom_input</code> Whether to allow a custom input field (e.g., for IDs or external references).Type: <code>bool</code>, Default: <code>False</code> <code>custom_input_name</code> The unique name or identifier for the custom input field. If not provided, defaults to <code>name</code> + <code>_custom</code>.Type: <code>str</code>, Default: <code>None</code> <code>custom_input_label</code> The label to display above the custom input field.Type: <code>str</code>, Default: <code>\"Custom Input\"</code> <code>custom_input_placeholder</code> Placeholder text for the custom input field.Type: <code>str</code>, Default: <code>\"12345\"</code>"},{"location":"full_guides/website/creating_components/frontend_elements/number_input/","title":"number_input","text":"<p>Displays a numeric input widget and maps its value to the backend as either a <code>float</code> or <code>int</code>.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/number_input/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% number_input name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    my_input = 1234\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/number_input/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text to be shown alongside the input field.Type: <code>str</code>, Default: <code>None</code> <code>placeholder</code> The placeholder text to display when input field is empty.Type: <code>str</code>, Default: <code>\"Enter details...\"</code> <code>maximum</code> Maximum value allowed to be entered by user. <code>None</code> means no limit. Type: <code>float</code>, Default: <code>None</code> <code>minimum</code> Minimum value allowed to be entered by user. <code>None</code> means no limit. Type: <code>float</code>, Default: <code>None</code> <code>is_int</code> Whether the input is an integer (set to <code>True</code>) or a float (set to <code>False</code>). Type: <code>bool</code>, Default: <code>False</code> <code>step_size</code> Descrete step size of the number. <code>None</code> means it is a continuos float value with no limit on digits. Type: <code>int</code>, Default: <code>None</code> <code>defer</code> Whether to defer processing or submission of the input value.Type: <code>bool</code>, Default: <code>True</code>"},{"location":"full_guides/website/creating_components/frontend_elements/radio/","title":"radio","text":"<p>Displays a radio select input widget and maps its value to the backend as a string.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/radio/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% radio name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n\n    my_input = None\n\n    my_input_options = [\n        (\"label1\", \"value1\"),\n        (\"label2\", \"value2\"),\n        (\"label3\", \"value3\"),\n        # ...\n    ]\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/radio/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>options</code> The name of the class attribute that holds all options for the dropdown menu. In python, options should be a list of <code>('label', 'value')</code>, where <code>label</code> is what's shown in the UI and <code>value</code> is what is set in python.Type: <code>str</code>, Default: `f\"{name}_options\" <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code>"},{"location":"full_guides/website/creating_components/frontend_elements/search_box/","title":"search_box","text":"<p>Displays a search box widget that combines a selectbox (optional), a single-line text input, and a button. Useful for search/filter interfaces.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/search_box/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% search_box name=\"search_query\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    search_query = \"\"\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/search_box/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the text input field. Should match the backend attribute.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input. If not provided, a label is auto-generated from <code>name</code>.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text shown alongside the input.Type: <code>str</code>, Default: <code>None</code> <code>disabled</code> If <code>True</code>, disables the input field.Type: <code>bool</code>, Default: <code>False</code> <p>For the text input:</p> Parameter Description <code>placeholder</code> Placeholder text for the input field.Type: <code>str</code>, Default: <code>\"Type value...\"</code> <code>max_length</code> Maximum number of characters allowed in the input.Type: <code>int</code>, Default: <code>None</code> <p>For the selectbox:</p> Parameter Description <code>show_selectbox</code> Whether to include a dropdown selectbox before the input.Type: <code>bool</code>, Default: <code>False</code> <code>selectbox_name</code> Name/id for the selectbox. If not provided, auto-generated as <code>{name}_type</code>.Type: <code>str</code>, Default: <code>f\"{name}_type\"</code> <code>selectbox_options</code> The name of the class attribute that holds all options for the selectbox. In python, options should be a list of <code>('label', 'value')</code>, where <code>label</code> is what's shown in the UI and <code>value</code> is what is set in python.*Type: <code>str</code>, Default: <code>f\"{selectbox_name}_options\"</code> <p>For the button:</p> Parameter Description <code>button_name</code> The name/id for the button. If not provided, auto-generated as <code>set_{name}</code>.Type: <code>str</code>, Default: <code>None</code> <code>button_theme</code> Visual theme for the button (e.g., <code>\"primary\"</code>).Type: <code>str</code>, Default: <code>\"primary\"</code> <code>button_icon</code> Icon name for the button.Type: <code>str</code>, Default: <code>\"magnify\"</code>"},{"location":"full_guides/website/creating_components/frontend_elements/selectbox/","title":"selectbox","text":"<p>Displays a selectbox input widget and maps its value to the backend as a string.</p> <p>We use Select2 under the hood to make the dropdown searchable.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/selectbox/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% selectbox name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n\n    my_input = None\n\n    my_input_options = [\n        (\"label1\", \"value1\"),\n        (\"label2\", \"value2\"),\n        (\"label3\", \"value3\"),\n        # ...\n    ]\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/selectbox/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>options</code> The name of the class attribute that holds all options for the dropdown menu. In python, options should be a list of <code>('label', 'value')</code>, where <code>label</code> is what's shown in the UI and <code>value</code> is what is set in python.Type: <code>str</code>, Default: `f\"{name}_options\" <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>dynamic_options</code> Whether the options list changes while the component is being updated. If your options are static, set this to <code>False</code> &amp; add your options to <code>javascript_exclude</code> to improve performance.Type: <code>bool</code>, Default: <code>False</code> <code>allow_custom_input</code> Whether the user can type in their own value, in addition to the options listed.Type: <code>bool</code>, Default: <code>False</code> <code>multiselect</code> Whether the user can select more than 1 option from the dropdown. When <code>True</code>, the python attribute for <code>name</code>  becomes a list of strings.Type: <code>bool</code>, Default: <code>False</code>"},{"location":"full_guides/website/creating_components/frontend_elements/text_area/","title":"text_area","text":"<p>Displays a multi-line text input widget and maps its value to the backend as a string.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/text_area/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% text_area name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    my_input = \"some default value\"\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/text_area/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text to be shown alongside the input field.Type: <code>str</code>, Default: <code>None</code> <code>placeholder</code> The placeholder text to display when input field is empty.Type: <code>str</code>, Default: <code>\"Enter details...\"</code> <code>ncols</code> The number of columns that the text area should render with.Type: <code>int</code>, Default: <code>4</code> <code>nrows</code> The number of rows that the text area should render with.Type: <code>int</code>, Default: <code>30</code> <code>defer</code> Whether to defer processing or submission of the input value.Type: <code>bool</code>, Default: <code>True</code>"},{"location":"full_guides/website/creating_components/frontend_elements/text_input/","title":"text_input","text":"<p>Displays a single-line text input widget and maps its value to the backend as a string.</p>"},{"location":"full_guides/website/creating_components/frontend_elements/text_input/#basic-use","title":"Basic use","text":"frontend (html+django)backend (python) <pre><code>{% text_input name=\"my_input\" %}\n</code></pre> <pre><code>from simmate.website.core_components.components import DynamicFormComponent\n\nclass ExampleView(DynamicFormComponent):\n    my_input = \"some default value\"\n</code></pre>"},{"location":"full_guides/website/creating_components/frontend_elements/text_input/#parameters","title":"Parameters","text":"Parameter Description <code>name</code> The unique name or identifier for the input field. This should match the name of your class attribute in the backend.Type: <code>str</code>, Default: \u2014 <code>label</code> The display label for the input field. If not provided, the <code>name</code> may be used as the label.Type: <code>str</code>, Default: <code>None</code> <code>show_label</code> Whether to display the label alongside the input field.Type: <code>bool</code>, Default: <code>True</code> <code>help_text</code> Optional helper text to be shown alongside the input field.Type: <code>str</code>, Default: <code>None</code> <code>placeholder</code> The placeholder text to display when input field is empty.Type: <code>str</code>, Default: <code>\"Type value...\"</code> <code>max_length</code> The maximum number of characters allowed in the input field.Type: <code>int</code>, Default: <code>None</code> <code>disabled</code> If <code>True</code>, the input field will be rendered as disabled and not editable.Type: <code>bool</code>, Default: <code>False</code> <code>defer</code> Whether to defer processing or submission of the input value.Type: <code>bool</code>, Default: <code>True</code>"},{"location":"full_guides/workflows/basic_use/","title":"Basic Workflow Use","text":""},{"location":"full_guides/workflows/basic_use/#list-available-workflows","title":"List Available Workflows","text":"command linepython <pre><code>simmate workflows list-all\n</code></pre> <pre><code>from simmate.workflows.utilities import get_all_workflow_names\n\nnames = get_all_workflow_names()\n</code></pre> <p>There are several more tools in <code>simmate.workflow.utilities</code> to help explore:</p> utility name <code>get_all_workflows</code> <code>get_all_workflow_names</code> <code>get_all_workflow_types</code> <code>get_apps_by_type</code> <code>get_workflow_names_by_type</code>"},{"location":"full_guides/workflows/basic_use/#load-a-workflow","title":"Load a Workflow","text":"<p>\"Loading\" a workflow only applies in python. Use the <code>get_workflow</code> method, which will return the requested <code>Workflow</code> subclass:</p> python <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow_name = \"static-energy.vasp.matproj\"\nworkflow = get_workflow(workflow_name)\n</code></pre>"},{"location":"full_guides/workflows/basic_use/#view-parameters-options","title":"View Parameters &amp; Options","text":"<p>For detailed information about a specific workflow's parameters:</p> command linepython <pre><code>simmate workflows explore\n</code></pre> <pre><code>workflow.show_parameters()\n</code></pre> <p>There are several properties &amp; methods available for all <code>Workflow</code> subclasses:    </p> property/method name <code>show_parameters()</code> <code>parameter_names</code> <code>parameter_names_required</code> <code>parameter_defaults</code> <p>Tip</p> <p>We've dedicated a entire section of our documentation to workflow parameters. Please familiarize yourself with this section for detailed parameter descriptions and examples.</p>"},{"location":"full_guides/workflows/basic_use/#run-a-workflow-local","title":"Run a Workflow (Local)","text":"<p>To execute a workflow on your local machine, use the <code>run</code> approach:</p> yamlcommand linetomlpythonwebsite <pre><code># in example.yaml\nworkflow_name: relaxation.vasp.matproj\nstructure: NaCl.cif\ncommand: mpirun -n 8 vasp_std &gt; vasp.out\n</code></pre> <pre><code>simmate workflows run example.yaml\n</code></pre> <pre><code>simmate workflows run-quick relaxation.vasp.matproj --structure NaCl.cif\n</code></pre> <pre><code># in example.toml\nworkflow_name = \"relaxation.vasp.matproj\"\nstructure = \"NaCl.cif\"\ncommand = \"mpirun -n 8 vasp_std &gt; vasp.out\"\n</code></pre> <pre><code>simmate workflows run example.toml\n</code></pre> <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"relaxation.vasp.matproj\")\nstatus = workflow.run(structure=\"NaCl.cif\")\nresult = status.result()\n</code></pre> <pre><code>https://simmate.org/workflows/static-energy/vasp/matproj/submit\n</code></pre>"},{"location":"full_guides/workflows/basic_use/#run-a-workflow-cloud","title":"Run a Workflow (Cloud)","text":"<p>Workflows can also be executed on a remote cluster. It's important to understand the differences between local and cloud runs:</p> local (run)remote submission (run-cloud) <pre><code>graph TD\n  A[submit with 'run' command] --&gt; B[starts directly on your local computer &amp; right away];</code></pre> <pre><code>graph TD\n  A[submit with 'run-cloud' command] --&gt; B[adds job to scheduler queue];\n  B --&gt; C[waits for a worker to pick up job];\n  C --&gt; D[worker selects job from queue];\n  D --&gt; E[runs the job where the worker is];\n  F[launch a worker with 'start-worker' command] --&gt; D;</code></pre> <p>To schedule a workflow to run on a remote cluster, ensure your computational resources are configured. Then, use the <code>run_cloud</code> method:</p> command linepython <p><pre><code># in example.yaml\nworkflow_name: static-energy.vasp.matproj\nstructure: NaCl.cif\ncommand: mpirun -n 4 vasp_std &gt; vasp.out\n</code></pre> <pre><code>simmate workflows run-cloud example.yaml\n</code></pre></p> <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"static-energy.vasp.matproj\")\n\nstatus = workflow.run_cloud(\n    structure=\"NaCl.cif\", \n    command=\"mpirun -n 4 vasp_std &gt; vasp.out\",\n)\n\nresult = state.result() # (1)\n</code></pre> <ol> <li>This will block and wait for the job to finish</li> </ol> <p>Warning</p> <p>The <code>run-cloud</code> command/method only schedules the workflow. It won't  run until you add computational resources (or <code>Workers</code>). To do this, you must read through the \"Computational Resources\" documentation.</p>"},{"location":"full_guides/workflows/basic_use/#view-workflow-results","title":"View Workflow Results","text":""},{"location":"full_guides/workflows/basic_use/#option-1-output-files","title":"Option 1: Output Files","text":"<p>Navigate to the directory where the calculation was run to find output files (if any). Some of these include:</p> <ul> <li><code>simmate_metadata.yaml</code>: original input parameters for the workflow run</li> <li><code>simmate_summary.yaml</code>: a summary of information that is saved to the database</li> <li><code>simmate_corrections.csv</code>: lists the errors encountered (if any) and how they were resolved</li> <li>others: for example, <code>relaxation</code> &amp; <code>electronic-structure</code> will output plots</li> </ul> <p>Tip</p> <p>While the plots and summary files are useful for quick viewing, there is much  more information available in the database.</p>"},{"location":"full_guides/workflows/basic_use/#option-2-python-objects","title":"Option 2: Python Objects","text":"<p>Access the result directly in python. Workflows can return <code>any</code> - however, workflows that save to a database table will return the actual database object. </p> python <pre><code>status = workflow.run(...)\nresult = state.result()  # (1)\n</code></pre> <ol> <li>Returns a <code>Database</code> object. In some cases, you can convert to a <code>toolkit</code> structure using <code>result.to_toolkit()</code></li> </ol> <p>For viewing the results of many workflow runs:</p> python <pre><code>results = workflow.all_results  # (1)\n</code></pre> <ol> <li>This takes the relevent table (e.g. <code>StaticEnergy</code>) and filters down to all results matching this workflow name.</li> </ol> <p>Tip</p> <p>View the Database guides for advanced filtering and data manipulation.</p>"},{"location":"full_guides/workflows/basic_use/#option-3-the-database","title":"Option 3: The Database","text":"<p>You can view the data directly via SQL. For example:</p> SQL <pre><code>SELECT *\nFROM workflows_staticenergy\nWHERE workflow_name = 'static-energy.vasp.mit'\n</code></pre> <p>Tip</p> <p>We recommend exploring database tables using DBeaver</p>"},{"location":"full_guides/workflows/basic_use/#option-4-the-website-server","title":"Option 4: The Website Server","text":"<p>Warning</p> <p>this is an experimental feature and still in early development</p> <p>In the <code>simmate_summary.yaml</code> output file, there is the <code>_WEBSITE_URL_</code>. You can copy/paste this URL into your browser and view your results in an interactive format. Just make sure you are running your local server first:</p> <pre><code>simmate run-server\n</code></pre> <p>Then open the link given by <code>_WEBSITE_URL_</code>:</p> <pre><code>http://127.0.0.1:8000/workflows/static-energy/vasp/mit/1\n</code></pre>"},{"location":"full_guides/workflows/basic_use/#run-massively-parallel-workflows","title":"Run Massively Parallel Workflows","text":"<p>Some workflows submit many subworkflows. For example, evolutionary structure prediction does this by submitting hundreds of individual structure relaxations, analyzing the results, and submitting new structures based on the results.</p> <p>This is achieved by the workflow manually calling <code>run-cloud</code> on others. If you start multiple workers elsewhere, you can calculate these subworkflows in parallel:</p> <pre><code>graph TD\n  A[main workflow];\n  A --&gt; B[subworkflow];\n  B --&gt; C[schedule run 1] --&gt; G[scheduler];\n  B --&gt; D[schedule run 2] --&gt; G;\n  B --&gt; E[schedule run 3] --&gt; G;\n  B --&gt; F[schedule run 4] --&gt; G;\n  G --&gt; H[worker 1];\n  G --&gt; I[worker 2];\n  G --&gt; J[worker 3];</code></pre> <p>To run these types of workflows, you must:</p> <ol> <li>Start the main workflow with the <code>run</code> command</li> <li>Start at least one worker that will run the submitted calculations</li> </ol> <p>Note</p> <p>The number of workers will determine how many jobs are run in parallel -- and this is only limited by the number of jobs queued. For example, if I submit 500 workflows with <code>run-cloud</code> but only start 100 workers, then only 100 workflows will be run at a time. Further, if I submit 25 workflows but have 100 workers, then that means 75 of our workflows will be sitting idle without any job to run.</p>"},{"location":"full_guides/workflows/creating_basic_workflows/","title":"Creating New Workflows","text":"<p>Warning</p> <p>Class-based workflows must follow Simmate naming conventions to work properly.</p>"},{"location":"full_guides/workflows/creating_basic_workflows/#basic-workflows","title":"Basic Workflows","text":"<p>Any python function can be a workflow. There are two steps to convert it:</p> <ol> <li>add the <code>@workflow</code> decorator</li> <li>include <code>**kwargs</code> as an input</li> </ol> <p>For example:</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef add(x, y, **kwargs):\n    return x + y\n\nstatus = add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>As you build more advanced workflows, you may want to switch to a class-based format. To do this, you must:</p> <ol> <li>set the class name using Simmate conventions</li> <li>define a <code>run_config</code> method</li> <li>add <code>@staticmethod</code> or <code>@classmethod</code> to <code>run_config</code></li> <li>include <code>**kwargs</code> as an input to <code>run_config</code></li> </ol> <p>For example (using the same function as above):</p> <pre><code>from simmate.workflows import Workflow\n\nclass Math__Basic__Add(Workflow):\n\n    use_database = False  # we don't have a database table yet\n\n    @staticmethod\n    def run_config(x, y, **kwargs):\n        return x + y\n\nstatus = Math__Basic__Add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>Tip</p> <p>Stick to <code>@workflow</code> for simple utilities. Class-based workflows are more important for sharing advanced features. For example, this is how we build reusable classes such as <code>VaspWorkflow</code> or <code>S3Workflow</code>, which are cover elsewhere in our guides.</p> <p>Example</p> <p>Here's is a more advanced example that shows how class-based workflows can take advantage of other class methods:</p> <pre><code>class Example__Python__Add100(Workflow):\n\n    use_database = False # we don't have a database table yet\n\n    constant = 100\n\n    @classmethod\n    def add_constant(cls, x):\n        return x + cls.constant\n\n    @classmethod\n    def run_config(cls, x, **kwargs):\n        return cls.add_constant(x)\n</code></pre> <p>And also leverage class inheritance to reuse code:</p> <pre><code># we inherit from the class above!\nclass Example__Python__Add300(Example__Python__Add100):\n    constant = 300\n</code></pre>"},{"location":"full_guides/workflows/creating_basic_workflows/#extra-kwargs-provided","title":"Extra <code>**kwargs</code> provided","text":"<p>In the workflows above, we used <code>**kwargs</code> in each of our workflows. This is because Simmate automatically passes default parameters to the <code>run_config</code> method -- even if you didn't define them as inputs when calling <code>run()</code>. </p> <p>We do this to allow all workflows to access key information about the run. These parameters are:</p> <ul> <li><code>run_id</code>: a unique id for tracking a calculation</li> <li><code>directory</code>: a unique folder name where the calculation will take place</li> <li><code>compress_output</code>: whether to compress the directory to a zip file when completed</li> <li><code>source</code>: where the input of this calculation came from (experimental feature)</li> </ul> <p>You can use any of these inputs to assist with your workflow. Alternatively, just add <code>**kwargs</code> to your function and ignore them.</p> <p>Example</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef example(run_id, **kwargs):\n    print(run_id)\n    print(**kwargs)  # to view others\n\nstatus = add.run()  # We don't have to provide `run_id`\nresult = status.result()\n</code></pre>"},{"location":"full_guides/workflows/creating_basic_workflows/#using-toolkit-parameters","title":"Using <code>toolkit</code> Parameters","text":"<p>You often will use input parameters that correspond to <code>toolkit</code> objects, such as <code>Structure</code> or <code>Composition</code>. If you use the matching input parameter name, these will inherit all of their features -- such as loading from filename, a dictionary, or python object.</p> <p>For example, if you use a <code>structure</code> input variable, it behaves as described in the Parameters section.</p> <pre><code>from simmate.toolkit import Structure\nfrom simmate.workflows import Workflow\n\nclass Example__Python__GetVolume(Workflow):\n\n    use_database = False  # we don't have a database table yet\n\n    @staticmethod\n    def run_config(structure, **kwargs):\n        assert type(structure) == Structure  # (1) \n        return structure.volume  # (2)\n</code></pre> <ol> <li>Even if we give a filename as an input, Simmate will convert it to a <code>toolkit</code> object for us</li> <li>you can interact with the structure object because it is a <code>toolkit</code> object</li> </ol> <p>Tip</p> <p>If you see a parameter in our documentation that has similar use to yours, make sure you use the same name. It can help with adding extra functionality.</p>"},{"location":"full_guides/workflows/creating_basic_workflows/#writing-output-files","title":"Writing Output Files","text":"<p>Of all the default parameters (described above in <code>**kwargs</code>), you'll likely get the most from using the <code>directory</code> input. </p> <p><code>directory</code> is given as a <code>pathlib.Path</code> object. Just add the directory to your <code>run_config()</code> method and use the object that's provided. For example:</p> <pre><code>from simmate.workflows import Workflow\n\nclass Example__Python__WriteFile(Workflow):\n\n    use_database = False  # we don't have a database table yet\n\n    @staticmethod\n    def run_config(directory, **kwargs):\n        output_file = directory / \"my_output.txt\" # (1)\n        with output_file.open(\"w\") as file:\n            file.write(\"Writing my output!\")\n        return \"Done!\"\n\nExample__Python__WriteFile.run()  # (2)\n</code></pre> <ol> <li>We use the <code>directory</code> created by Simmate and it will automatically be a <code>path.Pathlib</code> object</li> <li>We don't need to define the <code>directory</code> as Simmate automatically builds one. We can, however, provide one if we wish.</li> </ol>"},{"location":"full_guides/workflows/creating_basic_workflows/#progam-specific-workflows","title":"Progam-specific Workflows","text":"<p>For many apps, there are workflow classes that you can use as a starting point. Make sure you explore the Apps section of our documentation to see what is available.</p> <p>For example, VASP users can inherit from the <code>VaspWorkflow</code> class, which includes many built-in features:</p> basic VASP example <pre><code>from simmate.apps.vasp.workflows.base import VaspWorkflow\n\nclass Relaxation__Vasp__MyExample1(VaspWorkflow):\n\n    functional = \"PBE\"\n    potcar_mappings = {\"Y\": \"Y_sv\", \"C\": \"C\"}\n\n    _incar = dict(\n        PREC=\"Normal\",\n        EDIFF=1e-4,\n        ENCUT=450,\n        NSW=100,\n        KSPACING=0.4,\n    )\n</code></pre>"},{"location":"full_guides/workflows/creating_basic_workflows/#building-from-existing-workflows","title":"Building from Existing Workflows","text":"<p>Class-based workflows can leverage Python inheritance to borrow utilities and settings from an existing workflows.</p> <p>Here is an example using a workflow from the <code>VASP</code> app:</p> <pre><code>from simmate.workflows.utilities import get_workflow\n\noriginal_workflow = get_workflow(\"static-energy.vasp.matproj\")\n\n\nclass StaticEnergy__Vasp__MyCustomPreset(original_workflow):\n\n    _incar_updates = dict(\n        NPAR=1,\n        ENCUT=-1,\n    )\n</code></pre> <p>Note</p> <p>How you update a workflow depends on the app you are using. Be sure to read the Apps section of our documentation for more information.</p>"},{"location":"full_guides/workflows/creating_basic_workflows/#linking-a-database-table","title":"Linking a Database Table","text":"<p>Many workflows will want to store common types of data (such as static energy or relaxation data). If you want to use these tables automatically, you simply need to ensure your <code>name_type</code> matches what is available.</p> <p>For example, if we look at a static-energy calculation, you will see the <code>StaticEnergy</code> database table is automatically used because the name of our workflow starts with <code>StaticEnergy</code>:</p> <pre><code>from simmate.database import connect\nfrom simmate.database.workflow_results import StaticEnergy\n\nassert StaticEnergy__Vasp__MyCustomPreset.database_table == StaticEnergy\n</code></pre> <p>If you want to build or use a custom database, you must first have a registered <code>DatabaseTable</code>, and then you can link the database table to your workflow directly. The only other requirement is that your database table uses the <code>Calculation</code> database mix-in:</p> <pre><code>from my_project.models import MyCustomTable\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n    database_table = MyCustomTable\n</code></pre>"},{"location":"full_guides/workflows/creating_basic_workflows/#workflows-that-call-a-command","title":"Workflows that Call a Command","text":"<p>In many cases, you may have a workflow that runs a command or some external program and then reads the results from output files. An example of this would be an energy calculation using VASP. If your workflow involves calling another program, you should read about the \"S3\" workflow (<code>S3Workflow</code>) which helps with writing input files, calling other programs, and handling errors.</p>"},{"location":"full_guides/workflows/creating_basic_workflows/#registering-your-workflow","title":"Registering Your Workflow","text":"<p>Registering your workflow so that you can access it in the UI requires you to build a \"simmate project\". This is covered in the getting-started tutorials.</p>"},{"location":"full_guides/workflows/creating_nested_workflows/","title":"Creating nested workflows","text":""},{"location":"full_guides/workflows/creating_nested_workflows/#overview","title":"Overview","text":"<p>Workflows can incorporate any Python code, enabling them to invoke other workflows using the <code>run</code> or <code>run_cloud</code> methods. This functionality allows for the sequential execution of multiple workflows or their submission to a cluster for large-scale analyses.</p>"},{"location":"full_guides/workflows/creating_nested_workflows/#running-a-workflow-repeatedly","title":"Running a Workflow Repeatedly","text":"<p>You can use the <code>run</code> method of a workflow within another workflow for repeated runs.</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False  # no database table yet\n\n    @staticmethod\n    def run_config(structure, **kwargs):\n\n        another_workflow = get_workflow(\"static-energy.vasp.mit\")\n\n        for n in range(10):\n            structure.perturb(0.05)  # in-place modification\n            state = another_workflow.run(structure=structure)\n            result = state.result()\n            # ... process the result\n</code></pre> <p>Note</p> <p>The <code>state.result()</code> call is used just like in a regular workflow run. The usage remains the same.</p>"},{"location":"full_guides/workflows/creating_nested_workflows/#running-multiple-workflows","title":"Running Multiple Workflows","text":"<p>You can call a series of workflows on an input. The <code>run_config</code> accepts any Python code, so the workflow usage remains unchanged:</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False\n\n    @staticmethod\n    def run_config(structure, directory, **kwargs):\n\n        subworkflow_1 = get_workflow(\"static-energy.vasp.mit\")\n        subworkflow_1.run(structure=structure)\n\n        subworkflow_2 = get_workflow(\"population-analysis.vasp.elf-matproj\")\n        subworkflow_2.run(structure=structure)\n\n        subworkflow_3 = get_workflow(\"electronic-structure.vasp.matproj-full\")\n        subworkflow_3.run(structure=structure)      \n</code></pre>"},{"location":"full_guides/workflows/creating_nested_workflows/#storing-all-runs-in-a-shared-directory","title":"Storing All Runs in a Shared Directory","text":"<p>To save the results of all workflows in a single location, manually set the directory for each subworkflow run:</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False\n\n    @staticmethod\n    def run_config(structure, directory, **kwargs):  \n        another_workflow = get_workflow(\"static-energy.vasp.mit\")\n        for n in range(10):\n            structure.perturb(0.05)\n\n            subdirectory = directory / f\"perturb_number_{n}\"\n\n            another_workflow.run(\n                structure=structure,\n                directory=subdirectory, # creates a subdirectory for this run\n            )\n</code></pre> <p>Danger</p> <p>Do NOT share a working directory when using <code>run_cloud</code>. This can lead to problems when resources are distributed across different computers and file systems. Refer to github #237 for more information.</p>"},{"location":"full_guides/workflows/creating_nested_workflows/#transferring-results-between-runs","title":"Transferring Results Between Runs","text":"<p>You can pass the result from one subworkflow to the next subworkflow by interacting with the database object.</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False\n\n    @staticmethod\n    def run_config(structure, directory, **kwargs):\n\n        subworkflow_1 = get_workflow(\"relaxation.vasp.mit\")\n        state_1 = subworkflow_1.run(structure=structure)\n        result_1 = state_1.result()\n\n        subworkflow_2 = get_workflow(\"static-energy.vasp.mit\")\n        state_2 = subworkflow_2.run(\n            structure=result_1,  # use the final structure of the last calculation\n        )\n        result_2 = state_2.result()\n\n        if result_2.energy_per_atom &gt; 0:\n            print(\"Structure is very unstable even after relaxing!\")\n            structure_new = result_2.to_toolkit()\n            structure_new.scale_lattice(\n                volume=structure.volume * 1.2,\n            )\n            state_2 = subworkflow_2.run(\n                structure=structure_new,  # use the modified structure\n            )\n</code></pre>"},{"location":"full_guides/workflows/creating_nested_workflows/#transferring-files-between-runs","title":"Transferring Files Between Runs","text":"<p>A workflow can require a file from a previous calculation as an input. This can be specified using the <code>use_previous_directory</code> attribute, which copies files from the previous directory to the current one.</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False\n    use_previous_directory = [\"filename1\", \"filename2\"]\n\n    @staticmethod\n    def run_config(structure, directory, previous_directory, **kwargs):\n\n        expected_file1 = directory / \"filename1\"\n        assert expected_file1.exists()\n\n        expected_file2 = directory / \"filename2\"\n        assert expected_file2.exists()\n</code></pre> <p>Workflows with <code>use_previous_directory</code> set to True or a list of filenames MUST provide either a <code>previous_directory</code> parameter or a database object from a previous calculation as the <code>structure</code> parameter.</p> <pre><code>workflow.run(previous_directory=\"path/to/my/folder\")\n</code></pre> <pre><code>status = setup_workflow.run()\nprevious_result = status.result()\n\nworkflow.run(structure=previous_result)\n</code></pre> <p>Tip</p> <p>File copying/passing should be used for large files and data chunks. Small data pieces should be passed between workflows using Python objects and the database.</p>"},{"location":"full_guides/workflows/creating_nested_workflows/#submitting-parallel-workflows","title":"Submitting Parallel Workflows","text":"<p>For situations where you don't want to wait for each workflow run to finish or need to submit hundreds of independent workflow runs, use the <code>run_cloud</code> command instead of <code>run</code>.</p> <pre><code>from simmate.workflows.utilities import get_workflow\nfrom simmate.workflows import Workflow\n\nclass Example__Python__MyFavoriteSettings(Workflow):\n\n    use_database = False\n\n    @staticmethod\n    def run_config(structure, **kwargs):\n\n        another_workflow = get_workflow(\"static-energy.vasp.mit\")\n\n        submitted_states = []\n\n        for n in range(10):\n            structure.perturb(0.05)\n\n            state = another_workflow.run_cloud(structure=structure)\n\n            submitted_states.append(state)\n\n        results = [state.result() for state in submitted_states]\n\n        for result in results:\n            print(result.energy_per_atom)\n</code></pre> <p>Danger</p> <p>Do NOT share a working directory when using <code>run_cloud</code>. This can lead to problems when resources are distributed across different computers and file systems. Refer to github #237 for more information.</p> <p>Tip</p> <p>The <code>state.result()</code> call to wait for each result is optional. You can even have a workflow that just submits runs and then shuts down without ever waiting on the results.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/","title":"Overview of Supervised-Staged-Shell Workflow","text":""},{"location":"full_guides/workflows/creating_s3_workflows/#what-is-an-s3workflow","title":"What is an <code>S3Workflow</code>?","text":"<p>An <code>S3Workflow</code> involves writing input files, calling an external program, and reading the output files. The term \"S3\" stands for Supervised, Staged, and Shell call. Here's what each term means:</p> <ul> <li><code>Staged</code>: The calculation consists of three stages (each is a class method)<ol> <li><code>setup</code> = write input files</li> <li><code>execute</code> = run &amp; monitor the program</li> <li><code>workup</code> = read the output files</li> </ol> </li> <li><code>Shell</code>: The program is called through the command-line (the actual <code>execute</code> call)</li> <li><code>Supervised</code>: Simmate monitors the shell command for errors in the background (occurs during the <code>execute</code> call)</li> </ul> <p>Together, the <code>run</code> method of an <code>S3Workflow</code> carries out the following:</p> <pre><code>graph LR\n  A[Start] --&gt; B[setup];\n  B --&gt; C[execute];\n  C --&gt; D[workup];\n  D --&gt; E[Has errors?];\n  E --&gt;|Yes| B;\n  E --&gt;|No| F[Done!];</code></pre> <p>Warning</p> <p>The diagram is slightly misleading as the \"Has Errors?\" check also occurs while the execute step is still running. This allows for early error detection before the program completes its run.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#creating-s3workflows","title":"Creating S3Workflows","text":"<p>For commonly used material science programs, refer to their guides in the \"Third-party Software\" section. If your program is listed there, a subclass of <code>S3Workflow</code> is likely already available. For instance, VASP users can use <code>VaspWorkflow</code> to build workflows.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#building-a-custom-s3workflow","title":"Building a Custom S3Workflow","text":"<p>Tip</p> <p>Before creating a custom <code>S3Workflow</code>, ensure you've read the section on S3Workflows for common programs like VASP and the guides on building a custom <code>Workflow</code>.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#simple-command-call","title":"Simple Command Call","text":"<p>The simplest example of an S3Workflow is a single command call without any additional actions (no input files, no error handling, etc.). </p> <p>Unlike custom <code>Workflows</code> where we define a <code>run_config</code> method, <code>S3Workflows</code> have a pre-built <code>run_config</code> method that handles the different stages and monitoring of a workflow. </p> <p>For instance, let's use the <code>echo</code> command to print something:</p> <pre><code>from simmate.workflows.base_flow_types import S3Workflow\n\nclass Example__Echo__SayHello(S3Workflow):\n    use_database = False  # no custom table for now\n    monitor = False  # no error handling yet\n    command = \"echo Hello\"\n\n# behaves like a normal workflow\nstate = Example__Echo__SayHello.run()\nresult = state.result()\n</code></pre> <p>Tip</p> <p>Note the use of \"Echo\" in our workflow name. This helps users understand what commands or programs will be run when a workflow is executed.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#custom-setup-and-workup","title":"Custom Setup and Workup","text":"<p>If you need to write input files or read output files, you'll need to update your <code>setup</code> and <code>workup</code> methods:</p> <pre><code>from simmate.workflows.base_flow_types import S3Workflow\n\nclass Example__Echo__SayHello(S3Workflow):\n\n    use_database = False  # no custom table for now\n    monitor = False  # no error handling yet\n\n    command = \"echo Hello &gt; output.txt\"  # adds \"Hello\" into a new file\n\n    @classmethod\n    def setup(cls, directory, custom_parameter, **kwargs):\n        # The directory given is a pathlib.Path object for the directory\n        # that the command will be called in\n\n        print(\"I'm setting things up!\")\n        print(f\"My new setting value is {cls.some_new_setting}\")\n        print(f\"My new parameter value is {custom_parmeter}\")\n\n        return  # no need to return anything. Nothing will be done with it.\n\n    @staticmethod\n    def workup(directory):\n        # The directory given is a pathlib.Path object for the directory\n        # that the command will be called in\n\n        # Simply check that we have a new file\n        output_file = directory / \"output.txt\"\n        assert output_file.exists()\n\n        print(\"I'm working things up!\")\n        return \"Done!\"\n\ntask = Example__Echo__SayHello()\nresult = task.run()\n</code></pre> <p>Note:</p> <ol> <li>Writing new <code>setup</code> or <code>workup</code> methods is optional. If you do...<ul> <li>Both <code>setup</code> and <code>workup</code> methods should be either a staticmethod or classmethod.</li> <li>Custom <code>setup</code> methods require the <code>directory</code> and <code>**kwargs</code> input parameters.</li> <li>Custom <code>workup</code> methods require the <code>directory</code> input parameter.</li> </ul> </li> <li>Setting/overwriting attributes is optional. You can also add new ones.</li> </ol> <p>S3Workflows for commonly used programs (like <code>VaspWorkflow</code> for VASP) often have custom <code>setup</code> and <code>workup</code> methods already defined. You can modify these as needed.</p> <p>For a comprehensive example of a subclass, refer to <code>simmate.apps.vasp.workflows.base.VaspWorkflow</code> and the tasks that use it like <code>simmate.apps.materials_project.workflows.relaxation.matproj</code>.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#custom-error-handling","title":"Custom Error Handling","text":"<p>Custom error handling is currently under development. Please contact our team if you need this guide prioritized.</p>"},{"location":"full_guides/workflows/creating_s3_workflows/#alternatives-to-s3workflow","title":"Alternatives to S3Workflow","text":"<p>For advanced users, the S3Workflow class combines the functionality of Prefect's ShellTask, a Custodian Job, and Custodian monitoring. When subclassing this, we can also incorporate functionality from <code>pymatgen.io.vasp.sets</code>. By merging these into one class, we simplify the process for users and task creation.</p>"},{"location":"full_guides/workflows/naming_conventions/","title":"Workflows naming conventions","text":""},{"location":"full_guides/workflows/naming_conventions/#naming-conventions","title":"Naming conventions","text":"<p>Every workflow name follows the <code>type.app.preset</code> format:</p> <p><code>type</code>: Defines the type of analysis the workflow carries out (relaxation, static-energy, dynamics, etc.)</p> <p><code>app</code>: Denotes the third-party software used by the workflow (vasp, abinit, qe, deepmd, etc.)</p> <p><code>preset</code>: Gives a unique identifier for the settings applied (matproj, quality00, my-test-settings, etc.)</p> <p>Example</p> <p>Using <code>static-energy.vasp.matproj</code> as an example...</p> <ul> <li>type = <code>static</code> energy (performs a single point energy calculation)</li> <li>app = <code>vasp</code> (uses VASP for energy calculation)</li> <li>preset = <code>matproj</code>  (implements \"Materials Project\" settings)</li> </ul>"},{"location":"full_guides/workflows/naming_conventions/#format-in-different-contexts","title":"Format in different contexts","text":"<p>Here are several ways workflow names can be represented:</p> <ul> <li>Basic text: <code>type.app.preset</code></li> <li>Python class name: <code>Type__App__Preset</code></li> <li>Website URL: <code>https://simmate.org/workflows/{TYPE}/{APP}/{PRESET}</code></li> </ul> <p>When converting a workflow name from basic text to Python, periods should be replaced with double underscores (<code>__</code>) and phrases should be converted to pascal case. The placement of hyphens (<code>-</code>) is determined by capital letters.</p> <p>Example</p> <ul> <li><code>static-energy.vasp.matproj</code></li> <li><code>StaticEnergy__VASP__MatProj</code></li> <li>https://simmate.org/workflows/static-energy/vasp/matproj</li> </ul>"},{"location":"getting_started/overview/","title":"Getting Started Tutorials","text":""},{"location":"getting_started/overview/#getting-help","title":"Getting help","text":"<p>We recommend creating a GitHub account before starting the tutorials if you don't have one already. While not mandatory, having an account will enable you to ask questions on our forum.</p>"},{"location":"getting_started/overview/#expected-duration","title":"Expected duration","text":"<p>Python Experts: Tutorials 1-4 will take under 1 hour total, while tutorials 5-8 will take 2-3 hours total</p> <p>Beginners: If you're new to coding, we suggest you dedicate 1-2 hrs per tutorial in order to fully understand the concepts introduced in each. Please note that tutorials 5-8 cover advanced topics and are entirely optional.</p>"},{"location":"getting_started/overview/#other-software-used","title":"Other software used","text":"<p>Some tutorials will ask beginners to install extra programs to aid with specific tasks: </p> <ul> <li>Anaconda or Miniforge</li> <li>Docker-Desktop (optional)</li> <li>Spyder IDE (optional)</li> <li>DBeaver (optional)</li> </ul> <p>While there are paid tiers for some of these, you will not need them. Stick with the free versions.</p>"},{"location":"getting_started/wrap_up/","title":"You did it!","text":"<p>If you made it to this point, you're pretty much a Simmate expert! </p> <p>Any other guides and tutorials will be in the full-guides section.</p> <p>Have fun coding and always be sure to ask for help/feedback when you need it.</p> <p>\"The ceiling is the roof\" -Michael Jordan </p>"},{"location":"getting_started/add_computational_resources/intro_to_workers/","title":"Introduction to Workers","text":""},{"location":"getting_started/add_computational_resources/intro_to_workers/#when-to-use-workers","title":"When to Use Workers","text":"<p>If you're only executing a few workflows per day (&lt;10), we recommend sticking to the <code>run</code> method for workflows. In other words, just execute <code>simmate workflows run</code> and avoid unnecessary complexity.</p> <p>Example</p> <p>Rather than mess with Simmate workers &amp; cloud submissions, you can run workflows on an HPC SLURM cluster using a <code>submit.sh</code>:</p> <pre><code>#!/bin/bash\n\n#SBATCH --output=slurm.out\n#SBATCH --nodes=1\n#SBATCH --ntasks=2\n\nsimmate workflows run-yaml my_settings.yaml &gt; simmate.out\n</code></pre> <p>On the other hand, if your team is submitting hundreds or thousands of workflows simultaneously, it would be highly beneficial to monitor and manage these workflows using Simmate workers.</p>"},{"location":"getting_started/add_computational_resources/intro_to_workers/#what-is-a-worker","title":"What is a worker?","text":"<p>A worker is process that checks for scheduled workflow submissions and then runs them for you. In Simmate, workers run one workflow at a time -- pulling from your database, which stores a list of submitted jobs.</p> <p>To see this in action...</p> <ol> <li> <p>Start a worker (and leave it running) with the command: <pre><code>simmate engine start-worker\n</code></pre></p> </li> <li> <p>You will notice that your worker is not actually doing anything yet. This is because we haven't submitted any jobs. Open a new terminal so that we can submit the workflow used in an earlier tutorial. Note how we are using <code>run-cloud</code> instead of <code>run</code>: <pre><code># in example.yaml\nworkflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\n</code></pre> <pre><code>simmate workflows run-cloud example.yaml\n</code></pre></p> <p>Warning</p> <p>Don't forget -- we need our <code>POSCAR</code> file in the same directory as where we are submitting. </p> </li> <li> <p>Once you submit your workflow, you should see your worker (which we left running) pick up the submission and run it.</p> </li> </ol> <p>This was 1 workflow submission and 1 worker -- both done on our laptop.</p> <p>Howeer, in practice, you may submit hundreds of workflows from your local laptop and then start hundreds of workers on remote computers (such an HPC cluster). The workers would then pick up your jobs and run them in parallel!</p> <p>Tip</p> <p>\"1 computer = 1 worker\" is not always the case. To prove this, you can open up multiple terminals and run the command <code>simmate engine start-worker</code> in each.</p> <p>Beware though -- the number of workers per computer should be based on the computer's CPU and Memory specs. If you start too many workers on a single computer, it may exceed the system limits and cause workers to crash.</p>"},{"location":"getting_started/add_computational_resources/intro_to_workers/#where-do-workers-run","title":"Where do workers run?","text":"<p>Anywhere Simmate is installed! </p> <p>In the previous section we saw that we can start workers on our local laptop. In practice, most research teams manage their own computational resources, which could include:</p> <ul> <li>A university or federal HPC cluster with SLURM, PBS, or another queue system</li> <li>A series of nodes or a Kubernetes cluster on a cloud provider</li> <li>A collection of shared desktop computers within your lab</li> <li>Any combination of these resources</li> </ul> <p>Simmate let's you distribute workers accross all of these. The only requirement is that each resource has access to your database (typically through a simple internet connection).</p> <p>As real-world example, let's look at the Warren Lab at UNC. We have access to 3 different HPC clusters and submit workers to each. All of these workers are connected to the same database AND all users submit to the same database as well. This lets us distribute all calculations across the hundreds of compute nodes that we have access to: </p> General SetupExample (The Warren Lab) <pre><code>graph TD;\n    A[user 1]--&gt;E[scheduler];\n    B[user 2]--&gt;E;\n    C[user 3]--&gt;E;\n    D[user 4]--&gt;E;\n    E--&gt;F[cluster 1];\n    E--&gt;G[cluster 2];\n    E--&gt;H[cluster 3];\n    F--&gt;I[worker 1];\n    F--&gt;J[worker 2];\n    F--&gt;K[worker 3];\n    G--&gt;L[worker 4];\n    G--&gt;M[worker 5];\n    G--&gt;N[worker 6];\n    H--&gt;O[worker 7];\n    H--&gt;P[worker 8];\n    H--&gt;Q[worker 9];</code></pre> <pre><code>graph TD;\n    A[Jack's submissions]--&gt;E[cloud database];\n    B[Scott's submissions]--&gt;E;\n    C[Lauren's submissions]--&gt;E;\n    D[Siona's submissions]--&gt;E;\n    E--&gt;F[WarWulf];\n    E--&gt;G[LongLeaf];\n    E--&gt;H[DogWood];\n    F--&gt;I[slurm job 1];\n    F--&gt;J[slurm job 2];\n    F--&gt;K[slurm job 3];\n    G--&gt;L[slurm job 4];\n    G--&gt;M[slurm job 5];\n    G--&gt;N[slurm job 6];\n    H--&gt;O[slurm job 7];\n    H--&gt;P[slurm job 8];\n    H--&gt;Q[slurm job 9];</code></pre>"},{"location":"getting_started/add_computational_resources/quick_start/","title":"Distributed Computational Resources","text":""},{"location":"getting_started/add_computational_resources/quick_start/#quick-start","title":"Quick Start","text":"<p>Tip</p> <p>While this section is intended for distributing workflows accross many computers, you can stick to your local laptop for this Quick Start and learning the basics.</p> <p>Warning</p> <p>If you are running everything on your local computer, you can use the default database (<code>sqlite</code>) for now. HOWEVER... SQLite can not handle parallelization - so you may see errors/crashes with highly parallel workloads. Limit the number of workers you start.</p> <p>If your computational resources are distributed across different computers, ensure you've set up a cloud database, such as a Postgres database on DigitalOcean. Further, all workers need access to your database in order to function.</p> <ol> <li> <p>For remote resources, ensure all simmate installations are connected to the same database. In other words, make sure the <code>config</code> matches accross computers. This step is unnecessary if you are on a single computer. <pre><code>simmate config show --user-only\n</code></pre></p> <p>Note</p> <p>If you are using a custom app (w. tables or workflows), ensure all resources have this app installed</p> </li> <li> <p>Create your workflow settings as you normally do. Here we will use a <code>YAML</code> file, but you can use Python or the CLI as well: <pre><code># in example.yaml\nworkflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\n</code></pre></p> </li> <li> <p>Schedule your simmate workflows by switching from the <code>run</code> to the <code>run-cloud</code> command (in python use the <code>run_cloud()</code> method instead of <code>run()</code>). This workflow will be scheduled but won't run until a worker is started: <pre><code>simmate workflows run-cloud example.yaml\n</code></pre></p> </li> <li> <p>Start a worker wherever you want to run the workflow with the following command. This \"singleflow\" worker will start, run one workflow, then shut down: <pre><code>simmate engine start-singleflow-worker\n</code></pre></p> <p>Danger</p> <p>If you are on a cluster, <code>start-worker</code> should be called within your submit script (e.g., inside <code>submit.sh</code> for SLURM). Avoid running workers on the head node.</p> </li> <li> <p>For more control over the number of workflows ran or to run a worker indefinitely, use the command: <pre><code>simmate engine start-worker\n</code></pre></p> <p>Tip</p> <p>By default, any worker can pick up any workflow submission. To better control which workers run which workflows, use tags. Workers will only pick up submissions that have matching tags. See the Full Guides for more information.</p> </li> <li> <p>Expand your cluster! Start workers wherever you want, and start as many as you need. Just ensure you follow steps 4 and 5 for every worker. If you need to start multiple workers simultaneously, you can use the <code>start-cluster</code> command as well. <pre><code># starts 5 local workers\nsimmate engine start-cluster 5\n</code></pre></p> <p>Tip</p> <p>For HPC clusters, you can also utilize commands such as <code>simmate engine start-cluster 5 --type slurm</code> </p> </li> <li> <p>To allow others to use your cluster, simply connect them to the same database.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/","title":"Creating Simmate Apps","text":"<p>Tip</p> <p>If you prefer learning from full examples, you can explore other apps built with Simmate at <code>src/simmate/apps</code></p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#why-create-a-simmate-app","title":"Why create a Simmate App?","text":"<p>A custom Simmate app gives you the following features &amp; advantages:</p> <ul> <li> Utilizing a custom database table to store workflow results</li> <li> Accessing workflows through the website interface</li> <li> Accessing workflows from other scripts (e.g., using the <code>get_workflow</code> function)</li> <li> Organizing the code from larger projects into smaller files</li> <li> Sharing workflows within a team</li> <li> Allowing others to install your workflows (e.g., after publishing a new paper)</li> </ul> <p>To achieve this, we need to organize our Python code in a specific format (i.e., there are rules for file naming and content).</p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#creating-new-app-files","title":"Creating New App Files","text":"<ol> <li> <p>To start a new app, navigate to your desired folder for code storage and run: <pre><code>simmate create-app\n</code></pre></p> </li> <li> <p>You will see the creation of a new folder named <code>my_new_project</code>. Open it, you should find a series of new files: <pre><code>my_new_project/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 example_app\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 apps.py\n    \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 tests.py\n    \u251c\u2500\u2500 urls.py\n    \u251c\u2500\u2500 views.py\n    \u2514\u2500\u2500 workflows.py\n</code></pre></p> </li> <li> <p>Note the presence of a folder named <code>example_app</code>. This is where your code will reside. You can create as many app folders as needed, but this guide will focus on a single app.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#naming-your-project-and-app","title":"Naming Your Project and App","text":"<p>Danger</p> <p>Once you've chosen a name, stick with it. Altering your project or app name post-installation can result in <code>ModuleNotFound</code> errors.</p> <p>Naming the Project</p> <ol> <li> <p>Rename your folder from <code>my_new_project</code> to a name of your choice. Adhere to Python conventions by keeping your project name all lowercase and connected with underscores. For instance, <code>warren_lab</code> or <code>scotts_project</code> are suitable project names.</p> </li> <li> <p>Open the file <code>new_project_project/pyproject.toml</code> and update the name here as well. For example: <pre><code>[project]\nname = \"scotts_project\"  # &lt;--- updated with your new name\n</code></pre></p> </li> </ol> <p>Naming the App</p> <ol> <li> <p>Determine how your code should be imported. For instance, you may want your workflows to be loaded like so: <pre><code>from example_app.workflows import Example__Workflow__Settings\n</code></pre></p> </li> <li> <p>Use the first part of this (<code>example_app</code>) to rename the <code>example_app</code> folder. The Python conventions (described above) also apply here. For instance, <code>simmate_abinit</code> or <code>simmate_clease</code> are informative and memorable project names. Here's how they would work: <pre><code>from simmate_clease.workflows import ClusterExpansion__Clease__BasicSettings\n</code></pre></p> </li> <li> <p>Open the file <code>example_app/apps.py</code> and rename the class AND name property to match your app name. We also add labels for the web ui to use. For example: <pre><code>from django.apps import AppConfig\n\nclass SimmateCleaseConfig(AppConfig):\n    name = \"simmate_clease\"\n\n    # These settings determine in the web ui (if you add a urls.py to your app)\n    verbose_name = \"CLEASE\"  \n    description_short = \"utilities for running cluster-expanison calcs using CLEASE\"\n</code></pre></p> <p>Note</p> <p>While this file may seem trivial, it enables users to build complex apps that include many other apps / subapps. Beginners will likely never revisit this file.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#installing-your-app","title":"Installing Your App","text":"<ol> <li> <p>Open the <code>pyproject.toml</code> file. This file instructs Python on how to install your code (and it doesn't require much to install a package ). As your project expands and requires other programs to be installed, you'll track them here. For now, no changes are needed.</p> </li> <li> <p>While inside your new project folder, \"install\" the project to your conda environment in \"--editable\" (-e) mode. This allows you to make changes to your code, and Python will automatically incorporate your changes. <pre><code># replace \"my_new_project\" with the name of your project\ncd my_new_project\npip install -e .   # &lt;-- don't forget the period!\n</code></pre></p> </li> <li> <p>Verify the installation by running these lines in Python. You may need to restart your terminal/Spyder for this to work.     <pre><code># Update code to use your new names\nimport example_app\nfrom example_app.apps import ExampleAppConfig\n</code></pre></p> </li> <li> <p>You now have an installed app! However, Simmate is still unaware of its existence. We need to inform Simmate to load it.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#registering-your-app","title":"Registering Your App","text":"<ol> <li> <p>If you have explored the <code>Apps</code> section of our documentaion, you will see that many apps are registerd using the <code>simmate config add</code> command. We can use this command to register our app. Simply write out the python path to our <code>Config</code>: <pre><code>simmate config add 'example_app.apps.ExampleAppConfig'\n</code></pre></p> <p>Note</p> <p><code>ExampleAppConfig</code> is the python class that we defined in the <code>apps.py</code> file</p> <p>Tip</p> <p>If your app has another third-party Django dependency, you must register that as well. To do this, use the <code>extra_django_apps</code> setting. All apps in this setting will be added to Django's <code>INSTALLED_APPS</code> setting. For example:</p> <pre><code>apps:\n    - example_app.apps.ExampleAppConfig\n\nextra_django_apps:\n  - django_tables2\n  - django_celery_results\n</code></pre> <p><code>extra_django_apps</code> will be added to <code>INSTALLED_APPS</code> added ahead of any Simmate apps. If this does not work for your desired dependency, please contact our team for support.</p> </li> <li> <p>Ensure the new configuration includes your new app: <pre><code>simmate config show --user-only\n</code></pre></p> </li> <li> <p>Ensure Simmate can locate and load your app in Python: <pre><code>from simmate.configuration import settings\n\nprint(settings.apps)  # you should see your new app!\n</code></pre></p> </li> <li> <p>Ensure Simmate can configure your new app and its tables properly: <pre><code>from simmate.database import connect\n</code></pre></p> </li> <li> <p>You now have registerd your app with Simmate and confirmed everything is working </p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#sharing-your-app-w-others","title":"Sharing your app w. others","text":"<p>If you are an experienced python programmer, you probably noticed this already... But Simmate Apps are essentially the creation of a new Python package. In fact, our <code>start-project</code> command functions like a \"cookie-cutter\" template.</p> <p>This has significant implications for code and research sharing. With a fully-functional and published Simmate project, you can share your code with other labs via Github and PyPi. This allows the entire Simmate community to install and use your custom workflows with Simmate. For them, the process is as simple as:</p> <ol> <li><code>pip install my_new_project</code></li> <li>Adding <code>example_app.apps.ExampleAppConfig</code> to their <code>~/simmate/my_env-settings.yaml</code></li> </ol> <p>We won't cover publishing packages in our guides (because it's an advanced topic), but feel free to reach our to our team if you need help </p> <p>Note</p> <p>Alternatively, you can request to merge your app into our Simmate repository, making it a default installation for all users. Whichever path you choose, your hard work will be more accessible to the community and new users!</p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_app/#custom-django-settings","title":"Custom Django settings","text":"<p>Danger</p> <p>This section is only for experts. Try to avoid updating Django settings because you could unintentially break some Simmate apps/features.</p> <p>Advanced users may want to have full control over django settings. Before you mess with Simmate's default settings for Django, we highly recommend reading through our <code>settings.py</code> file located here:</p> <ul> <li>https://github.com/jacksund/simmate/blob/main/src/simmate/configuration/django/settings.py</li> </ul> <p>You can update hard-coded django settings using the simmate setting file (<code>~/simmate/settings.yaml</code>) like so:</p> <pre><code>django_settings:\n    LOGIN_REDIRECT_URL: '/accounts/profile/'\n</code></pre> <p>If you need even more control (such as providing a custom <code>settings.py</code> entirely), please reach out to our team so that we can add support for your needs.</p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/","title":"Creating Custom Database Tables","text":""},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#building-custom-tables","title":"Building Custom Tables","text":"<ol> <li> <p>Review the tutorial on python inheritance (from the <code>How tables are built</code> tutorial in the <code>Database</code> section). This topic is important to understanding when building new tables. </p> </li> <li> <p>In your new app, open the file <code>example_app/models.py</code> and you will see two example tables defined for you. This is all you need to build tables! Note, how we also use <code>Structure</code> and <code>Calculation</code> to add a bunch of columns to in the 2nd table: <pre><code>class MyCustomTable1(DatabaseTable):\n    custom_column_01 = table_column.IntegerField()\n    custom_column_02 = table_column.FloatField()\n\nclass MyCustomTable2(Structure, Calculation):\n    input_01 = table_column.FloatField()\n    input_02 = table_column.BooleanField()\n    output_01 = table_column.FloatField(null=True, blank=True)\n    output_02 = table_column.BooleanField(null=True, blank=True)\n</code></pre></p> <p>Tip</p> <p>We only demonstrate <code>Structure</code> and <code>Calculation</code> in the examples shown, but there are many more <code>base_data_types</code> you can utilize. Make sure to review our guides in the <code>simmate.database</code> module for more information.</p> <p>Info</p> <p>In Django (which Simmate uses under the hood), a <code>DatabaseTable</code> is referred to as a <code>Model</code>. Therefore, a model and table can be considered the same. As we're using Django, the file name <code>models.py</code> must remain as-is. That's where Django searches for your custom database tables.</p> </li> <li> <p>These examples will build tables with the following columns: <pre><code># TABLE 1\n\n# TABLE 2\n</code></pre></p> </li> <li> <p>Note... These tables are not actually in your database yet. You can check your tables in DBeaver to confirm this. Next, we will actually \"apply\" them to our database.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#applying-changes-to-the-database","title":"Applying Changes to the Database","text":"<ol> <li> <p>Open the <code>example_app/models.py</code> file and review the example tables.</p> </li> <li> <p>Ensure the Simmate configuration includes your new app: <pre><code>simmate config show --user-only\n</code></pre></p> </li> <li> <p>Add these tables to the database by updating it: <pre><code>simmate database update\n</code></pre></p> <p>Note</p> <p>The <code>update</code> command attempts to add any changes to your current database. If you wish to start from a clean and empty database, you can use <code>reset</code> instead.</p> </li> <li> <p>Verify the output of your <code>update</code> command. You should see that your new app and tables have been added. <pre><code>Migrations for 'example_app':\n  example_app/migrations/0001_initial.py\n    - Create model MyCustomTable1\n    - Create model MyCustomTable2\n</code></pre></p> <p>Danger</p> <p>All changes are tracked as \"migrations\" and stored in an extra folder within your app. Typically, you can just continue to let these files build because migrations are designed to be committed to, and distributed as part of, your codebase. Make sure to read &amp; understand Django's official guides on how to interact with these files.</p> </li> <li> <p>Check DBeaver and you should see new tables such as <code>example_app_mycustomtable1</code> and <code>example_app_mycustomtable2</code></p> </li> <li> <p>In a separate python script, let's ensure we can view the new tables in your database: <pre><code>from simmate.database import connect\n\nfrom example_app.models import MyCustomTable1, MyCustomTable2\n\n# both tables should output 0 because we haven't added data yet\nn1 = MyCustomTable1.objects.count()  \nn2 = MyCustomTable2.objects.count()  \n</code></pre></p> </li> <li> <p>You now have your tables in the database! </p> <p>Note</p> <p>If you ever change your tables (such as adding or removing a column), you will need to re-update your database. Therefore, whenever you modify the <code>models.py</code> file, make sure to run <code>simmate database update</code> for your changes to take effect in your database.</p> </li> </ol>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#adding-data-to-your-tables","title":"Adding Data to Your Tables","text":""},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#basic-population","title":"Basic Population","text":"<p>For basic tables, you can set each column manually:</p> <pre><code>from simmate.database import connect\nfrom example_app.models import MyCustomTable1\n\nnew_entry = MyCustomTable1(\n    custom_column_01=123,\n    custom_column_02=3.14,\n)\nnew_entry.save()\n</code></pre> <p>Once saved, try viewing your new row in DBeaver!</p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#advanced-population","title":"Advanced population","text":"<p>For more complex tables that include Simmate data types, we automatically populate data using the <code>from_toolkit</code> method:</p> <pre><code>from simmate.database import connect\nfrom simmate.toolkit import Structure\n\nfrom example_app.models import MyCustomTable2\n\nnacl = Structure.from_file(\"NaCl.cif\")\n\nnew_entry = MyCustomTable2.from_toolkit(structure=nacl)\nnew_entry.save()\n</code></pre> <p>Once saved, try viewing your new row in DBeaver. You will see many columns were filled out automatically. Some columns are still empty though (such as those from a <code>Calculation</code>). We will learn how to populate these tables in the next tutorial on <code>Adding app workflows</code></p> <p>Tip</p> <p>Manually populating your table with data is often unnecessary. Instead, you can connect your database to a workflow, which will automatically fill it with data. We'll cover this in a later step.</p>"},{"location":"getting_started/custom_tables_and_apps/create_a_custom_table/#searching-your-new-data","title":"Searching Your New Data","text":"<p>You can filter results just like any other table. If you need a refresher, refer back to the earlier database tutorial or refer to the Full Guides for more info:</p> <pre><code>df = MyCustomTable2.objects.filter(nsites__lte=10).to_dataframe()\n</code></pre>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/","title":"Using App Workflows","text":""},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#organizing-app-workflows","title":"Organizing app workflows","text":"<p>Simmate automatically searches for a <code>workflows.py</code> (or <code>workflows</code> module) within your app and retrieves all Python classes within it, assuming they are workflows you want registered. However, if your scripts contain non-workflow classes or abstract base workflows, this can lead to unexpected errors. Therefore, you need to explicitly specify which workflows should be registered with your app.</p> <p>Tip</p> <p>If you encounter <code>AttributeError: '...' object has no attribute 'name_full'</code> or <code>Exception: Make sure you are following Simmate naming conventions</code>, it's likely that your workflows are misorganized.</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#in-workflowspy-file","title":"in workflows.py file","text":"<p>Upon creating your project/app, you'll find a single <code>workflows.py</code> file with the following at the top:</p> <pre><code># -----------------------------------------------------------------------------\n# List all workflows you want registered\n# -----------------------------------------------------------------------------\n\n__all__ = [\n    \"add\",\n    \"Example__Python__MyExample\",\n]\n</code></pre> <p>You must explicitly list all workflows you want registered if you stick with a single <code>workflow.py</code> file format.</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#in-a-workflows-module","title":"in a workflows module","text":"<p>As your app expands, you might want to store your workflows in separate scripts or submodules. You can do this by replacing the <code>workflows.py</code> file with a <code>workflows</code> folder with the following structure:</p> <pre><code>example_app\n\u2514\u2500\u2500 workflows\n    \u251c\u2500\u2500 __init__.py   # &lt;-- file used for registration\n    \u251c\u2500\u2500 example_1.py\n    \u251c\u2500\u2500 example_2.py\n    \u251c\u2500\u2500 example_3.py\n    \u2514\u2500\u2500 example_submodule\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 example_4.py\n        \u2514\u2500\u2500 example_5.py\n</code></pre> <p>Here, <code>example_N.py</code> files can be named as you wish and do NOT require the <code>__all__</code> tag. This folder structure allows for better workflow organization.</p> <p>Instead of the <code>__all__</code> tag, we can list workflows to register in the <code>workflows/__init__.py</code> file. We can use relative Python imports to achieve this with minimal code:</p> <pre><code># in workflows/__init__.py\n\nfrom .example_1 import Example__Python__MyExample1\nfrom .example_2 import Example__Python__MyExample2\nfrom .example_3 import Example__Python__MyExample3\n\nfrom .example_submodule.example_4 import Example__Python__MyExample4\nfrom .example_submodule.example_5 import Example__Python__MyExample5\n</code></pre> <p>Example</p> <p>If you prefer learning by example, check out Simmate's built-in <code>Vasp</code> app. The <code>workflows</code> module of this app is located here. You can also see how our <code>workflows/__init__.py</code> file lists all of our registered workflows here).</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#basic-use","title":"Basic use","text":"<p>Now that we have registered workflows within a Simmate app, we can access some extra features. We can run the workflow in the same way we run others distributed with Simmate (using a YAML file, Python, Web UI, etc):</p> yamlpython <pre><code>workflow_name: example.python.my-example1\nstructure: NaCl.cif\ninput_01: 12345\ninput_02: true\n</code></pre> <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"example.python.my-example1\")\nworkflow.run(\n    structure=\"NaCl.cif\",\n    input_01=12345,\n    input_02=true,\n)\n</code></pre> <p>You can also see your workflow listed now:</p> command line <pre><code>simmate workflows list-all\n</code></pre>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#link-datatables-to-workflows","title":"Link Datatables to Workflows","text":"<p>To use a custom database table in a workflow, the following conditions must be met:</p> <ul> <li> the table must use the <code>Calculation</code> mix-in</li> <li> the workflow must have <code>database_table</code> set to our table</li> <li> the table and workflow must be registered (already completed)</li> </ul> <p>Note that our database tables and workflows already meet these conditions.</p> <p>For <code>MyCustomTable2</code>, we can see it is using the <code>Calculation</code> mix-in in our <code>models.py</code> file: <pre><code>class MyCustomTable1(Structure, Calculation):\n    # ... custom columns hidden ...\n</code></pre></p> <p>This table has already been linked to a workflow too. In our <code>workflows.py</code> file, we can see the following: <pre><code>class Example__Python__MyExample(Workflow):\n    database_table = MyCustomTable2\n</code></pre></p> <p>This completes our checklist -- so this database and workflow are already configured for us.</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#storing-inputs-parameters","title":"Storing inputs parameters","text":"<p>To store input parameters at the start of a calculation in a workflow, the following conditions must be met:</p> <ul> <li> the parameter must have been added as a column to the database</li> <li> a parameter with the exact same name must be an input option of <code>run_config</code></li> </ul> <p>For our <code>MyCustomTable1</code> and <code>Example__Python__MyExample</code>, we can see that the following inputs match both the <code>run_config</code> input AND are table columns:</p> <ol> <li>input_01</li> <li>input_02</li> <li>structure</li> </ol> <p>Here's the relevant code that sets this up:</p> MyCustomTable1Example__Python__MyExample <pre><code># structure --&gt; through the Structure mix-in\ninput_01 = table_column...\ninput_02 = table_column...\n</code></pre> <pre><code>def run_config(\n    input_01,\n    input_02,\n    structure,\n</code></pre> <p>That's it! Your workflow will store these inputs in your database when a workflow run starts.</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#storing-outputs-and-results","title":"Storing outputs and results","text":"<p>To store outputs at the end of a calculation in a workflow, the following conditions must be met:</p> <ul> <li> the parameter must have been added as a column to the database</li> <li> the <code>run_config</code> must return a dictionary of columns that need to be updated</li> <li> a key with the exact same name must be in this dictionary</li> </ul> <p>For our <code>MyCustomTable1</code> and <code>Example__Python__MyExample</code>, we can see that the following outputs match both the <code>run_config</code>'s output dictionary AND are table columns:</p> <ol> <li>output_01</li> <li>output_02</li> </ol> <p>Here's the relevant code that sets this up:</p> MyCustomTable1Example__Python__MyExample1 <pre><code>output_01 = table_column...\noutput_02 = table_column...\n</code></pre> <pre><code>return {\n    \"output_01\": ...,\n    \"output_02\": ...,\n}\n</code></pre> <p>That's it! Your workflow will store these results in your database when a workflow run completes.</p>"},{"location":"getting_started/custom_tables_and_apps/using_app_workflows/#viewing-results","title":"Viewing Results","text":"<p>Results are stored the same as any other workflow. You'll see a summary file written for you, and you can load all the data from your database. We only configure a small number of columns for our workflow + datatable, but check out all of the outputs!</p> <pre><code>_DATABASE_TABLE_: MyCustomTable1\n_TABLE_ID_: 1\n_WEBSITE_URL_: http://127.0.0.1:8000/workflows/example/python/my-example1/1\nchemical_system: Cl-Na\ncomputer_system: digital-storm\ncreated_at: 2022-09-04 00:10:01.844798+00:00\ndensity: 2.1053060843576104\ndensity_atomic: 0.04338757298280908\ndirectory: /home/jacksund/Documents/spyder_wd/simmate-task-ow6otw06\nformula_anonymous: AB\nformula_full: Na4 Cl4\nformula_reduced: NaCl\nid: 1\ninput_01: 12345.0\ninput_02: true\nnelements: 2\nnsites: 8\noutput_01: 1234500\noutput_02: false\nrun_id: 6872771c-c0d7-43b5-afea-b8ed87f6a5df\nspacegroup_id: 225\nupdated_at: 2022-09-04 00:10:01.875757+00:00\nvolume: 184.38459332974767\nvolume_molar: 13.87987468758872\nworkflow_name: example.python.my-example1\nworkflow_version: 0.10.0\n</code></pre>"},{"location":"getting_started/custom_workflows/basic_workflows/","title":"Introduction to Workflows","text":""},{"location":"getting_started/custom_workflows/basic_workflows/#what-is-a-workflow","title":"What is a workflow?","text":"<p>All workflows are really just python functions. They can be as simple as adding two numbers together or as complex as an evolutionary search which involves hundreds of DFT calculations. Whatever the workflow may be, it needs some inputs and it then produces some result for us.</p> <p>To prove this, we'll show how to make a workflow that just adds two numbers together.</p>"},{"location":"getting_started/custom_workflows/basic_workflows/#a-basic-python-function","title":"A basic Python function","text":"<p>Let's first create a basic python function that adds two numbers together:</p> <pre><code>def add(x, y):\n    return x + y\n\nresult = add(x=1, y=2)\n</code></pre> <p>Run this and you'll get <code>result = 3</code>.</p> <p>Simple enough! Next, let's turn this into a Simmate workflow.</p>"},{"location":"getting_started/custom_workflows/basic_workflows/#make-our-first-workflow","title":"Make our first workflow","text":"<p>To turn our <code>add</code> function into a Simmate workflow, we need to:</p> <ol> <li>add the <code>@workflow</code> decorator to our function</li> <li>make sure we include <code>**kwargs</code> as an input</li> </ol> <p>Here's what our workflow looks like:</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef add(x, y, **kwargs):\n    return x + y\n</code></pre> <p>And that's it! We now have a new Simmate workflow.</p>"},{"location":"getting_started/custom_workflows/basic_workflows/#running-our-workflow","title":"Running our workflow","text":"<p>Note how we originally ran our python function with this: <pre><code>result = add(x=1, y=2)\n</code></pre></p> <p>This code won't work anymore, because we've now changed our function into a <code>Workflow</code>. From earlier tutorials, we learned that workflows must be called with <code>.run()</code> instead. Therefore our code becomes:</p> <pre><code>status = add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>Note</p> <p>Our workflow run returned a <code>status</code> instead of our <code>result</code>. This is because (in advanced cases) we will be submitting workflows to a cluster, rather than running them directly. In such cases, it is common to submit workflow runs and check the result later.</p> <p>This will be covered in the final Simmate tutorial on <code>Computational Resources</code>.</p> <p>And here is our final script:</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef add(x, y, **kwargs):\n    return x + y\n\nstatus = add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>Just like with our original function, we should see <code>result = 3</code>.</p>"},{"location":"getting_started/custom_workflows/basic_workflows/#what-changed","title":"What changed?","text":"<p>So far, this might seem like a lot of work (and complexity) just to get the same result. But let's look under the hood and see the basics of what has changed.</p>"},{"location":"getting_started/custom_workflows/basic_workflows/#extra-parameters","title":"Extra parameters","text":"<p>For starters, we added <code>**kwargs</code>. Let's modify our function to see what this actual did:</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef add(x, y, **kwargs):\n    print(f\"Extra kwargs: {kwargs}\")  # add this new line!!!\n    return x + y\n\nstatus = add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>When we run this again, we will see a print statement will output something similar to this: </p> <pre><code>Extra kwargs: {\n    'run_id': 'eb467f3e-eb27-4bd0-8600-c49757bc5b63',\n    'directory': Path('path/to/simmate-task-abcd1234'),\n    'compress_output': False,\n    'source': None,\n    'started_at': datetime.datetime(...),\n}\n</code></pre> <p>What happened is that Simmate performed some extra setup for us. This included things such as...</p> <ul> <li>creating a unique workflow id (to help identify things in the database)</li> <li>creating a new folder (<code>directory</code>) that the workflow can use as a scratch space</li> <li>compressing the final folder to a <code>.zip</code> file (if requested)</li> <li>... and more!</li> </ul>"},{"location":"getting_started/custom_workflows/basic_workflows/#extra-properties-methods","title":"Extra properties &amp; methods","text":"<p>Because we now have a Simmate workflow, we can also access new properties and methods. For example:</p> <pre><code># run one line at a time\n\nadd.name_full\n\nadd.show_parameters()\n</code></pre>"},{"location":"getting_started/custom_workflows/basic_workflows/#and-more","title":"... and more","text":"<p>With this workflow, there are also advanced features we can include. This can be thing such as...</p> <ul> <li>advanced parameter loading</li> <li>saving the <code>result</code> to a database</li> <li>saving calculation info (like total time) to a database</li> <li>viewing &amp; running the workflow in the website interface</li> </ul> <p>Features like these (and more), are covered in later tutorials as well as the Full Guides section.</p>"},{"location":"getting_started/custom_workflows/chemistry_workflows/","title":"Chemistry Workflows","text":""},{"location":"getting_started/custom_workflows/chemistry_workflows/#a-chemistry-workflow","title":"A chemistry workflow","text":"<p>The <code>add</code> workflow was super basic, so now let's try a more advanced workflow involving a crystal structure.</p> <p>Here, we will make a workflow that (i) converts a structure to a primitive unitcell and (ii) writes it to a CIF file:</p> <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef write_primitive(structure, directory, **kwargs):\n    new_structure = structure.get_primitive_structure()\n    new_structure.to(directory / \"primitive.cif\", fmt=\"cif\")\n\nstatus = write_primitive.run(structure=\"POSCAR\")\nresult = status.result()\n</code></pre> <p>Note</p> <p>Make sure you run this in the same folder that contains the <code>POSCAR</code> file from earlier tutorials.</p> <p>There are several advanced things going in this workflow.</p> <ol> <li>We provided <code>POSCAR</code> filename (as a python string) -- However, our function is using <code>structure</code> as if it was a <code>toolkit</code> object (because it calls <code>get_primitive_structure</code>). Behind the scenes, Simmate took our <code>POSCAR</code> input, decided it was a structure file, and converted it to a <code>toolkit.Structure</code> object for us!</li> <li>We didn't provide a <code>directory</code> but Simmate built one for us. This is why we can have the code <code>directory / \"primitive.cif\"</code> actually write the file to our new folder.</li> </ol> <p>These advanced feature work let's us run our workflow in new ways. For example, we could run the workflow like so:</p> <pre><code>status = write_primitive.run(\n    structure={\n        \"database_table\": \"MatprojStructure\",\n        \"database_id\": \"mp-123\",\n    },\n    directory=\"MyNewFolder\",\n    compress_output=True,\n)\nresult = status.result()\n</code></pre> <p>This time, we pulled our structure from the database, specified the name of the folder we wanted to make, and that we wanted the final folder converted to a <code>zip</code> file once it's done.</p> <p>So we have lots of new functionality, and all we had to do was add <code>@workflow</code> </p> <p>Tip</p> <p>There are plenty of trick that empower how you run workflows, so be sure to read through our <code>Parameters</code> and <code>Full Guides</code> section.</p>"},{"location":"getting_started/custom_workflows/class_based_workflows/","title":"Class-based Workflows","text":""},{"location":"getting_started/custom_workflows/class_based_workflows/#switching-to-classes","title":"Switching to classes","text":"<p>We now know that all workflows are really just python functions (+ some automatic functionality added on top). However, advanced python users will run into trouble here... This is because functions are not as powerful as classes when it comes to organizing and reusing code.</p> <p>Simmate therefore let's you build workflows from a <code>Workflow</code> class, rather than the <code>@workflow</code> function decorator. In order to convert our function to a <code>Workflow</code> class, we must do the following:</p> <ul> <li>set the class name using Simmate conventions (we cover this in the next section)</li> <li>define a <code>run_config</code> method</li> <li>add <code>@staticmethod</code> or <code>@classmethod</code> to <code>run_config</code></li> </ul> <p>Taking our <code>add</code> workflow from the previous tutorial:</p> <pre><code>from simmate.workflows import Workflow\n\nclass Math__Basic__Add(Workflow):\n\n    use_database = False  # we don't have a database table yet\n\n    @staticmethod\n    def run_config(x, y, **kwargs):\n        return x + y\n\n# running is the same as before\nstatus = Math__Basic__Add.run(x=1, y=2)\nresult = status.result()\n</code></pre> <p>Nothing has changed with our workflow -- it just looks a little more complex. Writing workflows in this way might seem silly at first, but class-based workflows make advanced features MUCH easier to implement. </p> <p>We will demonstrate this in the <code>App-based Workflows</code> section. For now, let's focus on our crazy class name (<code>Math__Basic__Add</code>) and why we chose that.</p>"},{"location":"getting_started/custom_workflows/class_based_workflows/#naming-your-workflows","title":"Naming Your Workflows","text":""},{"location":"getting_started/custom_workflows/class_based_workflows/#importance-of-naming","title":"Importance of naming","text":"<p>In Simmate, the naming of your new workflow is a crucial step. </p> <p>Certain features, such as the website interface, necessitate that workflow names adhere to a specific format. This allows us to perform tasks such as locating your new workflow within the website interface. We follow a set of rules to generate workflow names like <code>relaxation.vasp.mit</code>.</p> <p>Here's how a workflow name appears in different contexts:</p> Readable NameWebsite URLPython Class Name <pre><code>static-energy.vasp.matproj\n</code></pre> <pre><code>https://simmate.org/workflows/static-energy/vasp/matproj\n</code></pre> <pre><code>StaticEnergy__Vasp__Matproj\n</code></pre> <p>Example</p> <p><code>Math__Basic__Add</code> becomes <code>math.basic.add</code>, and once placed in a custom app, this workflow can be found in the website at <code>http://localhost:8000/workflows/math/basic/add</code></p>"},{"location":"getting_started/custom_workflows/class_based_workflows/#understanding-conventions","title":"Understanding conventions","text":"<p>Simmate's naming conventions consist of three components:</p> <ol> <li>The type of analysis the workflow performs</li> <li>The \"app\" (or program) that the workflow uses for execution</li> <li>A unique name to distinguish the settings used</li> </ol> <p>Examples for each component are:</p> <ol> <li>relaxation, static-energy, dynamics, ...</li> <li>vasp, abinit, qe, deepmd, ...</li> <li>jacks-test, matproj, quality00, ...</li> </ol> <p>Combined, example workflow names would be:</p> <ul> <li><code>relaxation.vasp.jacks-test</code></li> <li><code>static-energy.abinit.matproj</code></li> <li><code>dynamics.qe.quality00</code></li> </ul> <p>To convert this to our workflow name in python, we replace periods with two underscores each and convert our words to pascal case. For instance, our workflow names become:</p> <ul> <li><code>Relaxation__Vasp__JacksTest</code></li> <li><code>StaticEnergy__Abinit__Matproj</code></li> <li><code>Dynamics__Qe__Quality00</code></li> </ul> <p>Warning</p> <p>Be mindful of capitalization as it is crucial in this context. Always double-check your workflow names.</p>"},{"location":"getting_started/custom_workflows/class_based_workflows/#powerful-app-based-workflows","title":"Powerful App-based Workflows","text":"<p>Using the <code>Workflow</code> organization instead <code>@workflow</code> decorator might seem silly at first, but class-based workflows make advanced features MUCH easier to implement. </p> <p>For example, say we want to make a workflow that uses Quantum Espresso or VASP. For VASP, we provide a <code>VaspWorkflow</code> class. For Quantum Espresso, we provide a <code>PwscfWorkflow</code> (PW-SCF is a component of QE). Here are some basic VASP and QE workflows written in Simmate:</p> VASPQuantum Espresso <pre><code>from simmate.apps.vasp.workflows.base import VaspWorkflow\n\nclass Relaxation__Vasp__ExampleSettings(VaspWorkflow):\n\n    functional = \"PBE\"\n    potcar_mappings = {\"Y\": \"Y_sv\", \"C\": \"C\"}\n\n    _incar = dict(\n        PREC=\"Normal\",\n        EDIFF=1e-4,\n        ENCUT=450,\n        NSW=100,\n        KSPACING=0.4,\n    )\n</code></pre> <pre><code>from simmate.apps.quantum_espresso.workflows.base import PwscfWorkflow\n\nclass StaticEnergy__QuantumEspresso__ExampleSettings(PwscfWorkflow):\n\n    control = dict(\n        pseudo_dir__auto=True,\n        restart_mode=\"from_scratch\",\n        calculation=\"scf\",\n        tstress=True,\n        tprnfor=True,\n    )\n\n    system = dict(\n        ibrav=0,\n        nat__auto=True,\n        ntyp__auto=True,\n        ecutwfc__auto=\"efficiency\",\n        ecutrho__auto=\"efficiency\",\n    )\n\n    electrons = dict(\n        diagonalization=\"cg\",\n        mixing_mode=\"plain\",\n        mixing_beta=0.7,\n        conv_thr=\"1.0e-8\",\n    )\n\n    psuedo_mappings_set = \"SSSP_PBE_EFFICIENCY\"\n\n    k_points = dict(\n        spacing=0.5,\n        gamma_centered=True,\n    )\n</code></pre> <p>There are many more workflows and base classes to explore. Be sure to look through both our <code>Apps</code> and <code>Full Guides</code>.</p> <p>Note</p> <p>Even if you don't know how to use VASP or QE, the key takeaway here should be that you can translate their software's inputs into a Simmate workflow with minimal effort.</p>"},{"location":"getting_started/custom_workflows/class_based_workflows/#advanced-workflow-features","title":"Advanced Workflow Features","text":"<p>There are still many improvements that you may want to incorporate into your new workflow(s). For instance, you might want to:</p> <ul> <li> Modify a complex workflow (like <code>diffusion.vasp.neb-all-paths-mit</code>)</li> <li> Develop a custom workflow using a new program such as USPEX or ABINIT</li> <li> Utilize a custom database table to store your workflow results</li> <li> Access the workflow via the website interface</li> <li> Access your workflow from other scripts (and the <code>get_workflow</code> function)</li> </ul> <p>These topics will be addressed in the next tutorial, where we will simultaneously cover custom database tables.</p>"},{"location":"getting_started/custom_workflows/quick_start/","title":"Building custom workflows","text":"<p>Warning</p> <p>This tutorial only covers workflows that are ran locally. If you are submitting to a cluster via <code>run_cloud</code> and/or want advanced features such as the workflow showing in the website UI, you must include your workflow in a custom app. This is covered in the next section of tutorials.</p>"},{"location":"getting_started/custom_workflows/quick_start/#quick-guide","title":"Quick Guide","text":"<ol> <li> <p>All workflows are really just python functions. Let create a simple python function that adds two numbers together: <pre><code>def add(x, y):\n    return x + y\n\nresult = add(x=1, y=2)\n</code></pre></p> </li> <li> <p>To make this a Simmate workflow, we need to (a) add the <code>@workflow</code> decorator and (b) make sure we include <code>**kwargs</code> as an input. The <code>add</code> function will then become a <code>Workflow</code>. This means we have access to a <code>run</code> method that adds extra functionality for us and returns a future-like object: <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef add(x, y, **kwargs):\n    print(f\"Extra kwargs: {kwargs}\")  # add this new line!\n    return x + y\n\nstatus = add.run(x=1, y=2)\nresult = status.result()\n</code></pre></p> <p>Note</p> <p>We added a <code>print</code> statement to our function. This was to understand why we require <code>**kwargs</code> as an input. This print statement will output something similar to: <pre><code>Extra kwargs: {\n    'run_id': 'eb467f3e-eb27-4bd0-8600-c49757bc5b63',\n    'directory': Path('path/to/simmate-task-abcd1234'),\n    'compress_output': False,\n    'source': None,\n    'started_at': datetime.datetime(2024, 1, 25, 0, 0, 0, 0, tzinfo=datetime.timezone.utc),\n}\n</code></pre></p> <p>Thus, the workflow provides optional extra parameters for us to use in our workflow. This includes a new folder (<code>directory</code>) that the workflow can use as a scratch space.</p> </li> <li> <p>As more advanced example, here is a workflow that converts a structure to a primitive unitcell and writes it to a CIF file:     <pre><code>from simmate.workflows import workflow\n\n@workflow\ndef write_primitive(structure, directory, **kwargs):\n    new_structure = structure.get_primitive_structure()\n    new_structure.to(directory / \"primitive.cif\", fmt=\"cif\")\n\nstatus = write_primitive.run(structure=\"POSCAR\")  # (1)\nresult = status.result()\n</code></pre></p> <ol> <li>Note how (a) we provided <code>POSCAR</code> (str) but our function converted it to a <code>toolkit.Structure</code> object; and (b) we didn't provide a <code>directory</code> but Simmate built one for us. Common input parameters adhere to the rules listed in the Parameters section of our documentation.</li> </ol> <p>Tip</p> <p>Try out some more advanced examples by going through our Full guides. For example, try running this workflow with...</p> <pre><code>status = write_primitive.run(\n    structure={\n        \"database_table\": \"MatprojStructure\",\n        \"database_id\": \"mp-123\",\n    },\n    directory=\"MyNewFolder\",\n    compress_output=True,\n)\nresult = status.result()\n</code></pre> <p>This pulled our structure from the database, specified the name of the folder we wanted to make, and that we wanted the final folder converted to a <code>zip</code> file once it's done.</p> </li> <li> <p>The <code>@workflow</code> decorator is very similar to other workflow engines (such as Prefect). However, the power of Simmate workflows comes from class-based workflows using <code>Workflow</code>. This involves some extra code (which at first is very boiler-plate), but we'll explain the signifiance after. Bear with us in the next step </p> </li> <li> <p>To make a <code>Workflow</code> class, we must (i) set the class name using Simmate conventions (see full guides) and (ii) define a <code>run_config</code> method as a <code>@staticmethod</code> OR a <code>@classmethod</code>.     <pre><code>from simmate.workflows import Workflow\n\nclass Example__Basic__WritePrimitive(Workflow):\n\n    use_database = False  # we don't have a database table yet\n\n    @staticmethod\n    def run_config(structure, directory, **kwargs):\n        new_structure = structure.get_primitive_structure()\n        new_structure.to(directory / \"primitive.cif\", fmt=\"cif\")\n\n# running is the same as before\nstatus = Example__Python__WritePrimitive.run(structure=\"POSCAR\")\nresult = status.result()\n</code></pre></p> <p>Note</p> <p>The class name is long (and unpythonic), but this how we keep workflows organized. With hundreds of workflows, having an organized format like <code>static-energy.quantum-espreso.example123</code> becomes very important. This workflow will give the name <code>example.basic.write-primitive</code></p> </li> <li> <p>This might seem silly at first, but class-based workflows make advanced features MUCH easier to implement. Take for example making workflows using both Quantum Espresso and VASP, which can utilize subclasses of <code>Workflow</code>:</p> </li> </ol> VASPQuantum Espresso <pre><code>from simmate.apps.vasp.workflows.base import VaspWorkflow\n\nclass Relaxation__Vasp__ExampleSettings(VaspWorkflow):\n\n    functional = \"PBE\"\n    potcar_mappings = {\"Y\": \"Y_sv\", \"C\": \"C\"}\n\n    _incar = dict(\n        PREC=\"Normal\",\n        EDIFF=1e-4,\n        ENCUT=450,\n        NSW=100,\n        KSPACING=0.4,\n    )\n</code></pre> <pre><code>from simmate.apps.quantum_espresso.workflows.base import PwscfWorkflow\n\n\nclass StaticEnergy__QuantumEspresso__ExampleSettings(PwscfWorkflow):\n\n    control = dict(\n        pseudo_dir__auto=True,\n        restart_mode=\"from_scratch\",\n        calculation=\"scf\",\n        tstress=True,\n        tprnfor=True,\n    )\n\n    system = dict(\n        ibrav=0,\n        nat__auto=True,\n        ntyp__auto=True,\n        ecutwfc__auto=\"efficiency\",\n        ecutrho__auto=\"efficiency\",\n    )\n\n    electrons = dict(\n        diagonalization=\"cg\",\n        mixing_mode=\"plain\",\n        mixing_beta=0.7,\n        conv_thr=\"1.0e-8\",\n    )\n\n    psuedo_mappings_set = \"SSSP_PBE_EFFICIENCY\"\n\n    k_points = dict(\n        spacing=0.5,\n        gamma_centered=True,\n    )\n</code></pre> <p>There are many more workflows and base classes to explore. Be sure to look through both our <code>Apps</code> and <code>Full Guides</code>.</p>"},{"location":"getting_started/database/access_thirdparty_data/","title":"d) Third-party data","text":""},{"location":"getting_started/database/access_thirdparty_data/#accessing-third-party-data","title":"Accessing Third-Party Data","text":""},{"location":"getting_started/database/access_thirdparty_data/#intro-to-third-party-data","title":"Intro to third-party data","text":"<p>There are many research teams in the larger community that have created databases consisting of over 100,000 structures, with calculations performed on each. In this section, we'll use Simmate to explore some of these datasets.</p> <p>We'll begin with one of the smaller datasets: JARVIS. Despite being smaller than others, it still contains approximately 56,000 structures.</p> <p>In DBeaver, you can find this table at <code>data_explorer_jarvisstructure</code>.</p>"},{"location":"getting_started/database/access_thirdparty_data/#loading-a-database","title":"Loading a Database","text":"<p>Previously, we loaded our <code>DatabaseTable</code> from the workflow. However, in this case, we want to directly access the JARVIS table. To do this, we run the following:</p> <pre><code>from simmate.database import connect  # (1)\nfrom simmate.apps.jarvis.models import JarvisStructure\n</code></pre> <ol> <li>This configures all database tables and establishes a connection to your database. It must be ran before any tables are imported.</li> </ol> <p>Warning</p> <p>The most common error when loading database tables directly from the <code>simmate.database</code> module is forgetting to connect to your database. Don't forget to include <code>from simmate.database import connect</code>!</p>"},{"location":"getting_started/database/access_thirdparty_data/#populating-data","title":"Populating Data","text":"<p>With our datatable class (<code>JarvisStructure</code>) loaded, let's check if it contains any data:</p> <pre><code>JarvisStructure.objects.count()\n</code></pre> <p>Note</p> <p>If you accepted the download during the <code>simmate database reset</code> command, you should see thousands of structures already in this database table! </p> <p>If the count returns 0, it means you still need to load data. You can quickly load all the data using the <code>load_remote_archive</code> method. This method downloads the JARVIS data from simmate.org and transfers it to your database. This process can take approximately 10 minutes as it saves all these structures to your computer, enabling you to load these structures in under a second in the future.</p> <pre><code>JarvisStructure.load_remote_archive()\n</code></pre> <p>Warning</p> <p>Please read the warnings printed by <code>load_remote_archive</code>. This data was NOT created by Simmate. We are merely distributing it on behalf of other teams. Please credit them for their work!</p>"},{"location":"getting_started/database/access_thirdparty_data/#exploring-the-data","title":"Exploring the Data","text":"<p>Now that our database is populated with data, we can start exploring it:</p> <pre><code>data = JarvisStructure.objects.to_dataframe(limit=150)  # (1)\n</code></pre> <ol> <li>We use limit=150 to just show the first 150 rows</li> </ol> <p>Let's test our filtering ability with this new data:</p> <pre><code>from simmate.database import connect\nfrom simmate.apps.jarvis.models import JarvisStructure\n\n# EXAMPLE 1: \nstructures_1 = JarvisStructure.objects.filter(nsites__lt=6).all()  # (1)\n\n# EXAMPLE 2:\nstructures_2 = JarvisStructure.objects.filter(  # (2)\n   formula_full=\"Mo1 S2\",\n   density__lt=5,\n   spacegroup__symbol=\"R3mH\",\n).all()\n\n# Convert to Dataframes\ndf_1 = structures_1.to_dataframe()\ndf_2 = structures_2.to_dataframe()\n</code></pre> <ol> <li>all structures that have less than 6 sites in their unitcell</li> <li>all MoS2 structures that are less than 5/A^3 and have a spacegroup symbol of R3mH</li> </ol> <p>Tip</p> <p>Note how we used <code>__lt</code> in our filter. <code>denity__lt=</code> translates to \"less than this density:\". There are many more filtered add-ons that you can use:</p> <ul> <li><code>contains</code> = contains text, case-sensitive query</li> <li><code>icontains</code>= contains text, case-insensitive query</li> <li><code>gt</code> = greater than</li> <li><code>gte</code> = greater than or equal to</li> <li><code>lt</code> = less than</li> <li><code>lte</code> = less than or equal to</li> <li><code>range</code> = provides upper and lower bound of values</li> <li><code>isnull</code> = returns True if the entry does not exist</li> </ul> <p>See the full guides for more information.</p>"},{"location":"getting_started/database/access_workflow_data/","title":"Accessing Results from Local Calculations","text":""},{"location":"getting_started/database/access_workflow_data/#loading-a-table","title":"Loading a Table","text":"<p>In the \"Workflow\" tutorial, we executed a calculation and stored the results in our database table. We also learned how to find the table and data in DBeaver. This section will guide you through accessing these results using Python.</p> <p>The results database table is always linked to the workflow via the <code>database_table</code> attribute. Here's how to load it:</p> <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"static-energy.quantum-espresso.quality00\")\ntable = workflow.database_table\n</code></pre>"},{"location":"getting_started/database/access_workflow_data/#viewing-available-columns","title":"Viewing Available Columns","text":"<p>To view the data stored in this table, use the <code>show_columns()</code> method. This will display all the columns in the table:</p> <pre><code>table.show_columns()\n</code></pre> <p>The output will be a list of all the columns in the table.</p>"},{"location":"getting_started/database/access_workflow_data/#converting-to-an-excel-like-table","title":"Converting to an Excel-like Table","text":"<p>To view a table's data, we will use the <code>objects</code> attribute to access the table rows (i.e., 1 object = 1 row). Therefore, something like <code>table.objects</code> effectively means \"grab all rows of this table\". Then to make things easier to view, we will convert these <code>objects</code> to a <code>DataFrame</code> object, which Spyder let's us open up:</p> <pre><code>data = table.objects.to_dataframe()\n</code></pre> <p>To view the table, double-click <code>data</code> in Spyder's variable explorer (top right window). Here's what a typical dataframe looks like in Spyder:</p> <p> </p>"},{"location":"getting_started/database/access_workflow_data/#basic-filtering","title":"Basic Filtering","text":"<p>You can also use the table columns to filter your results.</p> <pre><code>search_results = table.objects.filter(\n    formula_reduced=\"NaCl\",\n    nelements=2,\n).all()\n</code></pre> <p>In the previous example, we converted this list of results into a dataframe for easier viewing. You can also convert each row into a toolkit <code>Structure</code>. Feel free to experiment with each:</p> <pre><code># You can convert this list of objects to a dataframe like we did above\ndata = search_results.to_dataframe()\n\n# Or you can convert to a list of structure objects (ToolkitStructure)\nstructures = search_results.to_toolkit()\n</code></pre> <p>Note</p> <p>This may not seem very exciting now as we only have one row/structure in our table, but we'll explore more advanced filtering in the next section.</p>"},{"location":"getting_started/database/dbeaver/","title":"Viewing data with DBeaver","text":"<p>Note</p> <p>DBeaver is 100% optional, but without it, you may struggle to understand what your database is &amp; what it even looks like!</p>"},{"location":"getting_started/database/dbeaver/#why-dbeaver","title":"Why DBeaver?","text":"<p>Just as we use Excel for reading and analyzing <code>.xlsx</code> or <code>.csv</code> files, DBeaver is our go-to program for working with data from SQL databases. </p> <p>This includes managing files like <code>.sqlite3</code>, which is the format our Simmate database is currently in. In more advanced cases, we can even use DBeaver to connect to cloud-hosted databases, such as Postgres, which we will cover in a later tutorial.</p> <p>Ultimately, DBeaver will let us view data as if we were in Excel:</p> <p></p>"},{"location":"getting_started/database/dbeaver/#install-dbeaver","title":"Install DBeaver","text":"<p>Download install DBeaver Lite. It is free, and you do not need to make an account.</p> <p>DBeaver is just a regular desktop app, so open it up once installed. You'll see a variety of components when you first open it (but they will be empty at first):</p> <p></p>"},{"location":"getting_started/database/dbeaver/#connect-to-the-simmate-database","title":"Connect to the Simmate Database","text":"<ol> <li> <p>Select the \"New Database Connection\" button. This button is in the toolbar at the top of the page and looks like this: </p> </li> <li> <p>In the pop-up, you'll see a TON of database types that you can connect to. Search for \"SQLite\", select it, and then hit \"Next\". Its icon looks like this: </p> </li> <li> <p>Keep the <code>Connect by:</code> setting as <code>Host</code>. Then click the <code>Open ...</code> button and find your SQLite file. Remember, this file is located at <code>~/simmate/my_env-database.sqlite3</code>. Once selected, you can hit <code>Test Connection ...</code> (and install any necessary drivers if prompted). Hit <code>Finish</code> when everything looks good!</p> </li> <li> <p>You'll now see your Simmate database in the <code>Database Navigator</code>! (left side panel)</p> </li> </ol>"},{"location":"getting_started/database/dbeaver/#viewing-a-tables-data","title":"Viewing a Table's Data","text":"<ol> <li>Find your database in <code>Database Navigator</code> and <code>Tables</code> folder and see everything that Simmate built for you.</li> <li>Scroll down to the <code>workflows_staticenergy</code> table and double click to open it in the <code>Data Editor</code> (your main panel).</li> <li>You'll see three tabs at the top of the <code>Data Editor</code>: <code>Properties</code>, <code>Data</code>, and <code>ER Diagram</code>. Currently, we are looking at the <code>Properties</code> tab, which shows us a list of all the columns this table has. To view the actual table and data, select the <code>Data</code> tab.</li> <li>If you followed all tutorials, you should see some data from your workflow runs! If you accidentally reset your database, the table will be empty.</li> <li>Take a look at what information was stored from your calculation(s). There are a TON of columns available, so click around / sort by column / fiddle with your data. In the next tutorial, we will learn about why there are so many columns and where they come from.</li> </ol> <p>Tip</p> <p>If you'd like, you can export the table to a <code>.csv</code> file that you can then open in Excel. There is an <code>Export data</code> button at the bottom of your <code>Data</code> view.</p> <p>Danger</p> <p>DBeaver let's you click on &amp; update values within your table. Avoid doing this! You can corrupt and/or misrepresent your data this way. We recommend using DBeaver as if you have read-only permissions to your database.</p>"},{"location":"getting_started/database/intro_to_python_inheritance/","title":"Python Inheritance in Datatables","text":""},{"location":"getting_started/database/intro_to_python_inheritance/#recap-of-key-concepts","title":"Recap of Key Concepts","text":"<p>Before we proceed, let's quickly review the progress we've made so far...</p> <ul> <li> We established our database at <code>~/simmate/my_env-database.sqlite</code></li> <li> We ran a <code>quantum-espresso</code> workflow that stored results in our database</li> <li> We introduced Python classes, focusing on the significance of the <code>Structure</code> class</li> </ul> <p>Next, we'll build on these elements and learn about the database. </p>"},{"location":"getting_started/database/intro_to_python_inheritance/#a-basic-table","title":"A Basic Table","text":"<p>Let's start with the basics: what does the table you saw in DBeaver actually look like in Simmate's Python code?</p> <p>All datatables are represented by a class, and the general format is as follows:</p> <pre><code>from simmate.database.base_data_types import DatabaseTable, table_column\n\nclass MyExampleTable(DatabaseTable):\n   column_01 = table_column.CharField()  # CharField --&gt; text storage\n   column_02 = table_column.BoolField()  # BoolField --&gt; True/False storage\n   column_03 = table_column.FloatField()  # FloatField --&gt; number/decimal storage\n</code></pre> <p>The corresponding table (populated with random data) would look like this:</p> column_01 column_02 column_03 jack True 3.1456 lauren False 299792458 siona True 1.6180 scott False 1.602e-19 ... ... ... <p>Creating tables is as simple as defining a class, declaring it as a <code>DatabaseTable</code>, and specifying the desired columns with <code>table_column</code>.</p>"},{"location":"getting_started/database/intro_to_python_inheritance/#a-table-with-inheritance","title":"A Table with Inheritance","text":"<p>However, if we have multiple tables with similar data, this process can become repetitive. For instance, we might want to store structures in various tables, each with columns like density, number of sites, number of elements, etc. To streamline this process, we use Python \"inheritance\". Here's how it works...</p> <p>First, we define a table with common data (let's use <code>Person</code> as an example).</p> <pre><code>from simmate.database.base_data_types import DatabaseTable, table_column\n\nclass Person(DatabaseTable):\n   name = table_columns.CharField()\n   age = table_columns.IntField()\n   height = table_columns.FloatField()\n</code></pre> <p>Next, we create a separate table that includes this data and more:</p> <pre><code>class Student(Person):  # &lt;--- note we have Person here instead of DatabaseTable\n   year = table_columns.IntField()  # e.g. class of 2020\n   gpa = table_columns.FloatField()\n</code></pre> <p>The <code>Student</code> datatable now looks like this:</p> name age height year gpa jack 15 6.1 2020 3.6 lauren 16 5.8 2019 4.0 siona 15 5.6 2020 3.7 scott 14 6.2 2021 3.2 ... ... ... ... ... <p>Note that the <code>Student</code> table includes both our newly defined columns (<code>year</code> + <code>gpa</code>) as well as all of the columns from <code>Person</code> (<code>name</code>, <code>age</code>, <code>height</code>). This is because <code>Student</code> inherits from <code>Person</code>.</p>"},{"location":"getting_started/database/intro_to_python_inheritance/#a-full-example-in-simmate","title":"A full example in Simmate","text":"<p>Simmate uses this concept of inheritance with common materials science data. This includes tables for structures, thermodynamic data, site forces, and more.</p> <p>Let's use the <code>workflows_staticenergy</code> table as an example. Open this table in DBeaver, and take a closer look at all of the columns. This table inherits from several others:</p> <ul> <li><code>Structure</code></li> <li><code>Thermodynamics</code></li> <li><code>Forces</code></li> <li><code>Calculation</code></li> </ul> <p>This is because the calculation involves the following information, respectively:</p> <ul> <li>an input structure (formula, num_sites, density, etc.)</li> <li>thermodynamic data (final energy, energy per atom, stability, etc.)</li> <li>site forces and lattice stress (available because we used DFT to calculate the energy)</li> <li>general calculation info (e.g. calculation time, workflow name, dirctory name, etc.)</li> </ul> <p>This builds out the massive table for us. Then, during analysis, you can go in and select which columns you actually are interested in from the many available.</p> <p>Tip</p> <p>Experienced python users: take a look at our source code for the <code>StaticEnergy</code> table here. You'll see we just provide these data types as mix-ins.</p> <p>Warning</p> <p>Do not confuse the database table <code>Structure</code> with the toolkit <code>Structure</code>. One represents structural data in a table, while the other helps with advanced analysis and manipulation of a structure. You can use the aliases <code>DatabaseStructure</code> and <code>ToolkitStructure</code> to help keep them separate if you wish.</p> <p>Note also, you can convert a <code>ToolkitStructure</code> into a single row for a <code>DatabaseStructure</code>. Simmate does this frequently behind the scenes in order to save information to your database.</p>"},{"location":"getting_started/database/quick_start/","title":"Database Exploration","text":"<p>Tip</p> <p>We recommend using DBeaver to explore your database and all of its tables. DBeaver is free and production-ready for all database backends that we support (SQLite, Postgres, etc.).</p>"},{"location":"getting_started/database/quick_start/#quick-guide","title":"Quick Guide","text":"<ol> <li> <p>Ensure your database is initialized. This was done in earlier tutorials with the command <code>simmate database reset</code>. Do NOT rerun this command as it will clear your database and erase your results.</p> </li> <li> <p>(optional) Open up your database (<code>~/simmate/my_env-database.sqlite</code>) using DBeaver. Open and view the <code>workflows_staticenergy</code> table.</p> </li> <li> <p>The results table for Tutorial 2 is found in the <code>StaticEnergy</code> datatable class, which can be accessed via either of these options: <pre><code># OPTION 1\nfrom simmate.database import connect # this connects to our database\nfrom simmate.database.workflow_results import StaticEnergy\n\n# OPTION 2\nfrom simmate.workflows.utilities import get_workflow\nworkflow = get_workflow(\"static-energy.quantum-espresso.quality00\")\ntable = workflow.database_table  # yields the StaticEnergy class\n</code></pre></p> </li> <li> <p>Use <code>show_columns</code> to see all available table columns: <pre><code>table.show_columns()\n</code></pre></p> </li> <li> <p>Convert the full table to a pandas dataframe: <pre><code>df = table.objects.to_dataframe()\n</code></pre></p> </li> <li> <p>Use django-based queries to filter results. For example: <pre><code>filtered_results = table.objects.filter(\n    formula_reduced=\"NaCl\", \n    nsites__lte=2,\n).all()\n</code></pre></p> </li> <li> <p>Convert the final structure from a database object (aka <code>DatabaseStructure</code>) to a structure object (aka <code>ToolkitStructure</code>). <pre><code>single_relaxation = table.objects.filter(\n    formula_reduced=\"NaCl\", \n    nsites__lte=2,\n).first()\nnacl_structure = single_relaxation.to_toolkit()\n</code></pre></p> </li> <li> <p>Explore other tables and data available. For example, third-party data is automatically included in the prebuilt database (includes Material Project, AFLOW, COD, and more): <pre><code>from simmate.database import connect\nfrom simmate.apps.jarvis.models import JarvisStructure\n\nfirst_150_rows = JarvisStructure.objects.all()[:150]\ndataframe = first_150_rows.to_dataframe()\n</code></pre></p> </li> </ol>"},{"location":"getting_started/example_scripts/example-001/","title":"Example 001","text":""},{"location":"getting_started/example_scripts/example-001/#about","title":"About","text":"<p>This script queries the Material Project database for all ZnSnF6 structures with spacegroup=148 and then runs a (i) relaxation, (ii) static-energy, and (iii) bandstructure + density of states calculation on each -- passing the results between each step.</p> Key Info Contributor Becca Radomsky Github User @becca9835 Last updated 2023.05.01 Simmate Version v0.13.2"},{"location":"getting_started/example_scripts/example-001/#prerequisites","title":"Prerequisites","text":"<ul> <li> use a postgres database (guide)</li> <li> load the matproj database into your postgres database</li> <li> start a bunch of simmate workers (or a \"cluster\") (guide)</li> </ul>"},{"location":"getting_started/example_scripts/example-001/#the-script","title":"The script","text":"<p>Info</p> <p>We recommend submitting this script as it's own slurm job! This script will handle submitting other workflows and will finish when ALL workflows finish. </p> <p>Additionally, we run each job below with 8 cores, so our workers are also submitted to a SLURM cluster with n=8.</p> <pre><code>from simmate.database import connect\nfrom simmate.apps.materials_project.models import MatprojStructure\nfrom simmate.workflows.utilities import get_workflow\n\n# filter all the structures you want\nstructures = MatprojStructure.objects.filter(\n    spacegroup=148,\n    formula_reduced=\"ZnSnF6\",\n).all()\n\n# submit relaxations to cluster\nrelax_workflow = get_workflow(\"relaxation.vasp.matproj\")\nrelax_jobs = []\nfor structure in structures:\n    status = relax_workflow.run_cloud(\n        structure=structure,\n        command=\"mpirun -n 8 vasp_std &gt; vasp.out\",\n    )\n    relax_jobs.append(status)\n\n# as jobs finish, submit a static-energy for each\nstatic_workflow = get_workflow(\"static-energy.vasp.matproj\")\nstatic_jobs = []\nfor job in relax_jobs:\n    status = static_workflow.run_cloud(\n        # BUG: This assumes all jobs will complete successfully!\n        structure=job.result(), \n        command=\"mpirun -n 8 vasp_std &gt; vasp.out\",\n    )\n    static_jobs.append(status)\n\n# as jobs finish, submit a band structure + density of states\nelec_workflow = get_workflow(\"electronic-structure.vasp.matproj-full\")\nelec_jobs = []\nfor job in static_jobs:\n    status = elec_workflow.run_cloud(\n        structure=job.result(),\n        command=\"mpirun -n 8 vasp_std &gt; vasp.out\",\n    )\n    elec_jobs.append(status)\n\n# wait for all results to finish\nresults = [job.result() for job in elec_jobs]\n</code></pre>"},{"location":"getting_started/example_scripts/example-002/","title":"Example 002","text":""},{"location":"getting_started/example_scripts/example-002/#about","title":"About","text":"<p>This script configures and runs a custom NEB workflow that borrows features of path finding, endpoint relaxations, and more.</p> Key Info Contributor Becca Radomsky Github User @becca9835 Last updated 2023.12.30 Simmate Version v0.13.2"},{"location":"getting_started/example_scripts/example-002/#prerequisites","title":"Prerequisites","text":"<ul> <li> Simmate configured with default settings will work!</li> <li> The NEB settings below use CI-NEB, which requires some of the VTST-tools installed. You modify these settings to just use a normal VASP NEB run if you'd like (see the comment <code>Modify these if you don't want CI-NEB</code>).</li> </ul>"},{"location":"getting_started/example_scripts/example-002/#the-script","title":"The script","text":"<p>Info</p> <p>Run this script where you'd like the VASP calculations to run!</p> <p>The script can be called with something like <code>python myscript.py</code> and this line can be on your desktop, inside a SLURM job, or whereever!</p> <pre><code># -*- coding: utf-8 -*-\n\nfrom simmate.apps.vasp.inputs import PBE_POTCAR_MAPPINGS\nfrom simmate.apps.vasp.workflows.base import VaspWorkflow\nfrom simmate.apps.vasp.workflows.diffusion import (\n    NebAllPathsWorkflow,\n    SinglePathWorkflow,\n    VaspNebFromImagesWorkflow,\n)\n\n# -----------------------------------------------------------------------------\n\n# BULK UNITCELL RELAXATION\n\n\nclass Relaxation__Vasp__WarrenLab(VaspWorkflow):\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS\n    _incar = dict(\n        ALGO=\"Fast\",\n        EDIFF=1e-06,\n        ENCUT=520,\n        IBRION=2,\n        ICHARG=1,\n        ISIF=3,\n        ISPIN=2,\n        ISYM=0,\n        IVDW=12,\n        LORBIT=11,\n        LREAL=\"Auto\",\n        LWAVE=False,\n        NELM=200,\n        NELMIN=4,\n        NSW=99,\n        PREC=\"Accurate\",\n        ISMEAR=0,\n        SIGMA=0.05,\n        KSPACING=0.35,\n        LMAXMIX=4,\n    )\n\n\n# -----------------------------------------------------------------------------\n\n# BULK UNITCELL STATIC ENERGY\n\n\nclass StaticEnergy__Vasp__WarrenLab(VaspWorkflow):\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS\n    _incar = dict(\n        ALGO=\"Fast\",\n        EDIFF=1e-06,\n        ENCUT=520,\n        IBRION=-1,\n        ICHARG=1,\n        ISIF=3,\n        ISPIN=2,\n        ISYM=0,\n        IVDW=12,\n        LORBIT=11,\n        LREAL=\"Auto\",\n        LWAVE=False,\n        NELM=200,\n        NELMIN=4,\n        NSW=0,\n        PREC=\"Accurate\",\n        ISMEAR=0,\n        SIGMA=0.05,\n        KSPACING=0.35,\n        LMAXMIX=4,\n    )\n\n\n# -----------------------------------------------------------------------------\n\n# ENDPOINT SUPERCELL RELAXATIONS\n\n\nclass Relaxation__Vasp__WarrenLabNebEndpoint(VaspWorkflow):\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS\n    _incar = dict(\n        ALGO=\"Fast\",\n        EDIFF=5e-05,\n        EDIFFG=-0.01,\n        ENCUT=520,\n        IBRION=2,\n        ICHARG=1,\n        ISIF=2,\n        ISPIN=2,\n        ISYM=0,\n        IVDW=12,\n        LORBIT=11,\n        LREAL=\"Auto\",\n        LWAVE=False,\n        LCHARG=False,\n        NELM=200,\n        NSW=99,\n        PREC=\"Accurate\",\n        ISMEAR=0,\n        SIGMA=0.05,\n        KSPACING=0.4,\n        LMAXMIX=4,\n    )\n\n\n# -----------------------------------------------------------------------------\n\n# ENDPOINT SUPERCELL STATIC ENERGY\n\n\nclass StaticEnergy__Vasp__WarrenLabNebEndpoint(VaspWorkflow):\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS\n    _incar = dict(\n        ALGO=\"Fast\",\n        EDIFF=5e-05,\n        EDIFFG=-0.01,\n        ENCUT=520,\n        IBRION=-1,\n        ICHARG=1,\n        ISIF=2,\n        ISPIN=2,\n        ISYM=0,\n        IVDW=12,\n        LORBIT=11,\n        LREAL=\"Auto\",\n        LWAVE=False,\n        LCHARG=False,\n        NELM=200,\n        NSW=0,\n        PREC=\"Accurate\",\n        ISMEAR=0,\n        SIGMA=0.05,\n        KSPACING=0.4,\n        LMAXMIX=4,\n    )\n\n\n# -----------------------------------------------------------------------------\n\n# NEB FROM IMAGES\n\n\nclass Diffusion__Vasp__WarrenLabCiNebFromImages(VaspNebFromImagesWorkflow):\n    functional = \"PBE\"\n    potcar_mappings = PBE_POTCAR_MAPPINGS\n    _incar = dict(\n        ALGO=\"Fast\",\n        EDIFF=5e-05,\n        EDIFFG=-0.01,\n        ENCUT=520,\n        IBRION=3,\n        ICHARG=1,\n        ISIF=2,\n        ISPIN=2,\n        ISYM=0,\n        IVDW=12,\n        LORBIT=11,\n        LREAL=\"Auto\",\n        LWAVE=False,\n        LCHARG=False,\n        NELM=200,\n        NSW=99,\n        PREC=\"Accurate\",\n        ISMEAR=0,\n        SIGMA=0.05,\n        KSPACING=0.4,\n        LMAXMIX=4,\n        NIMAGES__auto=True,  # set automatically by simmate\n        # Modify these if you don't want CI-NEB\n        LCLIMB=True,\n        SPRING=-5,\n        POTIM=0,\n        IOPT=1,\n    )\n\n\n# -----------------------------------------------------------------------------\n# The two sections below use Simmate to piece together our individual\n# VASP calculations above.\n# -----------------------------------------------------------------------------\n\n# SINGLE PATH NEB\n\n\nclass Diffusion__Vasp__WarrenLabNebSinglePath(SinglePathWorkflow):\n    endpoint_relaxation_workflow = Relaxation__Vasp__WarrenLabNebEndpoint\n    endpoint_energy_workflow = StaticEnergy__Vasp__WarrenLabNebEndpoint\n    from_images_workflow = Diffusion__Vasp__WarrenLabCiNebFromImages\n\n\n# -----------------------------------------------------------------------------\n\n# ALL PATHS NEB\n\n\nclass Diffusion__Vasp__NebAllPathsWarrenLab(NebAllPathsWorkflow):\n    bulk_relaxation_workflow = Relaxation__Vasp__WarrenLab\n    bulk_static_energy_workflow = StaticEnergy__Vasp__WarrenLab\n    single_path_workflow = Diffusion__Vasp__WarrenLabNebSinglePath\n\n\n# -----------------------------------------------------------------------------\n# Now that we have our new &amp; custom NEB workflow, we can run that\n# full workflow analysis. Here, we just run it locally and one vasp calc\n# at a time.\n# -----------------------------------------------------------------------------\n\n# now run the workflow!\nresult = Diffusion__Vasp__NebAllPathsWarrenLab.run(\n    structure=\"example.cif\",\n    migrating_specie=\"Li\",\n    command=\"mpirun -n 10 vasp_std &gt; vasp.out\",  # make sure -n is divisible by nimages!\n    # Then any extra optional settings below.\n    # These parameters are automatically available thanks\n    # to the configuration we did above.\n    relax_bulk=True,\n    relax_endpoints=True,\n    nimages=5,\n    min_supercell_atoms=80,\n    max_supercell_atoms=240,\n    min_supercell_vector_lengths=10,\n    max_path_length=5,\n    percolation_mode=\"&gt;1d\",\n    vacancy_mode=True,\n)\n</code></pre>"},{"location":"getting_started/example_scripts/example_template/","title":"Example 001","text":""},{"location":"getting_started/example_scripts/example_template/#about","title":"About","text":"<p>This script does x, y, z using a, b, c...</p> Key Info Contributor Jack Sundberg Github User @jacksund Last updated 2023.05.31 Simmate Version v0.13.2"},{"location":"getting_started/example_scripts/example_template/#prerequisites","title":"Prerequisites","text":"<p>(note: these are common prerequisites for complex setups so we keep these below)</p> <ul> <li> use a postgres database (guide)</li> <li> load the matproj database into your postgres database</li> <li> start a bunch of simmate workers (or a \"cluster\") (guide)</li> </ul>"},{"location":"getting_started/example_scripts/example_template/#the-script","title":"The script","text":"<p>Info</p> <p>We recommend running this script as ....</p> <pre><code># paste in your python script here!\n</code></pre>"},{"location":"getting_started/example_scripts/overview/","title":"Example Scripts from Users","text":"<p>This section contains example Python scripts demonstrating the use of Simmate.</p> <p>Warning</p> <p>These examples do NOT cover all the features of Simmate, but they can be useful for beginners. </p> <p>Before referring to these examples, make sure to check the \"Full Guides\" and \"Apps\" sections.</p> Script Name Description Example-001 Runs relaxation, static-energy, and bandstruct/DOS calculations on a set of structures from the Materials Project. Example-002 Runs a custom NEB workflow incorporating features of path finding, endpoint relaxations, and more."},{"location":"getting_started/installation/command_line/","title":"Switching to the Command-line","text":"<p>While the Anaconda Navigator interface is a good entry point for beginners, the command-line is much faster and more powerful. Don't panic, it's simpler than it seems. Even if you're not familiar with coding, you can learn the command-line basics in a few minutes.</p>"},{"location":"getting_started/installation/command_line/#running-our-first-command","title":"Running our first command","text":"<p>Let's get started with our command-line:</p> <ul> <li>On Windows, search for and open \"Anaconda Powershell Prompt\" (or just Powershell) using your Start menu.</li> <li>On Mac and Linux, search for and open the app named \"Terminal\"</li> </ul> <p>You should see something like this:</p> <p> </p> <p>You'll notice <code>(base)</code> at the start of the line. This represents our current anaconda environment and shows we installed Anaconda correctly. Following that, you'll see the \"current working directory\", which is the folder we currently have open. On Windows, this will be your user folder (e.g. <code>C:\\Users\\johnsmith</code>), and for Mac/Linux, you'll see <code>~</code> which is shorthand for your user folder (e.g. <code>home/johnsmith</code>).</p> <p>Now, type in the command <code>cd Desktop</code> and press enter. This will open your Desktop folder. Then enter the command <code>ls</code>, which will list all files and folders on your Desktop. </p> <pre><code># run these two commands\ncd Desktop\nls\n</code></pre> <p>Tip</p> <p>Think of each command as a \"button\". For instance, the command <code>cd</code> stands for \"change directory\". When you use it, it opens a new folder to view its contents -- just like double-clicking a folder to open it.</p>"},{"location":"getting_started/installation/command_line/#mastering-new-commands","title":"Mastering new commands","text":"<p>Tip</p> <p>For more basic commands, refer to this cheat sheet or take a comprehensive tutorial. Remembering commands will come gradually, so keep this cheat-sheet handy. We strongly suggest that you spend 30 minutes going through these links after completing this tutorial.</p> <p>The challenging part with the command-line is knowing what to type. However, most programs have a single command that forms the base of more advanced one. For anaconda, the command is <code>conda</code>. If you're unsure about its function or usage, simply add <code>--help</code> to it. Type in the command <code>conda --help</code> and you'll see an output like this:</p> <pre><code>conda --help\n</code></pre> <pre><code>usage: conda [-h] [-V] command ...\n\nconda is a tool for managing and deploying applications, environments and packages.\n\nOptions:\n\npositional arguments:\n  command\n    clean        Remove unused packages and caches.\n    compare      Compare packages between conda environments.\n    config       Modify configuration values in .condarc. This is modeled after the git config command. Writes to the user .\n    ...\n\noptional arguments:\n  -h, --help     Show this help message and exit.\n  -V, --version  Show the conda version number and exit.\n\nconda commands available from other packages:\n  build\n  content-trust\n  ...\n</code></pre> <p>Don't get overwhelmed by the amount of information displayed. Each line conveys a simple concept. </p> <p>For instance, the line <code>-h, --help     Show this help message and exit.</code> explains what the <code>conda --help</code> command does! It also indicates that we could have used <code>conda -h</code> for the same output.</p> <p>This help message also reveals other \"subcommands\" available. One is <code>create</code> which creates a new environment. To learn more about that, we can run the command <code>conda create --help</code>. </p> <p>There's a lot here... But remember, you don't need to memorize all of this. Just remember how to access this help page when you need it. Or even easier, give a quick Google search or ask an AI chatbot for command help.</p> <p>Next, we'll use these commands to create our environment and install Simmate.</p>"},{"location":"getting_started/installation/create_your_env/","title":"Setting Up Your Env &amp; Installing Simmate","text":"<p>To begin, we'll establish a new environment using the conda-forge channel. Anaconda uses channels to download packages, and for simplicity, we'll consistently use conda-forge, which is a standard practice in the Python community.</p>"},{"location":"getting_started/installation/create_your_env/#1-environment-creation","title":"1. Environment Creation","text":"<p>Run the command below to create your environment. You can replace <code>my_env</code> with any name of your choice, but remember to use underscores instead of spaces (<code>my_env</code> is acceptable, <code>my env</code> will cause an error).</p> <pre><code>conda create -c conda-forge -n my_env python=3.11\n</code></pre> <p>Confirm the installation when prompted.</p>"},{"location":"getting_started/installation/create_your_env/#2-environment-activation","title":"2. Environment Activation","text":"<p>Switch to the newly created environment using the following command:</p> <pre><code>conda activate my_env\n</code></pre> <p>If it switched successfully, the start of your command line will change from <code>(base)</code> to <code>(my_env)</code>.</p>"},{"location":"getting_started/installation/create_your_env/#3-simmate-installation","title":"3. Simmate Installation","text":"<p>Now, let's install Simmate:</p> <pre><code>conda install -c conda-forge -n my_env simmate\n</code></pre> <p>The installation may take a few minutes. Once completed, Simmate is successfully installed! </p> <p>If you encounter any errors with this command, please inform our team by posting a new issue.</p>"},{"location":"getting_started/installation/create_your_env/#4-spyder-installation","title":"4. Spyder Installation","text":"<p>Lastly, let's install Spyder using Anaconda. This is optional, but if you're new to coding, you'll need Spyder for writing some Python code in later tutorials:</p> <pre><code>conda install -c conda-forge -n my_env spyder\n</code></pre>"},{"location":"getting_started/installation/explore_simmate_cli/","title":"Navigating Simmate's Command-Line Interface","text":"<p>Just as we used <code>conda --help</code> earlier, we can also use <code>--help</code> with Simmate. Try running the command:</p> <pre><code>simmate --help\n</code></pre> <p>The following output should be displayed:</p> <pre><code> Usage: simmate [OPTIONS] COMMAND [ARGS]...                                                                     \n\n This is the primary command from which all other Simmate commands originate. If you're new to the command line, we recommend starting with our tutorials. Below, you'll find a list of sub-commands to try. For instance, you can run `simmate database --help` to learn more about it.                  \n\n TIP: Many Simmate commands are lengthy and verbose. You can use --install-completion to add ipython-like autocomplete to your shell.                                                                                    \n\nOptions:\n--install-completion          Install completion for the current shell.                                      \n--show-completion             Show completion for the current shell, to copy it or customize the installation.                                                                  \n--help                        Show this message and exit.                                                    \n\nCommands:\ndatabase         A group of commands for managing your database                                              \nengine           A group of commands for starting up computational resources (Workers, Agents, and Clusters)          \nrun-server       Runs a local test server for the Simmate website interface                                  \nstart-project    Creates a new folder and fills it with an example project to get you started with custom Simmate workflows/datatables                                                                \nutilities        A group of commands for various simple tasks (such as file handling)                        \nworkflows        A group of commands for running workflows or viewing their settings                         \n</code></pre> <p>The output shows us that there are a bunch of other commands like <code>simmate database</code> and <code>simmate workflows</code> that we will explore in later tutorials.</p>"},{"location":"getting_started/installation/install_anaconda/","title":"Installing Anaconda","text":""},{"location":"getting_started/installation/install_anaconda/#why-anaconda","title":"Why Anaconda?","text":"<p>In an ideal world, you could download Simmate like any other desktop app and be ready to go. However, have you ever changed one thing on your computer only to find that another program stops working? This is a common occurrence with Python, so we need to tread carefully. For instance, consider the following scenario:</p> <ol> <li>Simmate which requires Python version 3.10 or greater</li> <li>A separate package which requires Python version 2.7</li> </ol> <p>The conflicting Python versions pose a problem. To address this, we use Anaconda. Anaconda installs Python and all our additional packages, including Simmate. To ensure nothing breaks, it isolates each of our installations into folders known as \"environments\".</p> <p>Anaconda also prevents the installation of conflicting packages within a single environment.</p> <p>Example</p> <p>With the two programs mentioned above, we could have two environments: one named <code>simmate_env</code> and another named <code>other_env</code> (you can name them anything). The two different Python versions and codes would be installed into separate folders to prevent interaction.</p>"},{"location":"getting_started/installation/install_anaconda/#installing-anaconda-and-a-first-look","title":"Installing Anaconda and a first look","text":"<p>In this tutorial, we'll install Anaconda on your local desktop/laptop. Even if you plan to use a university supercomputer (or any other remote computer system) to run workflows, stick to your local computer for now. We'll transition to your remote supercomputer in a later tutorial.</p>"},{"location":"getting_started/installation/install_anaconda/#1-install-anaconda","title":"1. Install Anaconda","text":"<p>To install Anaconda, you don't need to create an account on their website. Simply visit their download page and install Anaconda. Stick to the default options during installation.</p>"},{"location":"getting_started/installation/install_anaconda/#2-open-anaconda","title":"2. Open Anaconda","text":"<p>After the download is complete, launch the application, which will be named Anaconda Navigator.</p> <p>On the home screen, you'll see several \"IDEs\", such as Orange3, Jupyter Notebook, Spyder, and others. These IDEs are for writing your own Python code. Just as there are multiple platforms like Microsoft Word, Google Docs, &amp; LibreOffice for writing essays, these IDEs offer different ways to write Python. We recommend Spyder, which we will introduce in a later tutorial (so don't select it yet).</p> <p> </p>"},{"location":"getting_started/installation/install_anaconda/#3-view-environments","title":"3. View environments","text":"<p>On the left side of the application window, you'll find an Environments tab. Click on it. When you first install Anaconda, there will only be a `base`` environment with popular packages already installed. You can create new environments here and install new packages into each -- all without affecting what's already installed.</p> <p> </p>"},{"location":"getting_started/installation/install_anaconda/#final-comments","title":"Final comments","text":"<p>That's all there is to the Anaconda interface! While we can install Simmate using this interface, it's actually simpler with the command-line. The rest of this tutorial will use the command-line instead of the Anaconda Navigator interface.</p> <p>Tip</p> <p>If you want a more comprehensive overview of Anaconda, they offer a series of getting-started guides. However, these guides aren't necessary for using Simmate (so don't spend more than 10 minutes browsing through them).</p>"},{"location":"getting_started/installation/local_server_setup/","title":"Launching Your Local Test Server","text":"<p>Our official website allows you to view datasets, such all your past workflow results or downsets that you've download from other sources. We haven't loaded any data yet, but you can still start up the website on your local computer using two simple commands.</p>"},{"location":"getting_started/installation/local_server_setup/#1-reset-the-database","title":"1. Reset the Database","text":"<p>Firstly, we need to configure our database. We'll explain this more in a following tutorial, but for now, consider this as creating an empty Excel spreadsheet that we'll populate with data later. This can be done with:</p> <pre><code>simmate database reset\n</code></pre> <p>When prompted, confirm that you want to reset/delete your \"old\" database. Also, agree to download and use a prebuilt database.</p> <p>Tip</p> <p>You won't need to run this command again unless you want to erase all your data and start anew. Ideally, you have a single database that grows over time. But still, sometimes it's good to start from scratch when you're testing things out, so this <code>reset</code> command is handy in those cases.</p>"},{"location":"getting_started/installation/local_server_setup/#2-start-the-server","title":"2. Start the Server","text":"<p>For our second step, we simply instruct Simmate to launch the server:</p> <pre><code>simmate run-server\n</code></pre> <p>... and after a few moments, you should see the following output:</p> <pre><code>Starting development server at http://127.0.0.1:8000/\nQuit the server with CTRL-BREAK.\n</code></pre> <p>Keep this command running in your terminal and open the link http://127.0.0.1:8000/ in your preferred browser (Chrome, Firefox, etc.). You should see a site that resembles the simmate.org website!</p> <p>Tip</p> <p>The <code>simmate run-server</code> command will run forever if you let it. To stop it, use <code>crtl+c</code> or close your terminal window completely. Once stopped, you'll see that the website stops working in your browser as well.</p>"},{"location":"getting_started/installation/local_server_setup/#final-comments","title":"Final comments","text":"<p>The server we just started is hosted on your local computer. It's not accessible via the internet, and it will cease to function as soon as you close your terminal running the <code>simmate run-server</code> command. However, when we switch to a server that's accessible via the internet, Simmate's full set of features become available. This allows you to share results and computational resources with your entire team &amp; accross many computers. This is covered in a later tutorial.</p> <p>Additionally, keep in mind that Simmate's Python and command-line interfaces offer many more features than what is available in the website. To learn about these features, continue reading our tutorials!</p>"},{"location":"getting_started/installation/quick_start/","title":"Installation","text":""},{"location":"getting_started/installation/quick_start/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Download and install anaconda</p> <p>Warning</p> <p>Anaconda requires a license if you work at a company with &gt;200 employees (academic instituitions exlcuded). If this applies to you, download miniforge instead, which is free &amp; open-source for everyone. The conda commands below will be the same.</p> </li> <li> <p>Set up a conda environment, install Simmate within it, and activate it <pre><code>conda create -n my_env -c conda-forge python=3.11 simmate\nconda activate my_env\n</code></pre></p> </li> <li> <p>Run the help command to verify the installation <pre><code>simmate --help\n</code></pre></p> </li> <li> <p>For first-time setup, initialize your local database (SQLite) <pre><code>simmate database reset\n</code></pre></p> </li> <li> <p>Start the local dev server and keep this command running <pre><code>simmate run-server\n</code></pre></p> </li> <li> <p>Visit http://127.0.0.1:8000/ to access your local server</p> </li> </ol>"},{"location":"getting_started/toolkit/advanced_classes/","title":"Advanced Classes","text":""},{"location":"getting_started/toolkit/advanced_classes/#exploring-beyond-the-structure-class","title":"Exploring Beyond the Structure Class","text":"<p>This section provides a glimpse into some advanced classes and functionalities. Please note that Simmate is still in its early development stages, and there are many more features available through the PyMatGen and MatMiner packages, which were installed alongside Simmate.</p> <p>Tip</p> <p>If you're attempting to follow a paper and analyze a structure, chances are there's a class/function already created for that analysis! Make sure to explore the full guides or simply post a question and we'll direct you to the right path.</p>"},{"location":"getting_started/toolkit/advanced_classes/#example-1-creating-structures","title":"Example 1: Creating Structures","text":"<p>Currently, Simmate's toolkit is most effective for structure creation. This includes generating structures from random symmetry, prototype structures, and more. All we need to do is provide these \"creator\" classes with a composition object:</p> <pre><code>from simmate.toolkit import Composition\nfrom simmate.toolkit.creators import RandomSymStructure\n\ncomposition = Composition(\"Ca2N\")\ncreator = RandomSymStructure(composition)\n\nstructure1 = creator.create_structure(spacegroup=166)\nstructure2 = creator.create_structure(spacegroup=225)\n</code></pre>"},{"location":"getting_started/toolkit/advanced_classes/#example-2-fingerprint-analysis","title":"Example 2: Fingerprint Analysis","text":"<p>Matminer is especially useful for analyzing a structure's features and creating machine-learning inputs. A common analysis provides the structure's fingerprint, which aids in characterizing bonding in the crystal. The most basic fingerprint is the radial distribution function (rdf) -- it displays the distance between all atoms. We can take any structure object and feed it to a matminer <code>Featurizer</code> object:</p> <pre><code>from matminer.featurizers.structure.rdf import RadialDistributionFunction\n\nrdf_analyzer = RadialDistributionFunction(bin_size=0.1)\n\nrdf1 = rdf_analyzer.featurize(structure1)\nrdf2 = rdf_analyzer.featurize(structure2)\n</code></pre> <p>We can also plot an RDF using python. Since Matminer doesn't currently offer a convenient way to plot this (with Simmate, there would be a <code>show_plot()</code> method), we can use this opportunity to learn how to plot things ourselves:</p> <pre><code>import matplotlib.pyplot as plt\n\n# The x-axis ranges from 0.1 to 20 in steps of 0.1 (in Angstroms).\n# Matminer doesn't provide a list of these values but\n# we can generate it using this line.\nrdf_x = [n/10 + 0.1 for n in range(0, 200)]\n\n# Create a simple line plot with lists of (x,y) values\nplt.plot(rdf_x, rdf1)\n\n# Display the plot without any additional formatting or labels.\nplt.show()\n</code></pre>"},{"location":"getting_started/toolkit/advanced_classes/#example-3-matching-structures","title":"Example 3: Matching Structures","text":"<p>Pymatgen is currently the most extensive package and offers the most toolkit-like features. For instance, it's common to compare two structures to determine if they are symmetrically equivalent (within a given tolerance). You provide it with two structures, and it will return True or False based on whether they match:</p> <pre><code>from pymatgen.analysis.structure_matcher import StructureMatcher\n\nmatcher = StructureMatcher()\n\n# Now let's compare our two random structures!\n# This should return False. You can verify this in your Spyder variable explorer.\nis_matching = matcher.fit(structure1, structure2)  \n</code></pre>"},{"location":"getting_started/toolkit/intro_to_spyder/","title":"An Introduction to Python &amp; Spyder","text":""},{"location":"getting_started/toolkit/intro_to_spyder/#introduction-to-python","title":"Introduction to Python","text":"<p>If you're new to coding and Python, you will still be able to read along and follow this tutorial.</p> <p>However, we strongly recommend dedicating 2-3 days to learn Python fundamentals once you complete the tutorial. Python fundamentals are beyond the scope of our guides, but resources such as Codecademy's Python lessons are excellent for beginners.</p>"},{"location":"getting_started/toolkit/intro_to_spyder/#where-to-write-python-code","title":"Where to write Python code","text":"<p>Remember from the Installation tutorial: Anaconda provided several programs on their home screen, including Jupyter Notebook, Spyder, and others. These programs allow you to write your own Python code. Just as there are various platforms for writing papers, like Microsoft Word, Google Docs, and LibreOffice, these programs offer different ways to write Python. </p> <p>Our team prefers Spyder, and we highly recommend it to our users. We will use Spyder in this tutorial.</p>"},{"location":"getting_started/toolkit/intro_to_spyder/#launching-spyder","title":"Launching Spyder","text":"<p>Tip</p> <p>If you're already comfortable with Python or have completed the Codecademy python course, you can quickly familiarize yourself with Spyder by watching their intro videos. There are 3 videos, each under 4 minutes long.</p> <p>If you followed the installation tutorial, Spyder should already be installed and ready to use. </p> <p>To launch it, search for Spyder in your computer's apps (use the search bar at the bottom-left of your screen on Windows 10) and select <code>Spyder (my_env)</code>. </p> <p>Spyder will be empty when you first launch it. Here's a glimpse of what Spyder looks like when it's in use:</p> <p> </p>"},{"location":"getting_started/toolkit/intro_to_spyder/#running-python-code","title":"Running Python code","text":"<p>For this tutorial, we'll only be using the Python console (located at the bottom-right of the screen). The console behaves just like our command-line, except it runs Python code instead.</p> <p>To kick things off, paste the following in the console &amp; hit enter to run: <pre><code>x = 123 + 321\n\nprint(\"Using Python, we found the value of x:\")\nprint(x)\n</code></pre></p> <p>In the output, you should see our message and the answer <code>444</code>.</p>"},{"location":"getting_started/toolkit/quick_start/","title":"Analyzing &amp; Modifying Structures","text":"<p>Tip</p> <p>Simmate toolkit still uses pymatgen. Therefore, this tutorial also serves as a guide to using their package. See also:</p> <ul> <li>outline of all available methods &amp; properties (see <code>Full Guides</code> &gt; <code>Toolkit</code>)</li> <li>PyMatGen's official guides &amp; API reference</li> </ul>"},{"location":"getting_started/toolkit/quick_start/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Ensure you have the <code>POSCAR</code> file of NaCl from the previous tutorial.</p> </li> <li> <p>You can load the structure into python: <pre><code>from simmate.toolkit import Structure\n\nstructure = Structure.from_file(\"POSCAR\")\n</code></pre></p> </li> <li> <p>Access various properties of the structure, lattice, and composition: <pre><code># explore structure-based properties\nstructure.density\nstructure.distance_matrix\nstructure.cart_coords\nstructure.num_sites\n\n# access the structure's composition and its properties\ncomposition = structure.composition\ncomposition.reduced_formula\ncomposition.elements\n\n# access the structure's lattice and its properties\nlattice = structure.lattice\nlattice.volume\nlattice.matrix\nlattice.beta\n</code></pre></p> </li> <li> <p>Create new structures using some transformation or analysis: <pre><code>structure.add_oxidation_state_by_guess()\nstructure.make_supercell([2,2,2])\n</code></pre></p> </li> <li> <p>Export your final structure to a new file format: <pre><code>structure.to(filename=\"NaCl.cif\", fmt=\"cif\")\n</code></pre></p> </li> </ol>"},{"location":"getting_started/toolkit/quick_start/#extra-examples","title":"Extra Examples","text":"<p>Looking for advanced features? Simmate is gradually incorporating these into our toolkit module, but many more are available through PyMatGen and MatMiner (which are preinstalled for you).</p>"},{"location":"getting_started/toolkit/quick_start/#random-structure-creation","title":"Random Structure Creation","text":"<p>Creating a random structure from a spacegroup and composition:</p> <pre><code>from simmate.toolkit import Composition\nfrom simmate.toolkit.creators import RandomSymStructure\n\ncomposition = Composition(\"Ca2N\")\ncreator = RandomSymStructure(composition)\n\nstructure = creator.create_structure(spacegroup=166)\n</code></pre>"},{"location":"getting_started/toolkit/quick_start/#fingerprints-matminer","title":"Fingerprints (MatMiner)","text":"<p>Matminer is useful for analyzing structures and creating machine-learning inputs. One common analysis is the generating a RDF fingerprint to help analyze bonding and compare structures:</p> <pre><code>from matminer.featurizers.structure.rdf import RadialDistributionFunction\n\nrdf_analyzer = RadialDistributionFunction(bin_size=0.1)\nrdf = rdf_analyzer.featurize(structure)\n</code></pre>"},{"location":"getting_started/toolkit/quick_start/#structure-matching-pymatgen","title":"Structure Matching (PyMatGen)","text":"<p>Pymatgen currently offers the most functionality. One common function is checking if two structures are symmetrically equivalent (under some tolerance):</p> <pre><code>from pymatgen.analysis.structure_matcher import StructureMatcher\n\nmatcher = StructureMatcher()\nis_matching = matcher.fit(structure1, structure2)\n</code></pre>"},{"location":"getting_started/toolkit/the_structure_class/","title":"The <code>Structure</code> Class","text":"<p>Note</p> <p>This is the longest section of all our getting-started guides -- but take your time here and don't skip anything. Understanding the toolkit <code>Structure</code> class is essential when using Simmate.</p>"},{"location":"getting_started/toolkit/the_structure_class/#intro-to-python-classes","title":"Intro to Python Classes","text":"<p>In Python, a class is like a blueprint that defines how something should be created. </p> <p>Let's say you want to describe a car. The class would define what a car is \u2013 what attributes it has (like color, model, and speed) and what it can do (like drive or honk). Once you have this blueprint, you can create specific cars (objects) based on it. Each car you create is a unique instance of the class with its own characteristics. So, a class is like a template that helps you organize and create objects in your code.</p> <p>This becomes incredibly powerful when we start building out functionality and analyses.</p> <p>Example</p> <p>Consider these analogies: </p> <ul> <li>lions, tigers, and bears are examples of animals. In Python, we could say that <code>lion</code>, <code>tiger</code>, and <code>bear</code> are objects of the class <code>Animal</code>.</li> <li>McDonald's, Burger King, and Wendy's are examples of restaurants. In Python, we could say that <code>mcdonalds</code>, <code>burgerking</code>, and <code>wendys</code> are objects of the class <code>Restaurant</code>.</li> </ul>"},{"location":"getting_started/toolkit/the_structure_class/#the-structure-class_1","title":"The <code>Structure</code> class","text":"<p>In materials science, the most commonly used class is for crystal structures. In Simmate, this class is called <code>Structure</code>. </p> <p>A crystal structure always consists of a lattice and a list of atomic sites. This is exactly what we have in our <code>POSCAR</code> file from tutorial 2. </p> <p>Let's use Simmate to create an object of the <code>Structure</code>. Enter this line into the Python console:</p> <pre><code>from simmate.toolkit import Structure\n</code></pre> <p>This line loads the <code>Structure</code> class from Simmate's code it now ready to be used.</p>"},{"location":"getting_started/toolkit/the_structure_class/#summary-of-steps","title":"Summary of Steps","text":"<p>Once we have our <code>Structure</code> class loaded &amp; ready to help, analyzing a structure usually involves the following steps:</p> <ol> <li>Loading a structure into Python</li> <li>Cleaning up &amp; modifying the structure as needed</li> <li>Analyzing the structure's properties and features</li> <li>Exporting the structure in a different format</li> </ol> <p>While only the first step is mandatory, the rest are optional and can be customized according to your needs.</p>"},{"location":"getting_started/toolkit/the_structure_class/#basic-example","title":"Basic Example","text":"<p>Here's a script that covers each of the steps mentioned above:</p> <pre><code>from simmate.toolkit import Structure\n\n# 1: Import\nstructure = Structure.from_file(\"POSCAR\")\n\n# 2: Clean / Modify\nstructure = structure.get_primitive_structure()\n\n# 3: Analyze \nprint(f\"Density: {structure.density}\")\n\n# 4: Export\nstructure.to(filename=\"output.cif\", fmt=\"cif\")\n</code></pre> <p>In the steps below, we will walk through how to build your own script.</p>"},{"location":"getting_started/toolkit/the_structure_class/#1-load","title":"1. Load","text":"<p>Now, we will tell Python that we have a <code>Structure</code> and its information is located in the <code>POSCAR</code> file:</p> <pre><code>nacl_structure = Structure.from_file(\"POSCAR\")\n</code></pre> <p>Warning</p> <p>Before loading a structure, ensure you have the correct working directory (as we did with the command-line). Spyder displays this in the top right, and you can change it by clicking the folder icon. We want to be in the same folder as our <code>POSCAR</code> file.</p> <p>To view the structure you just loaded:</p> <pre><code>print(nacl_structure)\n</code></pre> <p>Tip</p> <p>There are MANY other ways to load structures, such as from different file formats or even python directly. To explore the different loading options, refer to our full guides.</p> <p>For example, you can create a structure directly in python: <pre><code>from simmate.toolkit import Structure\n\nstructure = Structure(\n    lattice=[\n        [3.48543651, 0.0, 2.01231771],\n        [1.16181217, 3.28610106, 2.01231771],\n        [0.0, 0.0, 4.02463542],\n    ],\n    species=[\"Na\", \"Cl\"],\n    coords=[\n        [0.0000, 0.0000, 0.0000],\n        [0.5000, 0.5000, 0.5000],\n    ],\n)\n</code></pre></p>"},{"location":"getting_started/toolkit/the_structure_class/#2-clean-modify","title":"2. Clean &amp; Modify","text":"<p>With our structure loaded, we can now learn the importance of the <code>Structure</code> class. A <code>Structure</code> object will have <code>properties</code> and <code>methods</code> available to help us perform common tasks and calculations. A <code>property</code> is a characteristic of an object (such as density or volume), where a method performs a specific task using optional parameters (such as symmetry analysis).</p> <p>Let's first learn about methods by cleaning our structure. We will converting it to the primitive unitcell and then create a 2x2x2 supercell.</p> <p>i: Symmetry reduction</p> <p>The <code>get_primitive_structure()</code> method can convert a conventional unit cell into a primitive unit cell:</p> <pre><code>nacl_structure.get_primitive_structure()\n</code></pre> <p>This command will display a new structure, which should match the primitive structure we already have. You can also store the result in a new Structure object. For example:</p> <pre><code>nacl_prim = nacl_structure.get_primitive_structure()\n</code></pre> <p>All methods end with parentheses <code>()</code>, which allow you to modify the method using optional input parameters. For example, the <code>get_primitive_structure()</code> method uses symmetry in its calculations, and you can adjust the tolerance for symmetry with:</p> <pre><code>nacl_structure.get_primitive_structure(tolerance=0.1)\n</code></pre> <p>This command will identify atoms as symmetrically identical if they are nearly in their 'symmetrically correct' positions (within 0.1 Angstrom). If you don't specify a tolerance, the method will use a default value. </p> <p>ii: Creating Supercells</p> <p>Some methods, require an input parameters. This includes the <code>make_supercell</code> method wich must be given the supercell size that you want it to make:</p> <pre><code>nacl_structure.make_supercell([2,2,2])\n</code></pre> <p>Tip</p> <p>See our <code>Tips &amp; Tricks</code> section below for viewing all available <code>Structure</code> methods</p>"},{"location":"getting_started/toolkit/the_structure_class/#3-analyze","title":"3. Analyze","text":"<p>In step 2, we mentioned \"properties\" but did not show examples. We will use properties (and a few more methods) to analyze our structure.</p> <p>Basic properties:</p> <p>Properties are essentially fixed formulas that we can follow. For instance, all structures possess a <code>density</code> property, which can be computed once the lattice and atomic sites are known. The formula for this calculation remains constant, allowing for automation. </p> <p>Unlike methods, however, there are no optional parameters for properties. Therefore, we do not need <code>()</code> at the end of them. Try accessing some: <pre><code>nacl_structure.density\nnacl_structure.num_sites\nnacl_structure.frac_coords\nnacl_structure.cart_coords\n</code></pre></p> <p>Advanced properties: Now, what if we want a bunch of properties relating to lattice such as volume, angles, and vectors? </p> <p>For better organization, the <code>Structure</code> class includes an associated class called <code>Lattice</code>. Within the <code>lattice</code> object, properties like <code>volume</code>, <code>angles</code>, <code>vectors</code> can be found. In other words, our <code>Structure</code> class is made up of smaller class objects like <code>Lattice</code>, <code>PeriodicSite</code>, and <code>Composition</code> that help us further organize properties and methods.</p> <p>Try accessing the lattice and composition properties (run one line at a time): <pre><code># Lattice properties\nnacl_structure.lattice.volume\nnacl_structure.lattice.matrix\nnacl_structure.lattice.beta\n\n# Compostion properties\nnacl_structure.composition.reduced_formula\nnacl_structure.composition.elements\n</code></pre></p> <p>Tip</p> <p>See our <code>Tips &amp; Tricks</code> section below for viewing all available <code>Structure</code> properties</p> <p>Tip</p> <p>For convenience, you can use a shortcut. Save the <code>Lattice</code> object to a new variable name (here, it's <code>l</code>, but you can choose a different name) and then call its properties:</p> <pre><code>l = nacl_structure.lattice\nl.volume\nl.matrix\nl.beta\n</code></pre>"},{"location":"getting_started/toolkit/the_structure_class/#4-export","title":"4. Export","text":"<p>Moving your structure from Python and back into a file will be our easiest step. There are a variety of formats available (<code>CIF</code>, <code>POSCAR</code>, <code>QE</code>, ...) which listed out in the full guides:</p> <pre><code>structure.to(filename=\"output.cif\", fmt=\"cif\")\n</code></pre>"},{"location":"getting_started/toolkit/the_structure_class/#extra-tips-tricks","title":"Extra Tips &amp; Tricks","text":""},{"location":"getting_started/toolkit/the_structure_class/#viewing-python-variables","title":"Viewing python variables","text":"<p>As you create new python objects and assign them different names, you'll need a way to keep track of them. Spyder's variable explorer (located in the top right window tab) can help with this. Try double-clicking on some of your variables to explore what Spyder can do:</p> <p> </p>"},{"location":"getting_started/toolkit/the_structure_class/#finding-methods-properties","title":"Finding methods &amp; properties","text":"<p>To see all the available properties and methods, type <code>nacl_structure</code> (or whatever your variable name is) into the terminal, add a dot (<code>.</code>), and then press <code>tab</code>. A list of options will appear. </p> <p>You can also explore the properties and methods of other classes, such as <code>lattice</code>, using the same method. The list should look something like this (note, this image uses numpy as an example):</p> <p> </p>"},{"location":"getting_started/toolkit/the_structure_class/#running-python-structures-in-workflows","title":"Running Python Structures in Workflows","text":"<p><code>Structure</code> objects can be used to run a workflow. We did this with the command-line in the last tutorial but can accomplish the same thing with Python:</p> python <pre><code>from simmate.toolkit import Structure\nfrom simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"static-energy.quantum-espresso.quality00\")\nnacl = Structure.from_file(\"POSCAR\")\nresult = workflow.run(structure=nacl)\n</code></pre> <p>Note</p> <p>As you get more confortable with Python, you'll learn that almost everything is a class or object. In fact, the workflow we just ran uses a <code>Workflow</code> class!</p> <p>Tip</p> <p>As a shortcut, we could have just given the filename to our workflow:</p> pythonyaml <pre><code>from simmate.workflows.utilities import get_workflow\n\nworkflow = get_workflow(\"static-energy.quantum-espresso.quality00\")\nresult = workflow.run(structure=\"POSCAR\")\n</code></pre> <pre><code>workflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\n</code></pre>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/","title":"b) Building a database","text":"<p>Tip</p> <p>Ensure you've read the previous section! Database setup can be complex, and most users can bypass it entirely.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#selecting-your-database-engine","title":"Selecting your database engine","text":"<p>Simmate employs Django ORM for database construction and management, meaning any Django-supported database can be used with Simmate. </p> <p>This encompasses PostgreSQL, MariaDB, MySQL, Oracle, SQLite, and others via third-party providers. noSQL databases like MongoDB are supported through djongo. Comprehensive documentation for Django databases is available here. </p> <p>However, we strongly recommend opting for Postgres, which we discuss in the following section.</p> <p>Warning</p> <p>Our team utilizes SQLite (for local testing) and PostgreSQL (for production), so currently, we can only provide guidance on these two backends. You're free to use others, but be aware that we haven't extensively tested these backends and may not be able to assist with troubleshooting if issues occur.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#introduction-to-postgres-setup","title":"Introduction to Postgres setup","text":"<p>PostgreSQL is free and open-source, allowing you to avoid costs and set it up manually.</p> <p>However, using a database service such as DigitalOcean, Linode, GoogleCloud, AWS, Azure, or another provider is MUCH simpler. These providers set up the database for you through a user-friendly interface.</p> <p>If you prefer to manually build a Postgres server, numerous tutorials and guides are available (1, 2, etc.). Be aware that this can be time-consuming and your final database connection may be slower if your team operates from multiple locations. </p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#setting-up-postgres-with-digitalocean","title":"Setting up Postgres with DigitalOcean","text":""},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#introduction-expected-costs","title":"Introduction &amp; expected costs","text":"<p>Our team uses DigitalOcean, where the basic database server (~$15/month) is sufficient for Simmate usage. You'll only need &gt;10GB if you're running &gt;100,000 structure relaxations or frequently using unit cells with &gt;1000 atoms.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#i-account-creation","title":"(i) Account creation","text":"<p>Start by creating an account on DigitalOcean using this link (our referral). We suggest signing in with your Github account. This referral link provides:</p> <ol> <li>$100 credit for servers from DigitalOcean (valid for 60 days)</li> <li>$10 credit for the Simmate team from DigitalOcean, helping fund our servers</li> </ol> <p>If you encounter any issues, please verify that DigitalOcean is still offering this deal here. Simmate is not affiliated with DigitalOcean.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#ii-cloud-database-creation","title":"(ii) Cloud database creation","text":"<ol> <li>On the DigitalOcean dashboard, click the green \"Create\" button in the top right and select \"Database\". This should take you to this page.</li> <li>For \"database engine\", select the latest version of PostgreSQL (currently v14)</li> <li>Leave the rest of the page's options at their default values.</li> <li>Click Create a Database Cluster when ready.</li> <li>On your new cluster's homepage, there's a \"Get Started\" button. We'll go through this dialog in the next section.</li> </ol> <p>Note, this is the database cluster, which can host multiple databases (each with their own tables).</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#iii-database-connection","title":"(iii) Database connection","text":"<p>Before setting up our database on this cluster, we'll first try connecting to the default database on it (named <code>defaultdb</code>).</p> <ol> <li>On your new database's page, you'll see a \"Getting Started\" dialog -- select it!</li> <li>\"Restrict inbound connections\" is optional and beginners should skip it for now. We skip this because if you're running calculations on a supercomputer/cluster, you'll need to add ALL the associated IP addresses for connections to work properly. That's a lot of IP addresses to collect and configure correctly -- so we leave this to advanced users.</li> <li>\"Connection details\" is the information we need to provide to Simmate/Django. Let's copy this information. For example, here's what the details look like on DigitalOcean: <pre><code>username = doadmin\npassword = asd87a9sd867fasd\nhost = db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\nport = 25060\ndatabase = defaultdb\nsslmode = require\n</code></pre></li> <li> <p>In your Simmate Python environment, ensure you have the Postgres engine installed. The package is <code>psycopg2</code>, which allows Django to communicate with Postgres. To install this, run the command: <pre><code>conda install -n my_env -c conda-forge psycopg2\n</code></pre></p> </li> <li> <p>We need to pass this information to Simmate (which connects using Django). To do this, add a file named <code>my_env-settings.yaml</code> (using your conda env name) to your Simmate config directory (<code>~/simmate</code>) with the following content -- make sure to substitute in your connection information: <pre><code>database:\n  engine: django.db.backends.postgresql\n  host: db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\n  name: defaultdb\n  user: doadmin\n  password: asd87a9sd867fasd\n  port: 25060\n  options:\n    sslmode: require\n</code></pre></p> </li> <li>Verify that you can connect to this database on your local computer by running the following in Spyder: <pre><code>from simmate.configuration import settings\n\nprint(settings.database)  # this should display your connect info!\n</code></pre></li> </ol>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#iv-creating-a-separate-database-for-testing-on-the-same-server","title":"(iv) Creating a separate database for testing (on the same server)","text":"<p>Just as we don't use the <code>(base)</code> environment in Anaconda, we don't want to use the default database <code>defaultdb</code> on our cluster. Here we'll create a new database -- one that we can delete if we want to start over.</p> <ol> <li>On DigitalOcean with your Database Cluster page, select the \"Users&amp;Databases\" tab.</li> <li>Create a new database using the \"Add new database\" button and name it <code>simmate-database-00</code>. We name it this way because you may want to create new/separate databases and numbering is a quick way to keep track of these.</li> <li>In your connection settings (from the section above), switch the NAME from defaultdb to <code>simmate-database-00</code>. You will change this in your <code>my_env-database.yaml</code> file.</li> </ol>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#v-building-our-database-tables","title":"(v) Building our database tables","text":"<p>Now that we've set up and connected to our database, we can create our Simmate database tables and start populating them with data! We do this the same way we did without a cloud database:</p> <ol> <li>In your terminal, ensure you have your Simmate environment activated</li> <li>Run the following command:  <pre><code>simmate database reset\n</code></pre></li> <li>You're now ready to start using Simmate with your new database!</li> </ol>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#vi-creating-a-connection-pool","title":"(vi) Creating a connection pool","text":"<p>When we have multiple calculations running simultaneously, we need to ensure our database can handle all these connections. Therefore, we create a connection pool which allows for thousands of connections. This \"pool\" operates like a waitlist where the database handles each connection request in sequence.</p> <ol> <li>Select the \"Connection Pools\" tab and then \"Create a Connection Pool\"</li> <li>Name your pool <code>simmate-database-00-pool</code> and select <code>simmate-database-00</code> for the database</li> <li>Select \"Transaction\" for our mode (the default) and set our pool size to 10 (or adjust this value as needed)</li> <li>Create the pool when ready!</li> <li>You'll need to update your <code>my_env-settings.yaml</code> file to these connection settings. At this point your file will look similar to this (note, our NAME and PORT values have changed): <pre><code>database:\n  engine: django.db.backends.postgresql\n  host: db-postgresql-nyc3-49797-do-user-8843535-0.b.db.ondigitalocean.com\n  name: simmate-database-00-pool  # THIS LINE WAS UPDATED\n  user: doadmin\n  password: asd87a9sd867fasd\n  port: 25061\n  options:\n    sslmode: require\n</code></pre></li> </ol> <p>Warning</p> <p>Calling <code>simmate database reset</code> when using a connection pool will NOT work! If you ever need to reset your database, ensure you connect to the database directly instead of through a database pool.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#vii-loading-third-party-data","title":"(vii) Loading third-party data","text":"<p>This step is optional.</p> <p>With Sqlite, we could download a prebuilt database with data from third parties already in it. However, creating our Postgres database means our database is entirely empty.</p> <p>To load ALL third-party data (~10GB total), you can use the following command. We can also use Dask to run this in parallel and speed things up. Depending on your internet connection and CPU speed, this can take up to 24 hours.</p> <pre><code>simmate database load-remote-archives --parallel\n</code></pre> <p>Warning</p> <p><code>--parallel</code> will use all cores on your CPU. Keep this in mind if you are running other programs/calculations on your computer already.</p>"},{"location":"getting_started/use_a_cloud_database/build_a_postgres_database/#viii-sharing-the-database","title":"(viii) Sharing the database","text":"<p>If you want to share this database with others, they simply need to copy your config file: <code>my_env-settings.yaml</code>. They won't need to run <code>simmate database reset</code> because you did it for them.</p>"},{"location":"getting_started/use_a_cloud_database/private_vs_collab/","title":"Should I Create My Own Database?","text":""},{"location":"getting_started/use_a_cloud_database/private_vs_collab/#sharing-a-database-with-others","title":"Sharing a Database with Others","text":"<p>A cloud database allows you to store your results on a remote server via an internet connection. Once a database is established, you can add unlimited users and connections. </p> <p>If you're part of a team, only ONE member needs to set up and manage ONE cloud database. Collaboration is possible for anyone with a username and password.</p>"},{"location":"getting_started/use_a_cloud_database/private_vs_collab/#collaborating-with-the-warren-lab","title":"Collaborating with the Warren Lab","text":"<p>Ideally, the entire scientific community could work together, sharing their results. Our Simmate team encourages as many labs as possible to collaborate. If you're interested in joining this effort, simply email simmate.team@gmail.com. As a team member, you won't need to set up or manage any cloud database.</p>"},{"location":"getting_started/use_a_cloud_database/private_vs_collab/#using-a-private-database","title":"Using a Private Database","text":"<p>If you prefer a private database for your team, appoint one member as the database manager. This person alone needs to complete the next section (on setting up your cloud database). All other members should wait for connection information before proceeding to the final section (on connecting to your cloud database).</p> <p>In summary, only establish your own cloud database if:</p> <ol> <li>You prefer a private database over Simmate's collaborative effort.</li> <li>You are the designated manager of your team's private database.</li> </ol>"},{"location":"getting_started/use_a_cloud_database/private_vs_collab/#connecting-to-a-cloud-database","title":"Connecting to a Cloud Database","text":"<p>If you're collaborating with someone who has already set up a database, connecting to it will be straightforward. </p> <p>Once you have your cloud database's connection parameters, create the file <code>~/simmate/my_env-settings.yaml</code> (if it isn't there already) and input the connection parameters provided by your point-person. For example, the following can be added to your settings file: <pre><code>database:\n  ENGINE: django.db.backends.postgresql\n  HOST: simmate-database-do-user-8843535-0.b.db.ondigitalocean.com\n  NAME: simmate-database-00-pool\n  USER: doadmin\n  PASSWORD: ryGEc5PDxC2IHDSM\n  PORT: 25061\n  OPTIONS:\n    sslmode: require\n</code></pre></p> <p>That's all! When you run a new workflow, results will be saved to this cloud database instead of your local file.</p> <p>Danger</p> <p>If your lab uses postgres, ensure you have the necessary database dependencies installed. For postgres, execute the command: <pre><code>conda install -n my_env -c conda-forge psycopg2\n</code></pre></p>"},{"location":"getting_started/use_a_cloud_database/quick_start/","title":"Utilize a Cloud Database","text":""},{"location":"getting_started/use_a_cloud_database/quick_start/#quick-guide","title":"Quick Guide","text":"<ol> <li> <p>Consider joining forces! Simmate is designed for sharing results, so reach out to <code>simmate.team@gmail.com</code> to discuss becoming part of our team. This will help you bypass the complexities of managing your own database. If you decide to join, you'll only need to follow steps 3 and 4 of this guide.</p> </li> <li> <p>Establish a cloud database that is supported by django. We strongly suggest using Postgres as well as setting up a connection pool for your database. If you need assistance with this setup, you can utilize our \"deploy\" button in the following section. A 10GB database is sufficient to begin with.</p> </li> <li> <p>Ensure you have the necessary database dependencies installed. For example for postgres, execute the following command: <pre><code>conda install -n my_env -c conda-forge psycopg2\n</code></pre></p> </li> <li> <p>Update the file <code>~/simmate/my_env-settings.yaml</code> with your connection details that align with the django format. For example, the following can be added to your settings file: <pre><code>database:\n  engine: django.db.backends.postgresql\n  host: simmate-database-do-user-8843535-0.b.db.ondigitalocean.com\n  name: simmate-database-00-pool\n  user: doadmin\n  password: ryGEc5PDxC2IHDSM\n  port: 25061\n  options:\n    sslmode: require\n</code></pre></p> </li> <li> <p>If you have created a brand new database in step 2, you will need to reset your database to build initial tables. Use the command <code>simmate database reset</code> to do this.  Do NOT execute this command if you have joined a shared database!</p> </li> </ol>"},{"location":"getting_started/use_a_cloud_database/quick_start/#setup-with-digital-ocean","title":"Setup with Digital Ocean","text":"<p>We recommend using Postgres via DigitalOcean. If you don't have a Digital Ocean account, please sign up using our referral link. The button below will direct you to the appropriate page.</p> <p> </p>"},{"location":"getting_started/use_a_cloud_database/quick_start/#setup-with-docker-desktop","title":"Setup with Docker-Desktop","text":"<p>If you would like to practice with Postgres on your local computer, you can use:</p> <pre><code>docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres\n</code></pre> <p>Refer to the offical guide here.</p>"},{"location":"getting_started/workflows/configure_database/","title":"Database Configuration","text":""},{"location":"getting_started/workflows/configure_database/#what-is-the-database","title":"What is the database?","text":"<p>The Simmate database is just a list of tables -- so you can imagine an Excel spreadsheet where there are a bunch of pre-set tables and column headers. Simmate then fills the table with data whenever we run workflows. </p> <p>Example</p> <p>Let's say we want a table for crystal structures. It would have columns for formula, density, and number of sites, among other things. Likewise, a static-energy calculation would have columns for final energy, CPU time, and more. Rather than build &amp; fill these tables from scratch, we let Simmate handle all of this.</p> <p>Note</p> <p>Our database tutorial will come after we learn about workflows. For now, just know we building the database so that we have somewhere to store results.</p>"},{"location":"getting_started/workflows/configure_database/#1-database-initialization","title":"1. Database Initialization","text":"<p>To create the database, run the following command. Say yes to each prompt too:</p> <pre><code>simmate database reset\n</code></pre> <p>And that's it! With just one command, our database is ready for use. We can now run workflows and start filling it with data. </p> <p>Warning</p> <p>Be aware that running the command <code>simmate database reset</code> will delete your existing database and replace it with an empty one. To keep your previous data, make sure to backup your database by copying and pasting the database file.</p>"},{"location":"getting_started/workflows/configure_database/#2-locating-the-database-file","title":"2. Locating the Database File","text":"<p>After running <code>simmate database reset</code>, the database can be located in a file named <code>~/simmate/my_env-database.sqlite3</code>.</p> <p>To find this file, remember that <code>~</code> is shorthand for our home directory, which is typically something like <code>/home/johnsmith/</code> or <code>C:\\Users\\johnsmith</code>.</p> <p>This file can't be opened by double-clicking. Just as Excel is needed to open and read Excel (<code>.xlsx</code>) files, a separate program is required to read database (<code>.sqlite3</code>) files. We'll use Simmate (&amp; DBeaver) for this later.</p> <p>Note</p> <p>Note that the name of your conda environment (<code>my_env</code> in this case) is part of the database file name. This is a Simmate feature that lets you switch between databases by simply changing your Anaconda environment. This is especially handy when testing and developing new workflows, which we'll discuss in a future tutorial.</p>"},{"location":"getting_started/workflows/configure_qe/","title":"Setting Up Quantum Espresso","text":""},{"location":"getting_started/workflows/configure_qe/#what-is-quantum-espresso-qe","title":"What is Quantum Espresso (QE)?","text":"<p>Quantum Espresso (QE) is a widely used software for running DFT calculations. </p> <p>There are also many other programs which do the same thing as QE, such as VASP, Abinit, and CASTEP. Simmate can be used alongside any of these programs, but (at the moment) Simmate only includes pre-built workflows for VASP and Quantum Espresso.</p> <p>This tutorial will use QE because it is free &amp; open-source.</p>"},{"location":"getting_started/workflows/configure_qe/#1-install-qe-using-docker","title":"1. Install QE using Docker","text":"<p>Warning</p> <p> IMPORTANT </p> <p>Docker is used in order to help beginners that are using their local laptop or desktop. In practice, most researchers will have a university cluster with QE or some other DFT software installed for them. </p> <p>Beginners: stick to your laptop &amp; Docker for now.</p> <p>Experienced Programmers: you may ignore any Docker setup. Simply ensure the <code>pw.x</code> executable is available in your <code>PATH</code>. See the official QE installation guides if you need them (link).</p>"},{"location":"getting_started/workflows/configure_qe/#i-why-docker","title":"i. Why Docker?","text":"<p>Most DFT programs can only be installed on Linux and are incompatible with Windows and Mac. And even on Linux, installing such software can be challenging for users. While QE is comparatively more manageable, it remains a significant hurdle for beginners.</p> <p>To get around this, we will use Docker. Docker simplifies the process for users without coding experience by eliminating complex setup procedures. Similar to Anaconda's isolated \"environments\" for Python packages, Docker employs isolated \"containers\" with everything necessary for a package to run, including the operating system.</p>"},{"location":"getting_started/workflows/configure_qe/#ii-install-docker-desktop","title":"ii. Install Docker-Desktop","text":"<p>Download install Docker-Desktop. You do not need to make an account.</p> <p>This will install the <code>docker</code> command for you and let you monitor all running containers.</p> <p>To confirm docker is working properly, run the command: <pre><code>docker run hello-world\n</code></pre></p> <p>Read through the output of this command, you will see somewhere this text: <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n</code></pre></p> <p>Seeing an error? Here are the two most common causes: </p> <p>Troubeshooting</p> <p>If you see an error such as... <pre><code>docker: error during connect: This error may indicate that the docker daemon is not running. ...\n</code></pre></p> <p>... then this means you don't have Docker-Desktop open &amp; running. Open the app (and leave it open) when running <code>docker</code> commands.</p> <p>Troubeshooting</p> <p>If you see an error such as...</p> <pre><code>docker: permission denied while trying to connect to the Docker daemon socket at unix: ...\n</code></pre> <p>...then you are likely a Linux user and don't have <code>sudo</code> permissions yet. To give <code>sudo</code> permissions to <code>docker</code>, read the official guides here. For example, on Ubuntu, you can get docker set up and running using: <pre><code>sudo snap install docker\nsudo groupadd docker\nsudo usermod -aG docker $USER\n# Then restart your computer\n</code></pre></p> <p>If you are on a shared computer system &amp; do not have <code>sudo</code> permissons (e.g. you are on a shared HPC cluster), then Docker likely isn't a good solution for you. Make sure you read the \"Submit to a Cluster\" section of this <code>Workflows</code> guide for more information.</p>"},{"location":"getting_started/workflows/configure_qe/#iii-tell-simmate-to-use-docker","title":"iii. Tell Simmate to use Docker","text":"<p>By default, Simmate assumes QE is installed on your computer. But here, we have QE installed within a Docker container, so QE commands such as <code>pw.x</code> are only accessible inside a docker container. We therefore need tell Simmate that we are using Docker for QE.</p> <p>Run this command to tell Simmate to use Docker for QE-based workflows: <pre><code>simmate config update \"quantum_espresso.docker.enable=True\"\n</code></pre></p>"},{"location":"getting_started/workflows/configure_qe/#2-configure-psuedo-files","title":"2. Configure Psuedo Files","text":"<p>To run calculations with QE, we need psuedopotentials. Normally, you have to find, download, and configure these on your own. Simmate helps load these from the popular SSSP library.</p> <p>Run the following command to set up your files: <pre><code>simmate-qe setup sssp\n</code></pre></p> <p>Tip</p> <p>To see what this command did, take a look at <code>~/simmate</code> and you'll see the following update: <pre><code># Located at ~ (e.g. /home/johnsmith)\nsimmate\n\u2514\u2500\u2500 quantum_espresso\n    \u2514\u2500\u2500 potentials\n        \u2514\u2500\u2500 &lt;&lt; all of your psuedo files! &gt;&gt;\n</code></pre></p>"},{"location":"getting_started/workflows/configure_qe/#3-test-your-qe-configuration","title":"3. Test Your QE Configuration","text":"<p>Let's make sure we've done the following correctly:</p> <ol> <li>Installed QE -- or -- installed Docker + used <code>simmate config update</code></li> <li>Used <code>simmate-qe setup sssp</code> to download our potentials</li> </ol> <p>Run this command to check everything:</p> <pre><code>simmate config test quantum_espresso\n</code></pre> <p>If all the checks pass, you're ready to run workflows!</p>"},{"location":"getting_started/workflows/make_a_structure/","title":"Creating a Structure File","text":"<p>Before running a workflow, we need a crystal structure or a molecule. In this tutorial, we'll use a crystal structure, but the same process applies to molecular systems.</p> <p>There are numerous ways to obtain a crystal structure, such as downloading one online or creating one from scratch. Here, we will create a structure file from scratch so that we understand the information it contains.</p>"},{"location":"getting_started/workflows/make_a_structure/#understanding-file-extensions","title":"Understanding File Extensions","text":"<p>Most computer files you will interact with are text files, but have text organized with a specific pattern/format. This is where file extensions come in (<code>.txt</code>, <code>.cif</code>, <code>.csv</code>, <code>.pdf</code>, ...). </p> <p>These extensions indicate the format we are using. For example, files named <code>example.cif</code> inform programs that we have a text file written in the CIF structure format. The <code>.cif</code> extension can tell us stuff like \"the first line of the file represents the chemical formula\" and so forth.</p> <p>One popular format in material's science is made by VASP. VASP is unique because it uses the name <code>POSCAR</code> (without any file extension) to indicate its format. This isn't best practice, but it is import to keep in mind when reading files.</p> <p>Fun-fact</p> <p>A Microsoft Word document is essentially a folder of text files. The .docx file extension tells Word that we have the folder in their desired format. Try renaming a word file from <code>my_file.docx</code> to <code>my_file.zip</code> and open it to explore. Most programs operate in a similar manner!</p>"},{"location":"getting_started/workflows/make_a_structure/#creating-a-poscar-file","title":"Creating a POSCAR File","text":"<ol> <li> <p>create a new text file named <code>POSCAR.txt</code>. You can use any text editor of your choice (Notepad, Sublime, etc.). Alternatively, you can create the file using the command line: <pre><code>nano POSCAR.txt\n</code></pre></p> </li> <li> <p>Ensure that the <code>.txt</code> extension is visible by enabling \"show file name extensions\" in your File window.</p> <p>Example</p> <p>To do this on Windows 10:</p> <ol> <li>Open File Explorer</li> <li>Click the View tab in File Explorer</li> <li>Click the box next to File name extensions to see file extensions</li> </ol> </li> <li> <p>copy and paste the following text into the file: <pre><code>Na1 Cl1\n1.0\n3.485437 0.000000 2.012318\n1.161812 3.286101 2.012318\n0.000000 0.000000 4.024635\nNa Cl\n1 1\ndirect\n0.000000 0.000000 0.000000 Na\n0.500000 0.500000 0.500000 Cl\n</code></pre> This text represents a structure, which consists of a lattice and a list of atomic sites. The lattice is defined by a 3x3 matrix (lines 3-5), and the sites are a list of xyz coordinates with an element (lines 8-9 show fractional coordinates). </p> </li> <li> <p>Rename your file from <code>POSCAR.txt</code> file to <code>POSCAR</code>. If you're using the command-line to create/edit this file, you can use the copy (<code>cp</code>) command to rename it: <pre><code>cp POSCAR.txt POSCAR\n</code></pre></p> <p>Note</p> <p>On Windows, you may receive a warning about changing the file extension. You can safely ignore this warning and change the extension.</p> </li> <li> <p>Your structure file is now ready to use!</p> </li> </ol>"},{"location":"getting_started/workflows/make_a_structure/#exploring-a-different-format-cif","title":"Exploring a Different Format (cif)","text":"<p>There are various ways to write structure information. The example above uses the VASP's \"POSCAR\" format. Another common format is CIF (Crystallographic Information File). Although it's not as neat as a POSCAR, it contains similar information. You can use CIFs, POSCAR, and many other formats when using Simmate.</p> <p>For example, this would be a file named <code>NaCl.cif</code>: <pre><code>data_NaCl\n_symmetry_space_group_name_H-M   'P 1'\n_cell_length_a   4.02463542\n_cell_length_b   4.02463542\n_cell_length_c   4.02463542\n_cell_angle_alpha   60.00000000\n_cell_angle_beta   60.00000000\n_cell_angle_gamma   60.00000000\n_symmetry_Int_Tables_number   1\n_chemical_formula_structural   NaCl\n_chemical_formula_sum   'Na1 Cl1'\n_cell_volume   46.09614833\n_cell_formula_units_Z   1\nloop_\n _symmetry_equiv_pos_site_id\n _symmetry_equiv_pos_as_xyz\n  1  'x, y, z'\nloop_\n _atom_site_type_symbol\n _atom_site_label\n _atom_site_symmetry_multiplicity\n _atom_site_fract_x\n _atom_site_fract_y\n _atom_site_fract_z\n _atom_site_occupancy\n  Na  Na0  1  0.00000000  0.00000000  0.00000000  1\n  Cl  Cl1  1  0.50000000  0.50000000  0.50000000  1\n</code></pre></p>"},{"location":"getting_started/workflows/make_a_structure/#molecular-formats","title":"Molecular Formats","text":"<p>While we're focusing on crystal structures for this tutorial, keep in mind that molecular compounds have their own formats too. For example, the molecule for Apirin can be represented in several ways:</p> <ul> <li> <p>In the SMILES format (<code>example.smi</code> files): <pre><code>CC(=O)OC1=CC=CC=C1C(=O)O\n</code></pre></p> <p>Note</p> <p>The SMILES format includes only bonding information, and it does not include XY or XYZ coordinates for each atom. This means the 2D orientation (and 3D conformation) of whatever compound you have is lost in the SMILES format. Still, it's a handy and easy format because of how small the text file is.</p> </li> <li> <p>In the Structure Data File (SDF) format (<code>example.sdf</code> files): <pre><code>     RDKit          2D\n\n 13 13  0  0  0  0  0  0  0  0999 V2000\n    5.2500   -1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.7500   -1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.0000   -2.5981    0.0000 O   0  0  0  0  0  0  0  0  0  0  0  0\n    3.0000    0.0000    0.0000 O   0  0  0  0  0  0  0  0  0  0  0  0\n    1.5000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7500   -1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.7500   -1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -1.5000    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.7500    1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7500    1.2990    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.5000    2.5981    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0\n    0.7500    3.8971    0.0000 O   0  0  0  0  0  0  0  0  0  0  0  0\n    3.0000    2.5981    0.0000 O   0  0  0  0  0  0  0  0  0  0  0  0\n  1  2  1  0\n  2  3  2  0\n  2  4  1  0\n  4  5  1  0\n  5  6  2  0\n  6  7  1  0\n  7  8  2  0\n  8  9  1  0\n  9 10  2  0\n 10 11  1  0\n 11 12  2  0\n 11 13  1  0\n 10  5  1  0\nM  END\n</code></pre></p> <p>Note</p> <p>You can see each line is a single atom in an SDF. The first three numbers are the XYZ coordinates, where all of our Z values are 0 in this example (meaning we have a 2D drawing of the molecule!). The remaining numbers include bonding and stereochemistry information.</p> </li> </ul>"},{"location":"getting_started/workflows/quick_start/","title":"Explore &amp; Run Workflows","text":""},{"location":"getting_started/workflows/quick_start/#quick-start","title":"Quick Start","text":"<p>Tip</p> <p>The majority of this guide covers initial setup for first-time users. For subsequent workflow runs, only steps 8-10 are necessary.</p> <ol> <li> <p>Initialize your Simmate database, which will be created at <code>~/simmate/my_env-database.sqlite3</code> and where <code>my_env</code> is the name of your active conda environment: <pre><code>simmate database reset\n</code></pre></p> </li> <li> <p>Create a structure file for sodium chloride, which we will use to practice calculations. Name it <code>POSCAR</code> and add the following text to it: <pre><code>Na1 Cl1\n1.0\n3.485437 0.000000 2.012318\n1.161812 3.286101 2.012318\n0.000000 0.000000 4.024635\nNa Cl\n1 1\ndirect\n0.000000 0.000000 0.000000 Na\n0.500000 0.500000 0.500000 Cl\n</code></pre></p> </li> <li> <p>Use the following command to view a list of all available workflows: <pre><code>simmate workflows list-all\n</code></pre></p> </li> <li> <p>Learn about all workflows interactively with the following command: <pre><code>simmate workflows explore\n</code></pre></p> <p>Note</p> <p>There are a variety of software options for QM, DFT, or other analyses (e.g., VASP, Abinit, QE, LAMMPS, etc.). In this tutorial, we will use Quantum Espresso because we have Docker images for those who don't have it installed. If you prefer another program, check the <code>Apps</code> section in our guides for specific instructions.</p> </li> <li> <p>Make sure you have Quantum Espresso (QE) installed using one of two options:</p> <ul> <li>(for beginners) Install Docker-Desktop. Then run the following command:       <pre><code>simmate config update \"quantum_espresso.docker.enable=True\"\n</code></pre></li> <li> <p>(for experts) Install QE using offical guides and make sure <code>pw.x</code> is in the path</p> <p>Tip</p> <p>If you choose Docker and need help, see our guides here for installation and common errors.</p> </li> </ul> </li> <li> <p>To run calculations with QE, we need psuedopotentials. Simmate helps load these from the popular SSSP library: <pre><code>simmate-qe setup sssp\n</code></pre></p> </li> <li> <p>Make sure QE is fully configured and ready to use: <pre><code>simmate config test quantum_espresso\n</code></pre></p> </li> <li> <p>With everything configured, you can submit your workflow using the website interface, command-line, or Python. Here, we'll use a settings file in YAML format. Create a file named <code>example.yaml</code> with the following content: <pre><code>workflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\n</code></pre></p> </li> <li> <p>Run the workflow configuration file we just created: <pre><code>simmate workflows run example.yaml\n</code></pre></p> </li> <li> <p>The run will create a new folder (e.g. <code>simmate-task-abcd1234</code>) for your run. Inside, you'll find files named <code>simmate_metadata.yaml</code> and <code>simmate_summary.yaml</code> which contain some quick information. Some workflows (like <code>band-structure</code> calculations) will also generate plots for you.</p> <p>Tip</p> <p>While the plots and summary files are useful for quick testing, more detailed information is stored in our database. We'll cover how to access your database in a subsequent tutorial.</p> </li> </ol>"},{"location":"getting_started/workflows/running_the_workflow/","title":"Running a Workflow","text":"<p>Tip</p> <p>This guide covers how to run workflows with a YAML file + the command line. But keep in mind, there are other ways to run your workflows -- such as using the website interface, a python script, or <code>run-quick</code> in the command line. </p>"},{"location":"getting_started/workflows/running_the_workflow/#1-recap","title":"1. Recap","text":"<p>In the previous sections, we accomplished the following prerequisites for running a workflow:</p> <ul> <li> Configured our database for storing results</li> <li> Created a structure file to use as input</li> <li> Selected a workflow to use (<code>static-energy.quantum-espresso.quality00</code>)</li> <li> Selected QE as our DFT software &amp; configured it </li> </ul> <p>Now let's run our workflow!</p>"},{"location":"getting_started/workflows/running_the_workflow/#2-create-a-config-file","title":"2. Create a config file","text":"<p>Rather than have super long command with all of our settings, we will write our settings into a <code>YAML</code> file. </p> <p>The name of our settings file doesn't matter, so we'll just use <code>example.yaml</code>. Create this file and add the following to it:</p> <pre><code># in example.yaml\nworkflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\n</code></pre>"},{"location":"getting_started/workflows/running_the_workflow/#3-submit-the-workflow","title":"3. Submit the workflow","text":"<p>Make sure both your <code>POSCAR</code> file AND <code>example.yaml</code> files are in the same folder as your command-line's working directory. Then start your workflow run with the following command: </p> <pre><code>simmate workflows run example.yaml\n</code></pre> <p>When running the workflow, it creates a new folder (e.g., <code>simmate-task-abcd1234</code>), writes the inputs, runs the calculation, and saves the results to your database.</p> <p>Tip</p> <p>Depending on your laptop specs, this calculation can take &gt;1 minute to finish.</p>"},{"location":"getting_started/workflows/running_the_workflow/#4-view-results","title":"4. View results","text":"<p>Once you're workflow finishes, you will find additional files in your output folder (e.g., <code>simmate-task-abcd1234</code>). One such file is <code>simmate_summary.yaml</code>, which provides a brief summary of your results:</p> <pre><code>_DATABASE_TABLE_: StaticEnergy\n_TABLE_ID_: 1\n_WEBSITE_URL_: http://127.0.0.1:8000/workflows/static-energy/vasp/mit/1\nband_gap: 4.9924\nchemical_system: Cl-Na\ncomputer_system: digital-storm\nconduction_band_minimum: 4.306\ncorrections: []\ncreated_at: 2022-09-10 14:32:35.857088+00:00\ndensity: 2.1053060843576104\ndensity_atomic: 0.04338757298280908\ndirectory: /home/jacksund/Documents/spyder_wd/simmate-task-e9tddsyw\nenergy: -27.25515165\nenergy_fermi: -0.63610593\nenergy_per_atom: -3.40689395625\nformula_anonymous: AB\nformula_full: Na4 Cl4\nformula_reduced: NaCl\nid: 42\nis_gap_direct: true\nlattice_stress_norm: 8.428394235089161\nlattice_stress_norm_per_atom: 1.0535492793861452\nnelements: 2\nnsites: 8\nrun_id: 3a1bd23f-705c-4947-96fa-3740865ed12d\nsite_force_norm_max: 1.4907796617877505e-05\nsite_forces_norm: 2.257345786537809e-05\nsite_forces_norm_per_atom: 2.8216822331722614e-06\nspacegroup_id: 225\nupdated_at: 2022-09-10 14:33:09.419637+00:00\nvalence_band_maximum: -0.6864\nvolume: 184.38459332974767\nvolume_molar: 13.87987468758872\nworkflow_name: static-energy.vasp.mit\nworkflow_version: 0.10.0\n</code></pre> <p>Different workflows may generate additional files and plots. For instance, <code>electronic-structure</code> workflows compute a band structure and create an image of your final band structure named <code>band_structure.png</code>. These additional files and plots, which vary by workflow, facilitate a quick review of your results.</p> <p>In the next set of tutorials, we will explore our database and the other data stored in it.</p>"},{"location":"getting_started/workflows/running_the_workflow/#4-mastering-parameters","title":"4. Mastering parameters","text":""},{"location":"getting_started/workflows/running_the_workflow/#a-basic","title":"a. Basic","text":"<p>What if we wanted to modify the directory the workflow is ran in? Don't forget about the <code>simmate workflows explore</code> command, which listed parameters for us. We can use any of these to modify how our workflow runs.</p> <p>For instance, we can change our folder name (<code>directory</code>). With this, we can update our <code>example.yaml</code> to:</p> <pre><code>workflow_name: static-energy.quantum-espresso.quality00\nstructure: POSCAR\ndirectory: my_custom_folder  # OPTIONAL\n</code></pre> <p>and re-run:</p> <pre><code>simmate workflows run example.yaml\n</code></pre>"},{"location":"getting_started/workflows/running_the_workflow/#b-advanced","title":"b. Advanced","text":"<p>In the previous examples, we provided our input structure as a <code>POSCAR</code> -- but what if we wanted to use a different format? Or use a structure from a previous calculation or the Materials Project database?</p> <p>When we go to the <code>Parameters</code> documentation, we see that <code>structure</code> input accepts...</p> <ul> <li> cif or poscar files </li> <li> pointers to a database entry</li> <li> pointers to a third-party database</li> <li> advanced python objects</li> </ul> <p>For instance, you can try running the following workflow:</p> <pre><code>workflow_name: tatic-energy.quantum-espresso.quality00\nstructure:\n    database_table: MatprojStructure\n    database_id: mp-22862\n</code></pre> <p>Even though we didn't create a structure file, Simmate fetched one for us from the Materials Project database.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/","title":"Switching to a Remote Cluster","text":"<p>Warning</p> <p>This section may be challenging for beginners. If possible, work through it with an experienced user or someone from your IT department. Don't be discouraged if it takes more than an hour -- there's a lot to learn!</p> <p>Tip</p> <p>Moving files around or transferring them between your local computer and the supercomputer can be challenging in the command line. It's much easier with a program like FileZilla, MobaXTerm, or another file transfer program. We recommend MobaXTerm, but it's entirely optional and up to you.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#overview","title":"Overview","text":"<p>Up until now, you've been running Simmate on your local desktop or laptop. However, as we saw in the previous sections, we need a DFT software (which often requires Linux) for Simmate's workflows to run. Most of the time, you'll be using a University or Federal supercomputer (also known as \"high performance computing (HPC) clusters\"), which will already have some of this software (VASP, QE, etc.) installed.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#cluster-specific-guides","title":"Cluster-Specific Guides","text":"<p>For teams actively using Simmate, we provide additional notes and examples for submitting to specific clusters. This includes:</p> <ul> <li>WarWulf: The Warren lab's \"BeoWulf\" cluster at UNC Chapel Hill</li> <li>LongLeaf: UNC's university cluster for most use-cases (1 node limit)</li> <li>DogWood: UNC's university cluster designed for massively parallel jobs (&gt;1 node)</li> </ul> <p>Tip</p> <p>If your cluster/university is not listed, contact your IT team for assistance in completing this tutorial.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#prerequisites","title":"Prerequisites","text":"<p>For workflows to run correctly, the following requirements must be met:</p> <ul> <li> A remote cluster that you have a profile with (e.g., UNC's LongLeaf)</li> <li> Anaconda installed on the remote cluster</li> <li> QE installed on the remote cluster</li> </ul> <p>Ensure these steps are completed before proceeding.</p> <p>Tip</p> <p>For the Warren Lab, these items are already configured on <code>WarWulf</code>, <code>LongLeaf</code>, and <code>DogWood</code>.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#1-sign-in-to-the-cluster","title":"1. Sign in to the Cluster","text":"<p>If you've never signed into a remote cluster before, we will do this using SSH (Secure Shell). Run the following command in your local terminal:</p> exampleWarWulfLongLeafDogWood <pre><code>ssh my_username@my_cluster.edu\n</code></pre> <pre><code>ssh WarrenLab@warwulf.net\n</code></pre> <p>Note</p> <p>Everyone shares the profile \"WarrenLab\". Ask Scott for the password (scw@email.unc.edu)</p> <pre><code>ssh my_onyen@longleaf.unc.edu\n</code></pre> <pre><code>ssh my_username@my_cluster.edu\n</code></pre> <p>Danger</p> <p>On Windows, use your Command Prompt -- not the Anaconda Powershell Prompt.</p> <p>After entering your password, you are now using a terminal on the remote supercomputer. Try running the command <code>pwd</code> (\"print working directory\") to show that your terminal is indeed running commands on the remote cluster, not your desktop:</p> <pre><code># This is the same for all Linux clusters\npwd\n</code></pre>"},{"location":"getting_started/workflows/submit_to_a_cluster/#2-build-your-personal-simmate-environment","title":"2. Build Your Personal Simmate Environment","text":"<p>Next, we need to ensure Simmate is installed. </p> <p>If you see <code>(base)</code> at the start of your command line, Anaconda is already installed.</p> <p>If not, ask your IT team how they want you to install it. Typically, it's by using miniconda, which is just Anaconda without the graphical user interface. </p> <p>With Anaconda set up, you can create your environment and install Simmate just like we did in the first tutorial:</p> <pre><code># Create your conda environment with...\n\nconda create -n my_env -c conda-forge python=3.11 simmate\nconda activate my_env\n\n# Initialize your database on this new installation.\nsimmate database reset\n</code></pre> <p>Danger</p> <p>On WarWulf, we share a profile, so make sure you name your environment something unique. For example, use <code>yourname_env</code> (e.g., <code>jacks_env</code>).</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#3-load-configure-qe","title":"3. Load &amp; Configure QE","text":"<p>To load QE into your environment, you typically need to run a 'load module' command:</p> exampleWarWulfLongLeafDogWood <pre><code>module load qe\n</code></pre> <pre><code>module load qe\n</code></pre> <pre><code>module load qe\n</code></pre> <pre><code>module load qe\n</code></pre> <p>Then check that the <code>pw.x</code> command is found and QE configured correctly:</p> <pre><code>simmate-qe test\n</code></pre> <p>If the potentials are missing, you have Simmate download and configure them:</p> <pre><code>simmate-qe setup sssp\n</code></pre>"},{"location":"getting_started/workflows/submit_to_a_cluster/#4-move-to-your-scratch-directory","title":"4. Move to Your 'Scratch' Directory","text":"<p>Typically, clusters have a \"scratch\" directory that you should submit jobs from -- which is different from your home directory. Make sure you switch to that before submitting any workflows. Your <code>POSCAR</code> and all input files should be in this directory too:</p> exampleWarWulfLongLeafDogWood <pre><code>cd /path/to/my/scratch/space/\n</code></pre> <pre><code>cd /media/synology/user/your_name\n</code></pre> <pre><code>cd /pine/scr/j/a/jacksund\n</code></pre> <pre><code>cd /21dayscratch/scr/y/o/youronyen\n</code></pre>"},{"location":"getting_started/workflows/submit_to_a_cluster/#5-build-our-input-files","title":"5. Build Our Input Files","text":"<p>Just like we did on our laptop, we need to make our input files. For now, let's use this sample YAML file:</p> <pre><code>workflow_name: static-energy.quantum-espresso.quality00\n# instead of POSCAR, we will use MatProj\nstructure:\n    database_table: MatprojStructure\n    database_id: mp-22862\ncommand: mpirun -n 4 pw.x &lt; pwscf.in &gt; pw-scf.out  # OPTIONAL\ndirectory: my_custom_folder  # OPTIONAL\n</code></pre> <p>Put this in a file named <code>my_settings.yaml</code> in your scratch directory.</p> <p>Danger</p> <p>Take note of the <code>-n 4</code> in our command. This is the number of cores that we want our calculation to use in parallel. Make sure this number matches your  <code>cpus-per-task</code> setting in the next section.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#6-build-our-submit-script","title":"6. Build Our Submit Script","text":"<p>Earlier in this tutorial, we called <code>simmate workflows run ...</code> directly in our terminal, but this should NEVER be done on a supercomputer. Instead, we should submit the workflow to the cluster's job queue. Typically, supercomputers use SLURM or PBS to submit jobs.</p> <p>For example, UNC's <code>WarWulf</code>, <code>LongLeaf</code>, and <code>DogWood</code> clusters each use SLURM. </p> <p>To submit, we would make a file named <code>submit.sh</code>:</p> <pre><code>nano submit.sh\n</code></pre> <p>... and use contents like ...</p> exampleWarWulfLongLeafDogWood <pre><code>#! /bin/sh\n\n#SBATCH --job-name=my_example_job\n#SBATCH --nodes=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=4\n#SBATCH --mem=4GB\n#SBATCH --time=01:00:00\n#SBATCH --partition=general\n#SBATCH --output=slurm.out \n#SBATCH --mail-type=ALL \n#SBATCH --mail-user=my_username@live.unc.edu\n\nsimmate workflows run my_settings.yaml\n</code></pre> <pre><code>#!/bin/bash\n\n#. /opt/ohpc/pub/suppress.sh  #suppress infiniband output, set vasp path\n\n#SBATCH --job-name=my_example_job\n#SBATCH --nodes=1\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=4\n#SBATCH --mem=4GB\n#SBATCH --time=01:00:00\n#SBATCH --partition=p1\n#SBATCH --output=slurm.out \n#SBATCH --mail-type=ALL \n#SBATCH --mail-user=my_username@live.unc.edu\n\nsimmate workflows run my_settings.yaml\n</code></pre> <pre><code>#! /bin/sh\n\n#SBATCH --job-name=my_example_job\n#SBATCH --nodes=20\n#SBATCH --ntasks=1\n#SBATCH --mem=40g\n#SBATCH --partition=general\n#SBATCH --output=slurm.out\n#SBATCH --mail-type=FAIL\n#SBATCH --mail-user=youronyen@live.unc.edu\n#SBATCH --time=11-00:00\n\nsimmate workflows run my_settings.yaml\n</code></pre> <p>Danger</p> <p>Note the large <code>ntasks</code> and <code>node</code> values here. DogWood is only meant for large calculations, so talk with our team before submitting.</p> <pre><code>#!/bin/sh\n\n#SBATCH --job-name=NEB\n#SBATCH --ntasks=704\n#SBATCH --nodes=16\n#SBATCH --time=2-00:00\n#SBATCH --mem=300g\n#SBATCH --partition=2112_queue\n#SBATCH --mail-type=ALL\n#SBATCH --mail-user=lamcrae@live.unc.edu\n\nsimmate workflows run my_settings.yaml\n</code></pre> <p>Info</p> <p>Each of these <code>SBATCH</code> parameters sets how we would like to submit a job and how many resources we expect to use. These are explained in SLURM's documentation for sbatch, but you may need help from your IT team to update them. But to break down these example parameters...</p> <ul> <li><code>job-name</code>: the name that identifies your job. It will be visible when you check the status of your job.</li> <li><code>nodes</code>: the number of server nodes (or CPUs) that you request. Typically leave this at 1.</li> <li><code>ntasks</code>: the number tasks that you'll be running. We run one workflow at a time here, so we use 1.</li> <li><code>cpus-per-task</code>: the number of CPU tasks required for each run. We run our workflow using 4 cores (<code>mpirun -n 4</code>), so we need to request 4 cores for it here.</li> <li><code>mem</code>: the memory requested for this job. If it is exceeded, the job will be terminated.</li> <li><code>time</code>: the maximum time requested for this job. If it is exceeded, the job will be terminated.</li> <li><code>partition</code>: the group of nodes that we request resources on. You can often remove this line and use the cluster's default.</li> <li><code>output</code>: the name of the file to write the job output (including errors).</li> <li><code>mail-type</code> + <code>mail-user</code>: will send an email alerts when a jobs starts/stops/fails/etc.</li> </ul>"},{"location":"getting_started/workflows/submit_to_a_cluster/#7-double-check-everything","title":"7. Double Check Everything","text":"<p>Let's go back through our checklist before we submit:</p> <ul> <li> Loaded the Quantum Espresso module</li> <li> Activated your conda environment</li> <li> In the temporary working directory</li> <li> Have our <code>yaml</code> file (+ extra inputs like a POSCAR) in the directory</li> <li> Have our <code>submit.sh</code> in the directory</li> <li> Structure file (e.g., <code>POSCAR</code>) is present in working directory</li> </ul> <p>If all of these are set, you're good to go.</p>"},{"location":"getting_started/workflows/submit_to_a_cluster/#8-submit-a-workflow-to-the-queue","title":"8. Submit a Workflow to the Queue","text":"<p>Finally, let's submit to our cluster! </p> <pre><code>sbatch submit.sh\n</code></pre>"},{"location":"getting_started/workflows/submit_to_a_cluster/#9-monitor-its-progress","title":"9. Monitor Its Progress","text":"<p>You can then monitor your job's progress with:</p> exampleWarWulfLongLeafDogWood <pre><code>squeue -u my_username\n</code></pre> <pre><code>sq\n# or\nsq | grep my_name\n</code></pre> <p>Example</p> <p><code>sq | grep jack</code></p> <pre><code>squeue -u my_onyen\n</code></pre> <pre><code>squeue -u my_onyen\n</code></pre>"},{"location":"getting_started/workflows/submit_to_a_cluster/#10-success","title":"10. Success!","text":"<p>Congratulations! You've now submitted a Simmate workflow to a remote cluster   !!! </p> <p>Tip</p> <p>Be sure to review this section a few times before moving on. Submitting remote jobs can be tedious, but it's important to understand. Advanced features of Simmate will let you skip a lot of this work down the road, but that won't happen until we reach the \"Adding Computational Resources\" guide.</p>"},{"location":"getting_started/workflows/view_all_workflows/","title":"Exploring Available Workflows","text":"<p>Warning</p> <p>Keep in mind that only the default Simmate workflows will show in this section! To explore others, you'll need to through the Apps tab of our documentation.</p>"},{"location":"getting_started/workflows/view_all_workflows/#accessing-all-workflows","title":"Accessing All Workflows","text":"<p>Simmate can be used to compute a material's energy, structure, or properties. For each of these needs, we have preconfigured workflows. You can access these via the <code>simmate workflows</code> command.</p> <p>To view all available workflows, run:</p> <pre><code>simmate workflows list-all\n</code></pre> <p>The output will resemble the following:</p> <pre><code>These are the workflows that have been registered:\n        (01) customized.vasp.user-config\n        (02) diffusion.vasp.neb-all-paths-mit\n        (03) diffusion.vasp.neb-from-endpoints-mit\n        (04) diffusion.vasp.neb-from-images-mit\n        (05) diffusion.vasp.neb-single-path-mit\n        (06) dynamics.vasp.matproj\n        (07) dynamics.vasp.mit\n        (08) dynamics.vasp.mvl-npt\n        (09) electronic-structure.vasp.matproj-full\n  ... &lt;&lt; additional workflows truncated for brevity &gt;&gt;\n</code></pre> <p>Note</p> <p>All workflows are named using the format <code>{type}.{app}.{preset}</code>:</p> <ol> <li><code>type</code>: The type of property/analysis</li> <li><code>app</code>: The program(s) used in the workflow</li> <li><code>preset</code>: The name of settings/preset used</li> </ol>"},{"location":"getting_started/workflows/view_all_workflows/#understanding-a-workflow","title":"Understanding a Workflow","text":"<p>Next, use the <code>explore</code> command for a more interactive way to view the available workflows.</p> <pre><code>simmate workflows explore\n</code></pre> <p>When prompted, select a workflow type or a specific preset. A description of the chosen workflow will be displayed at the end.</p> <p>For example, here's the output of the <code>relaxation.vasp.staged</code> workflow, frequently used in our evolutionary search algorithm. This output was obtained by running <code>simmate workflows explore</code>, selecting <code>relaxation</code>, then <code>vasp</code>, and then <code>staged</code>:</p> <pre><code>===================== relaxation.vasp.staged =====================\n\n\nDescription:\n\nRuns a series of increasing-quality relaxations and then finishes with a single static energy calculation.\n\nThis workflow is most useful for randomly-created structures or extremely large supercells. More precise relaxations+energy calcs should be done\nafterwards because ettings are still below MIT and Materials Project quality.\n\n\nParameters:\n\nREQUIRED PARAMETERS\n--------------------\n- structure\n\nOPTIONAL PARAMETERS (+ their defaults):\n---------------------------------------\n- command: null\n- source: null\n- directory: null\n- run_id: null\n- compress_output: false\n\n*** 'null' indicates the parameter is set with advanced logic\n\nTo understand each parameter, you can read through our parameter docs, which give full descriptions and examples.\n\n\n==================================================================\n</code></pre>"},{"location":"getting_started/workflows/view_all_workflows/#understanding-parameters","title":"Understanding Parameters","text":"<p>In the above message, there's a reference to our Parameter docs. You can access this page by clicking the Parameters section at the top of this webpage (or click here).</p> <p>This page provides a comprehensive list of ALL parameters for ALL workflows. If you want to learn more about a specific input, this is your go-to resource.</p>"},{"location":"getting_started/workflows/view_all_workflows/#choosing-a-workflow-for-practice","title":"Choosing a Workflow for Practice","text":"<p>For the remainder of this tutorial, we will use the <code>static-energy.quantum-espresso.quality00</code> workflow, which performs a basic static energy calculation.</p> <p>Take a look at this workflow using <code>simmate workflows explore</code> before moving on.</p>"}]}